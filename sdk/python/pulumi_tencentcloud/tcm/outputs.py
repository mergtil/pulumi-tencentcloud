# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AccessLogConfigCls',
    'AccessLogConfigSelectedRange',
    'AccessLogConfigSelectedRangeItem',
    'ClusterAttachmentClusterList',
    'MeshConfig',
    'MeshConfigInject',
    'MeshConfigIstio',
    'MeshConfigIstioSmartDns',
    'MeshConfigIstioTracing',
    'MeshConfigIstioTracingApm',
    'MeshConfigIstioTracingZipkin',
    'MeshConfigPrometheus',
    'MeshConfigPrometheusCustomProm',
    'MeshConfigSidecarResources',
    'MeshConfigSidecarResourcesLimit',
    'MeshConfigSidecarResourcesRequest',
    'MeshConfigTracing',
    'MeshConfigTracingApm',
    'MeshConfigTracingZipkin',
    'MeshTagList',
    'PrometheusAttachmentPrometheus',
    'PrometheusAttachmentPrometheusCustomProm',
    'TracingConfigApm',
    'TracingConfigZipkin',
    'GetMeshMeshListResult',
    'GetMeshMeshListConfigResult',
    'GetMeshMeshListConfigIstioResult',
    'GetMeshMeshListConfigIstioSmartDnResult',
    'GetMeshMeshListTagListResult',
]

@pulumi.output_type
class AccessLogConfigCls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logSet":
            suggest = "log_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessLogConfigCls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessLogConfigCls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessLogConfigCls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 log_set: Optional[str] = None,
                 topic: Optional[str] = None):
        pulumi.set(__self__, "enable", enable)
        if log_set is not None:
            pulumi.set(__self__, "log_set", log_set)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="logSet")
    def log_set(self) -> Optional[str]:
        return pulumi.get(self, "log_set")

    @property
    @pulumi.getter
    def topic(self) -> Optional[str]:
        return pulumi.get(self, "topic")


@pulumi.output_type
class AccessLogConfigSelectedRange(dict):
    def __init__(__self__, *,
                 all: Optional[bool] = None,
                 items: Optional[Sequence['outputs.AccessLogConfigSelectedRangeItem']] = None):
        if all is not None:
            pulumi.set(__self__, "all", all)
        if items is not None:
            pulumi.set(__self__, "items", items)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.AccessLogConfigSelectedRangeItem']]:
        return pulumi.get(self, "items")


@pulumi.output_type
class AccessLogConfigSelectedRangeItem(dict):
    def __init__(__self__, *,
                 gateways: Optional[Sequence[str]] = None,
                 namespace: Optional[str] = None):
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")


@pulumi.output_type
class ClusterAttachmentClusterList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "subnetId":
            suggest = "subnet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAttachmentClusterList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAttachmentClusterList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAttachmentClusterList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: str,
                 region: str,
                 role: str,
                 type: str,
                 vpc_id: str,
                 subnet_id: Optional[str] = None):
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> str:
        return pulumi.get(self, "cluster_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")


@pulumi.output_type
class MeshConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sidecarResources":
            suggest = "sidecar_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inject: Optional['outputs.MeshConfigInject'] = None,
                 istio: Optional['outputs.MeshConfigIstio'] = None,
                 prometheus: Optional['outputs.MeshConfigPrometheus'] = None,
                 sidecar_resources: Optional['outputs.MeshConfigSidecarResources'] = None,
                 tracing: Optional['outputs.MeshConfigTracing'] = None):
        if inject is not None:
            pulumi.set(__self__, "inject", inject)
        if istio is not None:
            pulumi.set(__self__, "istio", istio)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if sidecar_resources is not None:
            pulumi.set(__self__, "sidecar_resources", sidecar_resources)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @property
    @pulumi.getter
    def inject(self) -> Optional['outputs.MeshConfigInject']:
        return pulumi.get(self, "inject")

    @property
    @pulumi.getter
    def istio(self) -> Optional['outputs.MeshConfigIstio']:
        return pulumi.get(self, "istio")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional['outputs.MeshConfigPrometheus']:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter(name="sidecarResources")
    def sidecar_resources(self) -> Optional['outputs.MeshConfigSidecarResources']:
        return pulumi.get(self, "sidecar_resources")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.MeshConfigTracing']:
        return pulumi.get(self, "tracing")


@pulumi.output_type
class MeshConfigInject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeIpRanges":
            suggest = "exclude_ip_ranges"
        elif key == "holdApplicationUntilProxyStarts":
            suggest = "hold_application_until_proxy_starts"
        elif key == "holdProxyUntilApplicationEnds":
            suggest = "hold_proxy_until_application_ends"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigInject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigInject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigInject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_ip_ranges: Optional[Sequence[str]] = None,
                 hold_application_until_proxy_starts: Optional[bool] = None,
                 hold_proxy_until_application_ends: Optional[bool] = None):
        if exclude_ip_ranges is not None:
            pulumi.set(__self__, "exclude_ip_ranges", exclude_ip_ranges)
        if hold_application_until_proxy_starts is not None:
            pulumi.set(__self__, "hold_application_until_proxy_starts", hold_application_until_proxy_starts)
        if hold_proxy_until_application_ends is not None:
            pulumi.set(__self__, "hold_proxy_until_application_ends", hold_proxy_until_application_ends)

    @property
    @pulumi.getter(name="excludeIpRanges")
    def exclude_ip_ranges(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "exclude_ip_ranges")

    @property
    @pulumi.getter(name="holdApplicationUntilProxyStarts")
    def hold_application_until_proxy_starts(self) -> Optional[bool]:
        return pulumi.get(self, "hold_application_until_proxy_starts")

    @property
    @pulumi.getter(name="holdProxyUntilApplicationEnds")
    def hold_proxy_until_application_ends(self) -> Optional[bool]:
        return pulumi.get(self, "hold_proxy_until_application_ends")


@pulumi.output_type
class MeshConfigIstio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundTrafficPolicy":
            suggest = "outbound_traffic_policy"
        elif key == "disableHttpRetry":
            suggest = "disable_http_retry"
        elif key == "disablePolicyChecks":
            suggest = "disable_policy_checks"
        elif key == "enablePilotHttp":
            suggest = "enable_pilot_http"
        elif key == "smartDns":
            suggest = "smart_dns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 outbound_traffic_policy: str,
                 disable_http_retry: Optional[bool] = None,
                 disable_policy_checks: Optional[bool] = None,
                 enable_pilot_http: Optional[bool] = None,
                 smart_dns: Optional['outputs.MeshConfigIstioSmartDns'] = None,
                 tracing: Optional['outputs.MeshConfigIstioTracing'] = None):
        pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        if disable_http_retry is not None:
            pulumi.set(__self__, "disable_http_retry", disable_http_retry)
        if disable_policy_checks is not None:
            pulumi.set(__self__, "disable_policy_checks", disable_policy_checks)
        if enable_pilot_http is not None:
            pulumi.set(__self__, "enable_pilot_http", enable_pilot_http)
        if smart_dns is not None:
            pulumi.set(__self__, "smart_dns", smart_dns)
        if tracing is not None:
            pulumi.set(__self__, "tracing", tracing)

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> str:
        return pulumi.get(self, "outbound_traffic_policy")

    @property
    @pulumi.getter(name="disableHttpRetry")
    def disable_http_retry(self) -> Optional[bool]:
        return pulumi.get(self, "disable_http_retry")

    @property
    @pulumi.getter(name="disablePolicyChecks")
    def disable_policy_checks(self) -> Optional[bool]:
        return pulumi.get(self, "disable_policy_checks")

    @property
    @pulumi.getter(name="enablePilotHttp")
    def enable_pilot_http(self) -> Optional[bool]:
        return pulumi.get(self, "enable_pilot_http")

    @property
    @pulumi.getter(name="smartDns")
    def smart_dns(self) -> Optional['outputs.MeshConfigIstioSmartDns']:
        return pulumi.get(self, "smart_dns")

    @property
    @pulumi.getter
    def tracing(self) -> Optional['outputs.MeshConfigIstioTracing']:
        return pulumi.get(self, "tracing")


@pulumi.output_type
class MeshConfigIstioSmartDns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "istioMetaDnsAutoAllocate":
            suggest = "istio_meta_dns_auto_allocate"
        elif key == "istioMetaDnsCapture":
            suggest = "istio_meta_dns_capture"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstioSmartDns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstioSmartDns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstioSmartDns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 istio_meta_dns_auto_allocate: Optional[bool] = None,
                 istio_meta_dns_capture: Optional[bool] = None):
        if istio_meta_dns_auto_allocate is not None:
            pulumi.set(__self__, "istio_meta_dns_auto_allocate", istio_meta_dns_auto_allocate)
        if istio_meta_dns_capture is not None:
            pulumi.set(__self__, "istio_meta_dns_capture", istio_meta_dns_capture)

    @property
    @pulumi.getter(name="istioMetaDnsAutoAllocate")
    def istio_meta_dns_auto_allocate(self) -> Optional[bool]:
        return pulumi.get(self, "istio_meta_dns_auto_allocate")

    @property
    @pulumi.getter(name="istioMetaDnsCapture")
    def istio_meta_dns_capture(self) -> Optional[bool]:
        return pulumi.get(self, "istio_meta_dns_capture")


@pulumi.output_type
class MeshConfigIstioTracing(dict):
    def __init__(__self__, *,
                 apm: Optional['outputs.MeshConfigIstioTracingApm'] = None,
                 enable: Optional[bool] = None,
                 sampling: Optional[float] = None,
                 zipkin: Optional['outputs.MeshConfigIstioTracingZipkin'] = None):
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @property
    @pulumi.getter
    def apm(self) -> Optional['outputs.MeshConfigIstioTracingApm']:
        return pulumi.get(self, "apm")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def sampling(self) -> Optional[float]:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def zipkin(self) -> Optional['outputs.MeshConfigIstioTracingZipkin']:
        return pulumi.get(self, "zipkin")


@pulumi.output_type
class MeshConfigIstioTracingApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigIstioTracingApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigIstioTracingApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigIstioTracingApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class MeshConfigIstioTracingZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class MeshConfigPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProm":
            suggest = "custom_prom"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_prom: Optional['outputs.MeshConfigPrometheusCustomProm'] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional['outputs.MeshConfigPrometheusCustomProm']:
        return pulumi.get(self, "custom_prom")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class MeshConfigPrometheusCustomProm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "isPublicAddr":
            suggest = "is_public_addr"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigPrometheusCustomProm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigPrometheusCustomProm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigPrometheusCustomProm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 url: str,
                 is_public_addr: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[bool]:
        return pulumi.get(self, "is_public_addr")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class MeshConfigSidecarResources(dict):
    def __init__(__self__, *,
                 limits: Optional[Sequence['outputs.MeshConfigSidecarResourcesLimit']] = None,
                 requests: Optional[Sequence['outputs.MeshConfigSidecarResourcesRequest']] = None):
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)

    @property
    @pulumi.getter
    def limits(self) -> Optional[Sequence['outputs.MeshConfigSidecarResourcesLimit']]:
        return pulumi.get(self, "limits")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.MeshConfigSidecarResourcesRequest']]:
        return pulumi.get(self, "requests")


@pulumi.output_type
class MeshConfigSidecarResourcesLimit(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 quantity: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[str]:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class MeshConfigSidecarResourcesRequest(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 quantity: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quantity is not None:
            pulumi.set(__self__, "quantity", quantity)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quantity(self) -> Optional[str]:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class MeshConfigTracing(dict):
    def __init__(__self__, *,
                 apm: Optional['outputs.MeshConfigTracingApm'] = None,
                 enable: Optional[bool] = None,
                 sampling: Optional[float] = None,
                 zipkin: Optional['outputs.MeshConfigTracingZipkin'] = None):
        if apm is not None:
            pulumi.set(__self__, "apm", apm)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if sampling is not None:
            pulumi.set(__self__, "sampling", sampling)
        if zipkin is not None:
            pulumi.set(__self__, "zipkin", zipkin)

    @property
    @pulumi.getter
    def apm(self) -> Optional['outputs.MeshConfigTracingApm']:
        return pulumi.get(self, "apm")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter
    def sampling(self) -> Optional[float]:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def zipkin(self) -> Optional['outputs.MeshConfigTracingZipkin']:
        return pulumi.get(self, "zipkin")


@pulumi.output_type
class MeshConfigTracingApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MeshConfigTracingApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MeshConfigTracingApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MeshConfigTracingApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class MeshConfigTracingZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class MeshTagList(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 passthrough: Optional[bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if passthrough is not None:
            pulumi.set(__self__, "passthrough", passthrough)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def passthrough(self) -> Optional[bool]:
        return pulumi.get(self, "passthrough")


@pulumi.output_type
class PrometheusAttachmentPrometheus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customProm":
            suggest = "custom_prom"
        elif key == "instanceId":
            suggest = "instance_id"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusAttachmentPrometheus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusAttachmentPrometheus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusAttachmentPrometheus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_prom: Optional['outputs.PrometheusAttachmentPrometheusCustomProm'] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None,
                 subnet_id: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        if custom_prom is not None:
            pulumi.set(__self__, "custom_prom", custom_prom)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if subnet_id is not None:
            pulumi.set(__self__, "subnet_id", subnet_id)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="customProm")
    def custom_prom(self) -> Optional['outputs.PrometheusAttachmentPrometheusCustomProm']:
        return pulumi.get(self, "custom_prom")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> Optional[str]:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class PrometheusAttachmentPrometheusCustomProm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "isPublicAddr":
            suggest = "is_public_addr"
        elif key == "vpcId":
            suggest = "vpc_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusAttachmentPrometheusCustomProm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusAttachmentPrometheusCustomProm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusAttachmentPrometheusCustomProm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 url: str,
                 is_public_addr: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None,
                 vpc_id: Optional[str] = None):
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "url", url)
        if is_public_addr is not None:
            pulumi.set(__self__, "is_public_addr", is_public_addr)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="isPublicAddr")
    def is_public_addr(self) -> Optional[bool]:
        return pulumi.get(self, "is_public_addr")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[str]:
        return pulumi.get(self, "vpc_id")


@pulumi.output_type
class TracingConfigApm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceId":
            suggest = "instance_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TracingConfigApm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TracingConfigApm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TracingConfigApm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: Optional[bool] = None,
                 instance_id: Optional[str] = None,
                 region: Optional[str] = None):
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if instance_id is not None:
            pulumi.set(__self__, "instance_id", instance_id)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> Optional[str]:
        return pulumi.get(self, "instance_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class TracingConfigZipkin(dict):
    def __init__(__self__, *,
                 address: str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")


@pulumi.output_type
class GetMeshMeshListResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetMeshMeshListConfigResult'],
                 display_name: str,
                 mesh_id: str,
                 tag_lists: Sequence['outputs.GetMeshMeshListTagListResult'],
                 type: str,
                 version: str):
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "mesh_id", mesh_id)
        pulumi.set(__self__, "tag_lists", tag_lists)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetMeshMeshListConfigResult']:
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> str:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="meshId")
    def mesh_id(self) -> str:
        return pulumi.get(self, "mesh_id")

    @property
    @pulumi.getter(name="tagLists")
    def tag_lists(self) -> Sequence['outputs.GetMeshMeshListTagListResult']:
        return pulumi.get(self, "tag_lists")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetMeshMeshListConfigResult(dict):
    def __init__(__self__, *,
                 istios: Sequence['outputs.GetMeshMeshListConfigIstioResult']):
        pulumi.set(__self__, "istios", istios)

    @property
    @pulumi.getter
    def istios(self) -> Sequence['outputs.GetMeshMeshListConfigIstioResult']:
        return pulumi.get(self, "istios")


@pulumi.output_type
class GetMeshMeshListConfigIstioResult(dict):
    def __init__(__self__, *,
                 disable_http_retry: bool,
                 disable_policy_checks: bool,
                 enable_pilot_http: bool,
                 outbound_traffic_policy: str,
                 smart_dns: Sequence['outputs.GetMeshMeshListConfigIstioSmartDnResult']):
        pulumi.set(__self__, "disable_http_retry", disable_http_retry)
        pulumi.set(__self__, "disable_policy_checks", disable_policy_checks)
        pulumi.set(__self__, "enable_pilot_http", enable_pilot_http)
        pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        pulumi.set(__self__, "smart_dns", smart_dns)

    @property
    @pulumi.getter(name="disableHttpRetry")
    def disable_http_retry(self) -> bool:
        return pulumi.get(self, "disable_http_retry")

    @property
    @pulumi.getter(name="disablePolicyChecks")
    def disable_policy_checks(self) -> bool:
        return pulumi.get(self, "disable_policy_checks")

    @property
    @pulumi.getter(name="enablePilotHttp")
    def enable_pilot_http(self) -> bool:
        return pulumi.get(self, "enable_pilot_http")

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> str:
        return pulumi.get(self, "outbound_traffic_policy")

    @property
    @pulumi.getter(name="smartDns")
    def smart_dns(self) -> Sequence['outputs.GetMeshMeshListConfigIstioSmartDnResult']:
        return pulumi.get(self, "smart_dns")


@pulumi.output_type
class GetMeshMeshListConfigIstioSmartDnResult(dict):
    def __init__(__self__, *,
                 istio_meta_dns_auto_allocate: bool,
                 istio_meta_dns_capture: bool):
        pulumi.set(__self__, "istio_meta_dns_auto_allocate", istio_meta_dns_auto_allocate)
        pulumi.set(__self__, "istio_meta_dns_capture", istio_meta_dns_capture)

    @property
    @pulumi.getter(name="istioMetaDnsAutoAllocate")
    def istio_meta_dns_auto_allocate(self) -> bool:
        return pulumi.get(self, "istio_meta_dns_auto_allocate")

    @property
    @pulumi.getter(name="istioMetaDnsCapture")
    def istio_meta_dns_capture(self) -> bool:
        return pulumi.get(self, "istio_meta_dns_capture")


@pulumi.output_type
class GetMeshMeshListTagListResult(dict):
    def __init__(__self__, *,
                 key: str,
                 passthrough: bool,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "passthrough", passthrough)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def passthrough(self) -> bool:
        return pulumi.get(self, "passthrough")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


