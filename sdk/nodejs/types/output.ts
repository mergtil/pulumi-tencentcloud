// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace Address {
    export interface GetTemplateGroupsGroupList {
        id: string;
        name: string;
        templateIds: string[];
    }

    export interface GetTemplatesTemplateList {
        addresses: string[];
        id: string;
        name: string;
    }

}

export namespace ApiGateway {
    export interface ApiConstantParameter {
        defaultValue?: string;
        desc?: string;
        name?: string;
        position?: string;
    }

    export interface ApiMicroService {
        clusterId: string;
        microServiceName: string;
        namespaceId: string;
    }

    export interface ApiOauthConfig {
        loginRedirectUrl?: string;
        publicKey: string;
        tokenLocation: string;
    }

    export interface ApiRequestParameter {
        defaultValue?: string;
        desc?: string;
        name: string;
        position: string;
        required?: boolean;
        type: string;
    }

    export interface ApiResponseErrorCode {
        code: number;
        convertedCode?: number;
        desc?: string;
        msg: string;
        needConvert?: boolean;
    }

    export interface ApiServiceConfigCosConfig {
        action: string;
        authorization?: boolean;
        bucketName: string;
        pathMatchMode?: string;
    }

    export interface ApiServiceParameter {
        defaultValue?: string;
        name?: string;
        position?: string;
        relevantRequestParameterDesc?: string;
        relevantRequestParameterName?: string;
        relevantRequestParameterPosition?: string;
        relevantRequestParameterType?: string;
    }

    export interface ApiServiceTsfHealthCheckConf {
        errorThresholdPercentage?: number;
        isHealthCheck?: boolean;
        requestVolumeThreshold?: number;
        sleepWindowInMilliseconds?: number;
    }

    export interface ApiServiceTsfLoadBalanceConf {
        isLoadBalance?: boolean;
        method?: string;
        sessionStickRequired?: boolean;
        sessionStickTimeout?: number;
    }

    export interface ApiTargetService {
        dockerIp?: string;
        hostIp: string;
        vmIp: string;
        vmPort: number;
        vpcId: string;
    }

    export interface ApiTargetServicesHealthCheckConf {
        errorThresholdPercentage?: number;
        isHealthCheck?: boolean;
        requestVolumeThreshold?: number;
        sleepWindowInMilliseconds?: number;
    }

    export interface GetApiAppServiceApiIdStatusSet {
        apiBusinessType: string;
        apiDesc: string;
        apiId: string;
        apiName: string;
        apiType: string;
        authRelationApiId: string;
        authType: string;
        createdTime: string;
        isDebugAfterCharge: boolean;
        method: string;
        modifiedTime: string;
        oauthConfigs: outputs.ApiGateway.GetApiAppServiceApiIdStatusSetOauthConfig[];
        path: string;
        protocol: string;
        serviceId: string;
        tokenLocation: string;
        uniqVpcId: string;
    }

    export interface GetApiAppServiceApiIdStatusSetOauthConfig {
        loginRedirectUrl: string;
        publicKey: string;
        tokenLocation: string;
    }

    export interface GetApiAppServiceUsagePlanList {
        createdTime: string;
        environment: string;
        maxRequestNumPreSec: number;
        modifiedTime: string;
        usagePlanDesc: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface GetApiAppsApiAppList {
        apiAppDesc: string;
        apiAppId: string;
        apiAppKey: string;
        apiAppName: string;
        apiAppSecret: string;
        createdTime: string;
        modifiedTime: string;
    }

    export interface GetApiDocsApiDocList {
        apiDocId: string;
        apiDocName: string;
        apiDocStatus: string;
    }

    export interface GetApiKeysList {
        accessKeySecret: string;
        apiKeyId: string;
        createTime: string;
        modifyTime: string;
        status: string;
    }

    export interface GetApiUsagePlansResult {
        apiId: string;
        apiName: string;
        createdTime: string;
        environment: string;
        inUseRequestNum: number;
        maxRequestNum: number;
        maxRequestNumPreSec: number;
        method: string;
        modifiedTime: string;
        path: string;
        serviceId: string;
        serviceName: string;
        usagePlanDesc: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface GetApisList {
        apiDesc: string;
        apiName: string;
        authType: string;
        createTime: string;
        enableCors: boolean;
        modifyTime: string;
        protocol: string;
        requestConfigMethod: string;
        requestConfigPath: string;
        requestParameters: outputs.ApiGateway.GetApisListRequestParameter[];
        responseErrorCodes: outputs.ApiGateway.GetApisListResponseErrorCode[];
        responseFailExample: string;
        responseSuccessExample: string;
        responseType: string;
        serviceConfigMethod: string;
        serviceConfigMockReturnMessage: string;
        serviceConfigPath: string;
        serviceConfigProduct: string;
        serviceConfigScfFunctionName: string;
        serviceConfigScfFunctionNamespace: string;
        serviceConfigScfFunctionQualifier: string;
        serviceConfigTimeout: number;
        serviceConfigType: string;
        serviceConfigUrl: string;
        serviceConfigVpcId: string;
        serviceId: string;
    }

    export interface GetApisListRequestParameter {
        defaultValue: string;
        desc: string;
        name: string;
        position: string;
        required: boolean;
        type: string;
    }

    export interface GetApisListResponseErrorCode {
        code: number;
        convertedCode: number;
        desc: string;
        msg: string;
        needConvert: boolean;
    }

    export interface GetCustomerDomainsList {
        certificateId: string;
        domainName: string;
        isDefaultMapping: boolean;
        isStatusOn: boolean;
        netType: string;
        pathMappings: outputs.ApiGateway.GetCustomerDomainsListPathMapping[];
        protocol: string;
    }

    export interface GetCustomerDomainsListPathMapping {
        environment: string;
        path: string;
    }

    export interface GetIpStrategiesList {
        attachLists: outputs.ApiGateway.GetIpStrategiesListAttachList[];
        bindApiTotalCount: number;
        createTime: string;
        ipList: string;
        modifyTime: string;
        serviceId: string;
        strategyId: string;
        strategyName: string;
        strategyType: string;
    }

    export interface GetIpStrategiesListAttachList {
        apiBusinessType: string;
        apiDesc: string;
        apiId: string;
        apiName: string;
        apiType: string;
        authRelationApiId: string;
        authType: string;
        createTime: string;
        method: string;
        modifyTime: string;
        oauthConfig: {[key: string]: any};
        path: string;
        protocol: string;
        relationBusinessApiIds: string[];
        serviceId: string;
        tags: string[];
        uniqVpcId: string;
        vpcId: number;
    }

    export interface GetPluginsResult {
        apiId: string;
        apiName: string;
        apiType: string;
        attachedOtherPlugin: boolean;
        isAttached: boolean;
        method: string;
        path: string;
    }

    export interface GetServicesList {
        createTime: string;
        /**
         * @deprecated It has been deprecated from version 1.81.9.
         */
        exclusiveSetName: string;
        innerHttpPort: number;
        innerHttpsPort: number;
        internalSubDomain: string;
        ipVersion: string;
        modifyTime: string;
        netTypes: string[];
        outerSubDomain: string;
        protocol: string;
        serviceDesc: string;
        serviceId: string;
        serviceName: string;
        usagePlanLists: outputs.ApiGateway.GetServicesListUsagePlanList[];
    }

    export interface GetServicesListUsagePlanList {
        apiId: string;
        bindType: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface GetThrottlingApisList {
        apiEnvironmentStrategies: outputs.ApiGateway.GetThrottlingApisListApiEnvironmentStrategy[];
        serviceId: string;
    }

    export interface GetThrottlingApisListApiEnvironmentStrategy {
        apiId: string;
        apiName: string;
        method: string;
        path: string;
        strategyLists: outputs.ApiGateway.GetThrottlingApisListApiEnvironmentStrategyStrategyList[];
    }

    export interface GetThrottlingApisListApiEnvironmentStrategyStrategyList {
        environmentName: string;
        quota: number;
    }

    export interface GetThrottlingServicesList {
        environments: outputs.ApiGateway.GetThrottlingServicesListEnvironment[];
        serviceId: string;
    }

    export interface GetThrottlingServicesListEnvironment {
        environmentName: string;
        status: number;
        strategy: number;
        url: string;
        versionName: string;
    }

    export interface GetUpstreamsFilter {
        name: string;
        values: string[];
    }

    export interface GetUpstreamsResult {
        apiId: string;
        apiName: string;
        bindTime: string;
        serviceId: string;
        serviceName: string;
    }

    export interface GetUsagePlanEnvironmentsList {
        apiId: string;
        apiName: string;
        createTime: string;
        environment: string;
        method: string;
        modifyTime: string;
        path: string;
        serviceId: string;
        serviceName: string;
    }

    export interface GetUsagePlansList {
        createTime: string;
        maxRequestNum: number;
        maxRequestNumPreSec: number;
        modifyTime: string;
        usagePlanDesc: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface ServiceApiList {
        apiDesc: string;
        apiId: string;
        apiName: string;
        method: string;
        path: string;
    }

    export interface ServiceUsagePlanList {
        apiId: string;
        bindType: string;
        usagePlanId: string;
        usagePlanName: string;
    }

    export interface UpstreamHealthChecker {
        activeCheckHttpPath?: string;
        activeCheckInterval?: number;
        activeCheckTimeout?: number;
        enableActiveCheck: boolean;
        enablePassiveCheck: boolean;
        healthyHttpStatus: string;
        httpFailureThreshold: number;
        tcpFailureThreshold: number;
        timeoutThreshold: number;
        unhealthyHttpStatus: string;
        unhealthyTimeout?: number;
    }

    export interface UpstreamK8sService {
        clusterId: string;
        extraLabels: outputs.ApiGateway.UpstreamK8sServiceExtraLabel[];
        name?: string;
        namespace: string;
        port: number;
        serviceName: string;
        weight: number;
    }

    export interface UpstreamK8sServiceExtraLabel {
        key: string;
        value: string;
    }

    export interface UpstreamNode {
        clusterId?: string;
        host: string;
        nameSpace?: string;
        port: number;
        serviceName?: string;
        source?: string;
        tags?: string[];
        uniqueServiceName?: string;
        vmInstanceId?: string;
        weight: number;
    }

    export interface UsagePlanAttachList {
        apiId: string;
        apiName: string;
        createTime: string;
        environment: string;
        method: string;
        modifyTime: string;
        path: string;
        serviceId: string;
        serviceName: string;
    }

}

export namespace As {
    export interface GetAdvicesAutoScalingAdviceSet {
        advices: outputs.As.GetAdvicesAutoScalingAdviceSetAdvice[];
        autoScalingGroupId: string;
        level: string;
    }

    export interface GetAdvicesAutoScalingAdviceSetAdvice {
        detail: string;
        problem: string;
        solution: string;
    }

    export interface GetInstancesFilter {
        name: string;
        values: string[];
    }

    export interface GetInstancesInstanceList {
        addTime: string;
        autoScalingGroupId: string;
        autoScalingGroupName: string;
        creationType: string;
        healthStatus: string;
        instanceId: string;
        instanceType: string;
        launchConfigurationId: string;
        launchConfigurationName: string;
        lifeCycleState: string;
        protectedFromScaleIn: boolean;
        versionNumber: number;
        zone: string;
    }

    export interface GetLastActivityActivitySet {
        activityId: string;
        activityRelatedInstanceSets: outputs.As.GetLastActivityActivitySetActivityRelatedInstanceSet[];
        activityType: string;
        autoScalingGroupId: string;
        cause: string;
        createdTime: string;
        description: string;
        detailedStatusMessageSets: outputs.As.GetLastActivityActivitySetDetailedStatusMessageSet[];
        endTime: string;
        invocationResultSets: outputs.As.GetLastActivityActivitySetInvocationResultSet[];
        lifecycleActionResultSets: outputs.As.GetLastActivityActivitySetLifecycleActionResultSet[];
        startTime: string;
        statusCode: string;
        statusMessage: string;
        statusMessageSimplified: string;
    }

    export interface GetLastActivityActivitySetActivityRelatedInstanceSet {
        instanceId: string;
        instanceStatus: string;
    }

    export interface GetLastActivityActivitySetDetailedStatusMessageSet {
        code: string;
        instanceChargeType: string;
        instanceId: string;
        instanceType: string;
        message: string;
        subnetId: string;
        zone: string;
    }

    export interface GetLastActivityActivitySetInvocationResultSet {
        commandId: string;
        errorMessage: string;
        instanceId: string;
        invocationId: string;
        invocationTaskId: string;
        taskStatus: string;
    }

    export interface GetLastActivityActivitySetLifecycleActionResultSet {
        instanceId: string;
        invocationId: string;
        invokeCommandResult: string;
        lifecycleActionResult: string;
        lifecycleHookId: string;
        notificationResult: string;
        resultReason: string;
    }

    export interface GetScalingConfigsConfigurationList {
        configurationId: string;
        configurationName: string;
        createTime: string;
        dataDisks: outputs.As.GetScalingConfigsConfigurationListDataDisk[];
        diskTypePolicy: string;
        enhancedMonitorService: boolean;
        enhancedSecurityService: boolean;
        imageId: string;
        instanceTags: {[key: string]: any};
        instanceTypes: string[];
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        keyIds: string[];
        projectId: number;
        publicIpAssigned: boolean;
        securityGroupIds: string[];
        status: string;
        systemDiskSize: number;
        systemDiskType: string;
        userData: string;
    }

    export interface GetScalingConfigsConfigurationListDataDisk {
        deleteWithInstance: boolean;
        diskSize: number;
        diskType: string;
        snapshotId: string;
    }

    export interface GetScalingGroupsScalingGroupList {
        configurationId: string;
        createTime: string;
        defaultCooldown: number;
        desiredCapacity: number;
        forwardBalancerIds: outputs.As.GetScalingGroupsScalingGroupListForwardBalancerId[];
        instanceCount: number;
        loadBalancerIds: string[];
        maxSize: number;
        minSize: number;
        multiZoneSubnetPolicy: string;
        projectId: number;
        retryPolicy: string;
        scalingGroupId: string;
        scalingGroupName: string;
        status: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        terminationPolicies: string[];
        vpcId: string;
        zones: string[];
    }

    export interface GetScalingGroupsScalingGroupListForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        locationId: string;
        targetAttributes: outputs.As.GetScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute[];
    }

    export interface GetScalingGroupsScalingGroupListForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

    export interface GetScalingPoliciesScalingPolicyList {
        adjustmentType: string;
        adjustmentValue: number;
        comparisonOperator: string;
        continuousTime: number;
        cooldown: number;
        metricName: string;
        notificationUserGroupIds: string[];
        period: number;
        policyName: string;
        scalingGroupId: string;
        statistic: string;
        threshold: number;
    }

    export interface LoadBalancerForwardLoadBalancer {
        listenerId: string;
        loadBalancerId: string;
        locationId?: string;
        region?: string;
        targetAttributes: outputs.As.LoadBalancerForwardLoadBalancerTargetAttribute[];
    }

    export interface LoadBalancerForwardLoadBalancerTargetAttribute {
        port: number;
        weight: number;
    }

    export interface ScalingConfigDataDisk {
        deleteWithInstance?: boolean;
        diskSize?: number;
        diskType?: string;
        snapshotId?: string;
    }

    export interface ScalingConfigHostNameSettings {
        hostName: string;
        hostNameStyle?: string;
    }

    export interface ScalingConfigInstanceNameSettings {
        instanceName: string;
        instanceNameStyle?: string;
    }

    export interface ScalingGroupForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        ruleId?: string;
        targetAttributes: outputs.As.ScalingGroupForwardBalancerIdTargetAttribute[];
    }

    export interface ScalingGroupForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

}

export namespace Audit {
    export interface GetCosRegionsAuditCosRegionList {
        cosRegion: string;
        cosRegionName: string;
    }

    export interface GetKeyAliasAuditKeyAliasList {
        keyAlias: string;
        keyId: string;
    }

    export interface TrackStorage {
        storageName: string;
        storagePrefix: string;
        storageRegion: string;
        storageType: string;
    }

}

export namespace Audits {
    export interface GetAuditsAuditList {
        auditSwitch: boolean;
        cosBucket: string;
        id: string;
        logFilePrefix: string;
        name: string;
    }

}

export namespace Availability {
    export interface GetRegionsRegion {
        description: string;
        name: string;
        state: string;
    }

    export interface GetZonesByProductZone {
        description: string;
        id: string;
        name: string;
        state: string;
    }

}

export namespace Cam {
    export interface GetGroupMembershipsMembershipList {
        groupId: string;
        /**
         * @deprecated It has been deprecated from version 1.59.5. Use `user_names` instead.
         */
        userIds: string[];
        userNames: string[];
    }

    export interface GetGroupPolicyAttachmentsGroupPolicyAttachmentList {
        createMode: number;
        createTime: string;
        groupId: string;
        policyId: string;
        policyName: string;
        policyType: string;
    }

    export interface GetGroupsGroupList {
        createTime: string;
        groupId: string;
        name: string;
        remark: string;
    }

    export interface GetPoliciesPolicyList {
        attachments: number;
        createMode: number;
        createTime: string;
        description: string;
        name: string;
        policyId: string;
        serviceType: string;
        type: number;
    }

    export interface GetRolePolicyAttachmentsRolePolicyAttachmentList {
        createMode: number;
        createTime: string;
        policyId: string;
        policyName: string;
        policyType: string;
        roleId: string;
    }

    export interface GetRolesRoleList {
        consoleLogin: boolean;
        createTime: string;
        description: string;
        document: string;
        name: string;
        roleId: string;
        updateTime: string;
    }

    export interface GetSamlProvidersProviderList {
        createTime: string;
        description: string;
        modifyTime: string;
        name: string;
    }

    export interface GetUserPolicyAttachmentsUserPolicyAttachmentList {
        createMode: number;
        createTime: string;
        policyId: string;
        policyName: string;
        policyType: string;
        /**
         * @deprecated It has been deprecated from version 1.59.6. Use `user_name` instead.
         */
        userId: string;
        userName: string;
    }

    export interface GetUsersUserList {
        consoleLogin?: boolean;
        countryCode: string;
        email: string;
        name: string;
        phoneNum: string;
        remark: string;
        uid: number;
        uin: number;
        userId: string;
    }

}

export namespace Cat {
    export interface GetNodeNodeDefine {
        city: string;
        code: string;
        codeType: string;
        district: string;
        ipType: number;
        location: number;
        name: string;
        netService: string;
        nodeDefineStatus: number;
        type: number;
    }

    export interface GetProbeDataDetailedSingleDataDefine {
        fields: outputs.Cat.GetProbeDataDetailedSingleDataDefineField[];
        labels: outputs.Cat.GetProbeDataDetailedSingleDataDefineLabel[];
        probeTime: number;
    }

    export interface GetProbeDataDetailedSingleDataDefineField {
        id: number;
        name: string;
        value: number;
    }

    export interface GetProbeDataDetailedSingleDataDefineLabel {
        id: number;
        name: string;
        value: string;
    }

    export interface TaskSetBatchTasks {
        name: string;
        targetAddress: string;
    }

}

export namespace Cbs {
    export interface GetSnapshotPoliciesSnapshotPolicyList {
        attachedStorageIds: string[];
        createTime: string;
        repeatHours: number[];
        repeatWeekdays: number[];
        retentionDays: number;
        snapshotPolicyId: string;
        snapshotPolicyName: string;
        status: string;
    }

    export interface GetSnapshotsSnapshotList {
        availabilityZone: string;
        createTime: string;
        encrypt: boolean;
        percent: number;
        projectId: number;
        snapshotId: string;
        snapshotName: string;
        storageId: string;
        storageSize: number;
        storageUsage: string;
    }

    export interface GetStoragesSetStorageList {
        attached: boolean;
        availabilityZone: string;
        chargeType: string;
        createTime: string;
        encrypt: boolean;
        instanceId: string;
        prepaidRenewFlag: string;
        projectId: number;
        status: string;
        storageId: string;
        storageName: string;
        storageSize: number;
        storageType: string;
        storageUsage: string;
        tags: {[key: string]: any};
        throughputPerformance: number;
    }

    export interface GetStoragesStorageList {
        attached: boolean;
        availabilityZone: string;
        chargeType: string;
        createTime: string;
        encrypt: boolean;
        instanceId: string;
        prepaidRenewFlag: string;
        projectId: number;
        status: string;
        storageId: string;
        storageName: string;
        storageSize: number;
        storageType: string;
        storageUsage: string;
        tags: {[key: string]: any};
        throughputPerformance: number;
    }

}

export namespace Ccn {
    export interface GetBandwidthLimitsLimit {
        bandwidthLimit: number;
        dstRegion: string;
        region: string;
    }

    export interface GetCrossBorderFlowMonitorCrossBorderFlowMonitorData {
        inBandwidths: number[];
        inPkgs: number[];
        outBandwidths: number[];
        outPkgs: number[];
    }

    export interface GetCrossBorderRegionBandwidthLimitsCcnBandwidthSet {
        ccnId: string;
        ccnRegionBandwidthLimits: outputs.Ccn.GetCrossBorderRegionBandwidthLimitsCcnBandwidthSetCcnRegionBandwidthLimit[];
        createdTime: string;
        expiredTime: string;
        instanceChargeType: string;
        isCrossBorder: boolean;
        isSecurityLock: boolean;
        marketId: string;
        regionFlowControlId: string;
        renewFlag: string;
        updateTime: string;
        userAccountId: string;
    }

    export interface GetCrossBorderRegionBandwidthLimitsCcnBandwidthSetCcnRegionBandwidthLimit {
        bandwidthLimit: number;
        destinationRegion: string;
        sourceRegion: string;
    }

    export interface GetCrossBorderRegionBandwidthLimitsFilter {
        name: string;
        values: string[];
    }

    export interface GetInstancesInstanceList {
        attachmentLists: outputs.Ccn.GetInstancesInstanceListAttachmentList[];
        bandwidthLimitType: string;
        ccnId: string;
        chargeType: string;
        createTime: string;
        description: string;
        name: string;
        qos: string;
        state: string;
    }

    export interface GetInstancesInstanceListAttachmentList {
        attachedTime: string;
        cidrBlocks: string[];
        instanceId: string;
        instanceRegion: string;
        instanceType: string;
        state: string;
    }

    export interface InstancesAcceptAttachInstance {
        description?: string;
        instanceId: string;
        instanceRegion: string;
        instanceType?: string;
        routeTableId?: string;
    }

    export interface InstancesRejectAttachInstance {
        description?: string;
        instanceId: string;
        instanceRegion: string;
        instanceType?: string;
        routeTableId?: string;
    }

    export interface InstancesResetAttachInstance {
        description?: string;
        instanceId: string;
        instanceRegion: string;
        instanceType?: string;
        routeTableId?: string;
    }

}

export namespace Cdh {
    export interface GetInstancesCdhInstanceList {
        availabilityZone: string;
        cageId: string;
        chargeType: string;
        createTime: string;
        cvmInstanceIds: string[];
        expiredTime: string;
        hostId: string;
        hostName: string;
        hostResources: outputs.Cdh.GetInstancesCdhInstanceListHostResource[];
        hostState: string;
        hostType: string;
        prepaidRenewFlag: string;
        projectId: number;
    }

    export interface GetInstancesCdhInstanceListHostResource {
        cpuAvailableNum: number;
        cpuTotalNum: number;
        diskAvailableSize: number;
        diskTotalSize: number;
        diskType: string;
        memoryAvailableSize: number;
        memoryTotalSize: number;
    }

    export interface InstanceHostResource {
        cpuAvailableNum: number;
        cpuTotalNum: number;
        diskAvailableSize: number;
        diskTotalSize: number;
        diskType: string;
        memoryAvailableSize: number;
        memoryTotalSize: number;
    }

}

export namespace Cdn {
    export interface DomainAuthentication {
        switch?: string;
        typeA?: outputs.Cdn.DomainAuthenticationTypeA;
        typeB?: outputs.Cdn.DomainAuthenticationTypeB;
        typeC?: outputs.Cdn.DomainAuthenticationTypeC;
        typeD?: outputs.Cdn.DomainAuthenticationTypeD;
    }

    export interface DomainAuthenticationTypeA {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        signParam: string;
    }

    export interface DomainAuthenticationTypeB {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
    }

    export interface DomainAuthenticationTypeC {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        timeFormat?: string;
    }

    export interface DomainAuthenticationTypeD {
        backupSecretKey?: string;
        expireTime: number;
        fileExtensions: string[];
        filterType: string;
        secretKey: string;
        timeFormat?: string;
        timeParam?: string;
    }

    export interface DomainAwsPrivateAccess {
        accessKey?: string;
        bucket?: string;
        region?: string;
        secretKey?: string;
        switch: string;
    }

    export interface DomainBandWidthAlert {
        alertPercentage?: number;
        alertSwitch?: string;
        bpsThreshold?: number;
        counterMeasure?: string;
        lastTriggerTime: string;
        lastTriggerTimeOverseas: string;
        metric?: string;
        statisticItem?: outputs.Cdn.DomainBandWidthAlertStatisticItem;
        switch: string;
    }

    export interface DomainBandWidthAlertStatisticItem {
        alertPercentage?: number;
        alertSwitch?: string;
        bpsThreshold?: number;
        counterMeasure?: string;
        cycle?: number;
        metric?: string;
        switch: string;
        type?: string;
        unblockTime?: number;
    }

    export interface DomainCacheKey {
        fullUrlCache?: string;
        ignoreCase?: string;
        keyRules?: outputs.Cdn.DomainCacheKeyKeyRule[];
        queryString?: outputs.Cdn.DomainCacheKeyQueryString;
    }

    export interface DomainCacheKeyKeyRule {
        fullUrlCache?: string;
        ignoreCase?: string;
        queryString: outputs.Cdn.DomainCacheKeyKeyRuleQueryString;
        rulePaths: string[];
        ruleTag?: string;
        ruleType: string;
    }

    export interface DomainCacheKeyKeyRuleQueryString {
        action?: string;
        switch?: string;
        value?: string;
    }

    export interface DomainCacheKeyQueryString {
        action: string;
        reorder?: string;
        switch?: string;
        value?: string;
    }

    export interface DomainCompression {
        compressionRules?: outputs.Cdn.DomainCompressionCompressionRule[];
        switch: string;
    }

    export interface DomainCompressionCompressionRule {
        algorithms: string[];
        compress: boolean;
        fileExtensions?: string[];
        maxLength: number;
        minLength: number;
        rulePaths?: string[];
        ruleType?: string;
    }

    export interface DomainDownstreamCapping {
        cappingRules?: outputs.Cdn.DomainDownstreamCappingCappingRule[];
        switch: string;
    }

    export interface DomainDownstreamCappingCappingRule {
        kbpsThreshold: number;
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainErrorPage {
        pageRules?: outputs.Cdn.DomainErrorPagePageRule[];
        switch: string;
    }

    export interface DomainErrorPagePageRule {
        redirectCode: number;
        redirectUrl: string;
        statusCode: number;
    }

    export interface DomainHttpsConfig {
        clientCertificateConfig?: outputs.Cdn.DomainHttpsConfigClientCertificateConfig;
        forceRedirect: outputs.Cdn.DomainHttpsConfigForceRedirect;
        http2Switch?: string;
        httpsSwitch: string;
        ocspStaplingSwitch?: string;
        serverCertificateConfig?: outputs.Cdn.DomainHttpsConfigServerCertificateConfig;
        spdySwitch?: string;
        tlsVersions: string[];
        verifyClient?: string;
    }

    export interface DomainHttpsConfigClientCertificateConfig {
        certificateContent: string;
        certificateName: string;
        deployTime: string;
        expireTime: string;
    }

    export interface DomainHttpsConfigForceRedirect {
        carryHeaders?: string;
        redirectStatusCode?: number;
        redirectType?: string;
        switch?: string;
    }

    export interface DomainHttpsConfigServerCertificateConfig {
        certificateContent?: string;
        certificateId?: string;
        certificateName: string;
        deployTime: string;
        expireTime: string;
        message?: string;
        privateKey?: string;
    }

    export interface DomainHwPrivateAccess {
        accessKey?: string;
        bucket?: string;
        secretKey?: string;
        switch: string;
    }

    export interface DomainIpFilter {
        filterRules?: outputs.Cdn.DomainIpFilterFilterRule[];
        filterType?: string;
        filters?: string[];
        returnCode?: number;
        switch: string;
    }

    export interface DomainIpFilterFilterRule {
        filterType: string;
        filters: string[];
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainIpFreqLimit {
        qps?: number;
        switch: string;
    }

    export interface DomainMaxAge {
        maxAgeRules?: outputs.Cdn.DomainMaxAgeMaxAgeRule[];
        switch: string;
    }

    export interface DomainMaxAgeMaxAgeRule {
        followOrigin?: string;
        maxAgeContents: string[];
        maxAgeTime: number;
        maxAgeType: string;
    }

    export interface DomainOrigin {
        backupOriginLists?: string[];
        backupOriginType?: string;
        backupServerName?: string;
        cosPrivateAccess?: string;
        originLists: string[];
        originPullProtocol?: string;
        originType: string;
        serverName: string;
    }

    export interface DomainOriginPullOptimization {
        optimizationType?: string;
        switch: string;
    }

    export interface DomainOriginPullTimeout {
        connectTimeout: number;
        receiveTimeout: number;
    }

    export interface DomainOssPrivateAccess {
        accessKey?: string;
        bucket?: string;
        region?: string;
        secretKey?: string;
        switch: string;
    }

    export interface DomainPostMaxSize {
        maxSize?: number;
        switch: string;
    }

    export interface DomainQnPrivateAccess {
        accessKey?: string;
        secretKey?: string;
        switch: string;
    }

    export interface DomainReferer {
        refererRules?: outputs.Cdn.DomainRefererRefererRule[];
        switch: string;
    }

    export interface DomainRefererRefererRule {
        allowEmpty: boolean;
        refererType: string;
        referers: string[];
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainRequestHeader {
        headerRules?: outputs.Cdn.DomainRequestHeaderHeaderRule[];
        switch?: string;
    }

    export interface DomainRequestHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainResponseHeader {
        headerRules?: outputs.Cdn.DomainResponseHeaderHeaderRule[];
        switch: string;
    }

    export interface DomainResponseHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface DomainRuleCach {
        cacheTime: number;
        compareMaxAge?: string;
        followOriginSwitch?: string;
        heuristicCacheSwitch?: string;
        heuristicCacheTime?: number;
        ignoreCacheControl?: string;
        ignoreSetCookie?: string;
        noCacheSwitch?: string;
        reValidate?: string;
        rulePaths: string[];
        ruleType?: string;
        switch?: string;
    }

    export interface DomainStatusCodeCache {
        cacheRules?: outputs.Cdn.DomainStatusCodeCacheCacheRule[];
        switch: string;
    }

    export interface DomainStatusCodeCacheCacheRule {
        cacheTime: number;
        statusCode: string;
    }

    export interface GetDomainsDomainList {
        area: string;
        cname: string;
        createTime: string;
        domain: string;
        fullUrlCache: boolean;
        httpsConfigs: outputs.Cdn.GetDomainsDomainListHttpsConfig[];
        id: string;
        origins: outputs.Cdn.GetDomainsDomainListOrigin[];
        projectId: number;
        rangeOriginSwitch: string;
        requestHeaders: outputs.Cdn.GetDomainsDomainListRequestHeader[];
        ruleCaches: outputs.Cdn.GetDomainsDomainListRuleCach[];
        serviceType: string;
        status: string;
        tags: {[key: string]: any};
        updateTime: string;
    }

    export interface GetDomainsDomainListHttpsConfig {
        http2Switch: string;
        httpsSwitch: string;
        ocspStaplingSwitch: string;
        spdySwitch: string;
        verifyClient: string;
    }

    export interface GetDomainsDomainListOrigin {
        backupOriginLists: string[];
        backupOriginType: string;
        backupServerName: string;
        cosPrivateAccess: string;
        originLists: string[];
        originPullProtocol: string;
        originType: string;
        serverName: string;
    }

    export interface GetDomainsDomainListRequestHeader {
        headerRules: outputs.Cdn.GetDomainsDomainListRequestHeaderHeaderRule[];
        switch: string;
    }

    export interface GetDomainsDomainListRequestHeaderHeaderRule {
        headerMode: string;
        headerName: string;
        headerValue: string;
        rulePaths: string[];
        ruleType: string;
    }

    export interface GetDomainsDomainListRuleCach {
        cacheTime: number;
        compareMaxAge?: string;
        followOriginSwitch: string;
        ignoreCacheControl?: string;
        ignoreSetCookie: string;
        noCacheSwitch: string;
        reValidate: string;
        rulePaths: string[];
        ruleType: string;
        switch: string;
    }

    export interface UrlPurgePurgeHistory {
        createTime: string;
        flushType: string;
        purgeType: string;
        status: string;
        taskId: string;
        url: string;
    }

    export interface UrlPushPushHistory {
        area: string;
        createTime: string;
        percent: number;
        status: string;
        taskId: string;
        updateTime: string;
        url: string;
    }

}

export namespace Cfs {
    export interface GetAccessGroupsAccessGroupList {
        accessGroupId: string;
        createTime: string;
        description: string;
        name: string;
    }

    export interface GetAccessRulesAccessRuleList {
        accessRuleId: string;
        authClientIp: string;
        priority: number;
        rwPermission: string;
        userPermission: string;
    }

    export interface GetAvailableZoneRegionZone {
        region: string;
        regionCnName: string;
        regionName: string;
        regionStatus: string;
        zones: outputs.Cfs.GetAvailableZoneRegionZoneZone[];
    }

    export interface GetAvailableZoneRegionZoneZone {
        types: outputs.Cfs.GetAvailableZoneRegionZoneZoneType[];
        zone: string;
        zoneCnName: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetAvailableZoneRegionZoneZoneType {
        prepayment: boolean;
        protocols: outputs.Cfs.GetAvailableZoneRegionZoneZoneTypeProtocol[];
        type: string;
    }

    export interface GetAvailableZoneRegionZoneZoneTypeProtocol {
        protocol: string;
        saleStatus: string;
    }

    export interface GetFileSystemClientsClientList {
        cfsVip: string;
        clientIp: string;
        mountDirectory: string;
        vpcId: string;
        zone: string;
        zoneName: string;
    }

    export interface GetFileSystemsFileSystemList {
        accessGroupId: string;
        availabilityZone: string;
        createTime: string;
        fileSystemId: string;
        fsId: string;
        mountIp: string;
        name: string;
        protocol: string;
        sizeLimit: number;
        sizeUsed: number;
        status: string;
        storageType: string;
    }

    export interface GetMountTargetsMountTarget {
        ccnId: string;
        cidrBlock: string;
        fileSystemId: string;
        fsId: string;
        ipAddress: string;
        lifeCycleState: string;
        mountTargetId: string;
        networkInterface: string;
        subnetId: string;
        subnetName: string;
        vpcId: string;
        vpcName: string;
    }

}

export namespace Chdfs {
    export interface AccessRuleAccessRule {
        accessMode?: number;
        accessRuleId: number;
        address?: string;
        createTime: string;
        priority?: number;
    }

    export interface GetAccessGroupsAccessGroup {
        accessGroupId: string;
        accessGroupName: string;
        createTime: string;
        description: string;
        vpcId: string;
        vpcType: number;
    }

    export interface GetFileSystemsFileSystem {
        appId: number;
        blockSize: number;
        capacityQuota: number;
        createTime: string;
        description: string;
        enableRanger: boolean;
        fileSystemId: string;
        fileSystemName: string;
        posixAcl: boolean;
        rangerServiceAddresses: string[];
        region: string;
        status: number;
        superUsers: string[];
    }

    export interface GetMountPointsMountPoint {
        accessGroupIds: string[];
        createTime: string;
        fileSystemId: string;
        mountPointId: string;
        mountPointName: string;
        status: number;
    }

    export interface LifeCycleRuleLifeCycleRule {
        createTime: string;
        lifeCycleRuleId: number;
        lifeCycleRuleName?: string;
        path?: string;
        status?: number;
        transitions?: outputs.Chdfs.LifeCycleRuleLifeCycleRuleTransition[];
    }

    export interface LifeCycleRuleLifeCycleRuleTransition {
        days: number;
        type: number;
    }

}

export namespace Ci {
    export interface MediaAnimationTemplateContainer {
        format: string;
    }

    export interface MediaAnimationTemplateTimeInterval {
        duration?: string;
        start?: string;
    }

    export interface MediaAnimationTemplateVideo {
        animateFramesPerSecond?: string;
        animateOnlyKeepKeyFrame?: string;
        animateTimeIntervalOfFrame?: string;
        codec: string;
        fps?: string;
        height?: string;
        quality?: string;
        width?: string;
    }

    export interface MediaConcatTemplateConcatTemplate {
        audio?: outputs.Ci.MediaConcatTemplateConcatTemplateAudio;
        audioMixes?: outputs.Ci.MediaConcatTemplateConcatTemplateAudioMix[];
        concatFragments: outputs.Ci.MediaConcatTemplateConcatTemplateConcatFragment[];
        container: outputs.Ci.MediaConcatTemplateConcatTemplateContainer;
        video?: outputs.Ci.MediaConcatTemplateConcatTemplateVideo;
    }

    export interface MediaConcatTemplateConcatTemplateAudio {
        bitrate?: string;
        channels?: string;
        codec: string;
        samplerate?: string;
    }

    export interface MediaConcatTemplateConcatTemplateAudioMix {
        audioSource: string;
        effectConfig?: outputs.Ci.MediaConcatTemplateConcatTemplateAudioMixEffectConfig;
        mixMode?: string;
        replace?: string;
    }

    export interface MediaConcatTemplateConcatTemplateAudioMixEffectConfig {
        bgmFadeTime?: string;
        enableBgmFade?: string;
        enableEndFadeout?: string;
        enableStartFadein?: string;
        endFadeoutTime: string;
        startFadeinTime?: string;
    }

    export interface MediaConcatTemplateConcatTemplateConcatFragment {
        mode: string;
        url: string;
    }

    export interface MediaConcatTemplateConcatTemplateContainer {
        format: string;
    }

    export interface MediaConcatTemplateConcatTemplateVideo {
        bitrate?: string;
        codec: string;
        crf?: string;
        fps?: string;
        height?: string;
        remove: string;
        rotate?: string;
        width?: string;
    }

    export interface MediaPicProcessTemplatePicProcess {
        isPicInfo?: string;
        processRule: string;
    }

    export interface MediaSmartCoverTemplateSmartCover {
        count?: string;
        deleteDuplicates?: string;
        format: string;
        height?: string;
        width?: string;
    }

    export interface MediaSnapshotTemplateSnapshot {
        blackLevel: string;
        ciParam: string;
        count: string;
        height: string;
        isCheckBlack: string;
        isCheckCount: string;
        mode: string;
        pixelBlackThreshold: string;
        snapshotOutMode: string;
        spriteSnapshotConfig: outputs.Ci.MediaSnapshotTemplateSnapshotSpriteSnapshotConfig;
        start: string;
        timeInterval: string;
        width: string;
    }

    export interface MediaSnapshotTemplateSnapshotSpriteSnapshotConfig {
        cellHeight: string;
        cellWidth: string;
        color: string;
        columns: string;
        lines: string;
        margin: string;
        padding: string;
    }

    export interface MediaSpeechRecognitionTemplateSpeechRecognition {
        channelNum: string;
        convertNumMode?: string;
        engineModelType: string;
        filterDirty?: string;
        filterModal?: string;
        filterPunc?: string;
        outputFileType?: string;
        resTextFormat?: string;
        speakerDiarization?: string;
        speakerNumber?: string;
    }

    export interface MediaTranscodeProTemplateAudio {
        codec: string;
        remove?: string;
    }

    export interface MediaTranscodeProTemplateContainer {
        clipConfig?: outputs.Ci.MediaTranscodeProTemplateContainerClipConfig;
        format: string;
    }

    export interface MediaTranscodeProTemplateContainerClipConfig {
        duration?: string;
    }

    export interface MediaTranscodeProTemplateTimeInterval {
        duration?: string;
        start?: string;
    }

    export interface MediaTranscodeProTemplateTransConfig {
        adjDarMethod?: string;
        audioBitrateAdjMethod?: string;
        deleteMetadata?: string;
        isCheckAudioBitrate?: string;
        isCheckReso?: string;
        isCheckVideoBitrate?: string;
        isHdr2Sdr?: string;
        resoAdjMethod?: string;
        videoBitrateAdjMethod?: string;
    }

    export interface MediaTranscodeProTemplateVideo {
        bitrate?: string;
        codec?: string;
        fps?: string;
        height?: string;
        interlaced?: string;
        profile?: string;
        rotate?: string;
        width?: string;
    }

    export interface MediaTranscodeTemplateAudio {
        bitrate?: string;
        channels?: string;
        codec?: string;
        keepTwoTracks?: string;
        remove?: string;
        sampleFormat?: string;
        samplerate?: string;
        switchTrack?: string;
    }

    export interface MediaTranscodeTemplateAudioMix {
        audioSource: string;
        effectConfig?: outputs.Ci.MediaTranscodeTemplateAudioMixEffectConfig;
        mixMode?: string;
        replace?: string;
    }

    export interface MediaTranscodeTemplateAudioMixEffectConfig {
        bgmFadeTime?: string;
        enableBgmFade?: string;
        enableEndFadeout?: string;
        enableStartFadein?: string;
        endFadeoutTime?: string;
        startFadeinTime?: string;
    }

    export interface MediaTranscodeTemplateContainer {
        clipConfig?: outputs.Ci.MediaTranscodeTemplateContainerClipConfig;
        format: string;
    }

    export interface MediaTranscodeTemplateContainerClipConfig {
        duration?: string;
    }

    export interface MediaTranscodeTemplateTimeInterval {
        duration?: string;
        start?: string;
    }

    export interface MediaTranscodeTemplateTransConfig {
        adjDarMethod?: string;
        audioBitrateAdjMethod?: string;
        deleteMetadata?: string;
        hlsEncrypt: outputs.Ci.MediaTranscodeTemplateTransConfigHlsEncrypt;
        isCheckAudioBitrate?: string;
        isCheckReso?: string;
        isCheckVideoBitrate?: string;
        isHdr2Sdr?: string;
        resoAdjMethod?: string;
        videoBitrateAdjMethod?: string;
    }

    export interface MediaTranscodeTemplateTransConfigHlsEncrypt {
        isHlsEncrypt: string;
        uriKey: string;
    }

    export interface MediaTranscodeTemplateVideo {
        bitrate?: string;
        bufsize?: string;
        codec?: string;
        crf?: string;
        fps?: string;
        gop?: string;
        height?: string;
        longShortMode?: string;
        maxrate?: string;
        pixfmt?: string;
        preset?: string;
        profile?: string;
        remove?: string;
        rotate?: string;
        width?: string;
    }

    export interface MediaVideoMontageTemplateAudio {
        bitrate?: string;
        channels?: string;
        codec: string;
        remove?: string;
        samplerate?: string;
    }

    export interface MediaVideoMontageTemplateAudioMix {
        audioSource: string;
        effectConfig?: outputs.Ci.MediaVideoMontageTemplateAudioMixEffectConfig;
        mixMode?: string;
        replace?: string;
    }

    export interface MediaVideoMontageTemplateAudioMixEffectConfig {
        bgmFadeTime?: string;
        enableBgmFade?: string;
        enableEndFadeout?: string;
        enableStartFadein?: string;
        endFadeoutTime?: string;
        startFadeinTime?: string;
    }

    export interface MediaVideoMontageTemplateContainer {
        format: string;
    }

    export interface MediaVideoMontageTemplateVideo {
        bitrate?: string;
        codec: string;
        crf?: string;
        fps?: string;
        height?: string;
        remove?: string;
        width?: string;
    }

    export interface MediaVideoProcessTemplateColorEnhance {
        contrast?: string;
        correction?: string;
        enable?: string;
        saturation?: string;
    }

    export interface MediaVideoProcessTemplateMsSharpen {
        enable?: string;
        sharpenLevel?: string;
    }

    export interface MediaVoiceSeparateTemplateAudioConfig {
        bitrate?: string;
        channels?: string;
        codec: string;
        samplerate?: string;
    }

    export interface MediaWatermarkTemplateWatermark {
        dx: string;
        dy: string;
        endTime?: string;
        image?: outputs.Ci.MediaWatermarkTemplateWatermarkImage;
        locMode: string;
        pos: string;
        startTime?: string;
        text?: outputs.Ci.MediaWatermarkTemplateWatermarkText;
        type: string;
    }

    export interface MediaWatermarkTemplateWatermarkImage {
        background: string;
        height?: string;
        mode: string;
        transparency: string;
        url: string;
        width?: string;
    }

    export interface MediaWatermarkTemplateWatermarkText {
        fontColor: string;
        fontSize: string;
        fontType: string;
        text: string;
        transparency: string;
    }

}

export namespace Ckafka {
    export interface AclRuleRuleList {
        host: string;
        operation: string;
        permissionType: string;
        principal: string;
    }

    export interface ConnectResourceClickhouseConnectParam {
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceDorisConnectParam {
        bePort?: number;
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt?: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceDtsConnectParam {
        groupId: string;
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        topic: string;
        userName: string;
    }

    export interface ConnectResourceEsConnectParam {
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceKafkaConnectParam {
        brokerAddress?: string;
        isUpdate?: boolean;
        region?: string;
        resource?: string;
        selfBuilt?: boolean;
    }

    export interface ConnectResourceMariadbConnectParam {
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceMongodbConnectParam {
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceMysqlConnectParam {
        clusterId?: string;
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt?: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourcePostgresqlConnectParam {
        clusterId?: string;
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt?: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface ConnectResourceSqlserverConnectParam {
        isUpdate?: boolean;
        password: string;
        port: number;
        resource: string;
        serviceVip?: string;
        uniqVpcId?: string;
        userName: string;
    }

    export interface DatahubTaskSourceResource {
        clickHouseParam?: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParam;
        clsParam?: outputs.Ckafka.DatahubTaskSourceResourceClsParam;
        cosParam?: outputs.Ckafka.DatahubTaskSourceResourceCosParam;
        ctsdbParam?: outputs.Ckafka.DatahubTaskSourceResourceCtsdbParam;
        dtsParam?: outputs.Ckafka.DatahubTaskSourceResourceDtsParam;
        esParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParam;
        eventBusParam?: outputs.Ckafka.DatahubTaskSourceResourceEventBusParam;
        kafkaParam?: outputs.Ckafka.DatahubTaskSourceResourceKafkaParam;
        mariaDbParam?: outputs.Ckafka.DatahubTaskSourceResourceMariaDbParam;
        mongoDbParam?: outputs.Ckafka.DatahubTaskSourceResourceMongoDbParam;
        mySqlParam?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParam;
        postgreSqlParam?: outputs.Ckafka.DatahubTaskSourceResourcePostgreSqlParam;
        scfParam?: outputs.Ckafka.DatahubTaskSourceResourceScfParam;
        sqlServerParam?: outputs.Ckafka.DatahubTaskSourceResourceSqlServerParam;
        tdwParam?: outputs.Ckafka.DatahubTaskSourceResourceTdwParam;
        topicParam?: outputs.Ckafka.DatahubTaskSourceResourceTopicParam;
        type: string;
    }

    export interface DatahubTaskSourceResourceClickHouseParam {
        cluster: string;
        database: string;
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParamDropCls;
        dropInvalidMessage?: boolean;
        ip?: string;
        password?: string;
        port?: number;
        resource: string;
        schemas: outputs.Ckafka.DatahubTaskSourceResourceClickHouseParamSchema[];
        selfBuilt?: boolean;
        serviceVip?: string;
        table: string;
        type?: string;
        uniqVpcId?: string;
        userName?: string;
    }

    export interface DatahubTaskSourceResourceClickHouseParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourceClickHouseParamSchema {
        allowNull: boolean;
        columnName: string;
        jsonKey: string;
        type: string;
    }

    export interface DatahubTaskSourceResourceClsParam {
        contentKey?: string;
        decodeJson: boolean;
        logSet?: string;
        resource: string;
        timeField?: string;
    }

    export interface DatahubTaskSourceResourceCosParam {
        aggregateBatchSize?: number;
        aggregateInterval?: number;
        bucketName: string;
        directoryTimeFormat?: string;
        formatOutputType?: string;
        objectKey?: string;
        objectKeyPrefix?: string;
        region: string;
    }

    export interface DatahubTaskSourceResourceCtsdbParam {
        ctsdbMetric?: string;
        resource?: string;
    }

    export interface DatahubTaskSourceResourceDtsParam {
        groupId?: string;
        groupPassword?: string;
        groupUser?: string;
        ip?: string;
        port?: number;
        resource: string;
        topic?: string;
        tranSql?: boolean;
    }

    export interface DatahubTaskSourceResourceEsParam {
        contentKey?: string;
        databasePrimaryKey?: string;
        dateFormat?: string;
        documentIdField?: string;
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropCls;
        dropDlq?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlq;
        dropInvalidJsonMessage?: boolean;
        dropInvalidMessage?: boolean;
        index?: string;
        indexType?: string;
        password?: string;
        port?: number;
        resource: string;
        selfBuilt?: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName?: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlq {
        dlqType?: string;
        kafkaParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqKafkaParam;
        maxRetryAttempts?: number;
        retryInterval?: number;
        topicParam?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqTopicParam;
        type: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskSourceResourceEsParamDropDlqKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskSourceResourceEsParamDropDlqTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId?: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskSourceResourceEventBusParam {
        functionName?: string;
        namespace?: string;
        qualifier?: string;
        resource: string;
        selfBuilt: boolean;
        type: string;
    }

    export interface DatahubTaskSourceResourceKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskSourceResourceKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskSourceResourceKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskSourceResourceMariaDbParam {
        database: string;
        includeContentChanges?: string;
        includeQuery?: boolean;
        isTablePrefix?: boolean;
        keyColumns?: string;
        outputFormat?: string;
        recordWithSchema?: boolean;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskSourceResourceMongoDbParam {
        collection: string;
        copyExisting: boolean;
        database: string;
        ip?: string;
        listeningEvent?: string;
        password?: string;
        pipeline?: string;
        port?: number;
        readPreference?: string;
        resource: string;
        selfBuilt?: boolean;
        userName?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParam {
        dataSourceIncrementColumn?: string;
        dataSourceIncrementMode?: string;
        dataSourceMonitorMode?: string;
        dataSourceMonitorResource?: string;
        dataSourceStartFrom?: string;
        dataTargetInsertMode?: string;
        dataTargetPrimaryKeyField?: string;
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParamDataTargetRecordMapping[];
        database: string;
        ddlTopic?: string;
        dropCls?: outputs.Ckafka.DatahubTaskSourceResourceMySqlParamDropCls;
        dropInvalidMessage?: boolean;
        includeContentChanges?: string;
        includeQuery?: boolean;
        isTablePrefix?: boolean;
        isTableRegular?: boolean;
        keyColumns?: string;
        outputFormat?: string;
        recordWithSchema?: boolean;
        resource: string;
        signalDatabase?: string;
        snapshotMode?: string;
        table: string;
        topicRegex?: string;
        topicReplacement?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParamDataTargetRecordMapping {
        allowNull?: boolean;
        autoIncrement?: boolean;
        columnName?: string;
        columnSize?: string;
        decimalDigits?: string;
        defaultValue?: string;
        extraInfo?: string;
        jsonKey?: string;
        type?: string;
    }

    export interface DatahubTaskSourceResourceMySqlParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskSourceResourcePostgreSqlParam {
        dataFormat?: string;
        dataTargetInsertMode?: string;
        dataTargetPrimaryKeyField?: string;
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskSourceResourcePostgreSqlParamDataTargetRecordMapping[];
        database: string;
        dropInvalidMessage?: boolean;
        isTableRegular?: boolean;
        keyColumns?: string;
        pluginName: string;
        recordWithSchema?: boolean;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskSourceResourcePostgreSqlParamDataTargetRecordMapping {
        allowNull?: boolean;
        autoIncrement?: boolean;
        columnName?: string;
        columnSize?: string;
        decimalDigits?: string;
        defaultValue?: string;
        extraInfo?: string;
        jsonKey?: string;
        type?: string;
    }

    export interface DatahubTaskSourceResourceScfParam {
        batchSize?: number;
        functionName: string;
        maxRetries?: number;
        namespace?: string;
        qualifier?: string;
    }

    export interface DatahubTaskSourceResourceSqlServerParam {
        database: string;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskSourceResourceTdwParam {
        bid: string;
        isDomestic?: boolean;
        tdwHost?: string;
        tdwPort?: number;
        tid: string;
    }

    export interface DatahubTaskSourceResourceTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId?: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTargetResource {
        clickHouseParam?: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParam;
        clsParam?: outputs.Ckafka.DatahubTaskTargetResourceClsParam;
        cosParam?: outputs.Ckafka.DatahubTaskTargetResourceCosParam;
        ctsdbParam?: outputs.Ckafka.DatahubTaskTargetResourceCtsdbParam;
        dtsParam?: outputs.Ckafka.DatahubTaskTargetResourceDtsParam;
        esParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParam;
        eventBusParam?: outputs.Ckafka.DatahubTaskTargetResourceEventBusParam;
        kafkaParam?: outputs.Ckafka.DatahubTaskTargetResourceKafkaParam;
        mariaDbParam?: outputs.Ckafka.DatahubTaskTargetResourceMariaDbParam;
        mongoDbParam?: outputs.Ckafka.DatahubTaskTargetResourceMongoDbParam;
        mySqlParam?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParam;
        postgreSqlParam?: outputs.Ckafka.DatahubTaskTargetResourcePostgreSqlParam;
        scfParam?: outputs.Ckafka.DatahubTaskTargetResourceScfParam;
        sqlServerParam?: outputs.Ckafka.DatahubTaskTargetResourceSqlServerParam;
        tdwParam?: outputs.Ckafka.DatahubTaskTargetResourceTdwParam;
        topicParam?: outputs.Ckafka.DatahubTaskTargetResourceTopicParam;
        type: string;
    }

    export interface DatahubTaskTargetResourceClickHouseParam {
        cluster: string;
        database: string;
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParamDropCls;
        dropInvalidMessage?: boolean;
        ip?: string;
        password?: string;
        port?: number;
        resource: string;
        schemas: outputs.Ckafka.DatahubTaskTargetResourceClickHouseParamSchema[];
        selfBuilt?: boolean;
        serviceVip?: string;
        table: string;
        type?: string;
        uniqVpcId?: string;
        userName?: string;
    }

    export interface DatahubTaskTargetResourceClickHouseParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourceClickHouseParamSchema {
        allowNull: boolean;
        columnName: string;
        jsonKey: string;
        type: string;
    }

    export interface DatahubTaskTargetResourceClsParam {
        contentKey?: string;
        decodeJson: boolean;
        logSet?: string;
        resource: string;
        timeField?: string;
    }

    export interface DatahubTaskTargetResourceCosParam {
        aggregateBatchSize?: number;
        aggregateInterval?: number;
        bucketName: string;
        directoryTimeFormat?: string;
        formatOutputType?: string;
        objectKey?: string;
        objectKeyPrefix?: string;
        region: string;
    }

    export interface DatahubTaskTargetResourceCtsdbParam {
        ctsdbMetric?: string;
        resource?: string;
    }

    export interface DatahubTaskTargetResourceDtsParam {
        groupId?: string;
        groupPassword?: string;
        groupUser?: string;
        ip?: string;
        port?: number;
        resource: string;
        topic?: string;
        tranSql?: boolean;
    }

    export interface DatahubTaskTargetResourceEsParam {
        contentKey?: string;
        databasePrimaryKey?: string;
        dateFormat?: string;
        documentIdField?: string;
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropCls;
        dropDlq?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlq;
        dropInvalidJsonMessage?: boolean;
        dropInvalidMessage?: boolean;
        index?: string;
        indexType?: string;
        password?: string;
        port?: number;
        resource: string;
        selfBuilt?: boolean;
        serviceVip?: string;
        uniqVpcId?: string;
        userName?: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlq {
        dlqType?: string;
        kafkaParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqKafkaParam;
        maxRetryAttempts?: number;
        retryInterval?: number;
        topicParam?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqTopicParam;
        type: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskTargetResourceEsParamDropDlqKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskTargetResourceEsParamDropDlqTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId?: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTargetResourceEventBusParam {
        functionName?: string;
        namespace?: string;
        qualifier?: string;
        resource: string;
        selfBuilt: boolean;
        type: string;
    }

    export interface DatahubTaskTargetResourceKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskTargetResourceKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskTargetResourceKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskTargetResourceMariaDbParam {
        database: string;
        includeContentChanges?: string;
        includeQuery?: boolean;
        isTablePrefix?: boolean;
        keyColumns?: string;
        outputFormat?: string;
        recordWithSchema?: boolean;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskTargetResourceMongoDbParam {
        collection: string;
        copyExisting: boolean;
        database: string;
        ip?: string;
        listeningEvent?: string;
        password?: string;
        pipeline?: string;
        port?: number;
        readPreference?: string;
        resource: string;
        selfBuilt?: boolean;
        userName?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParam {
        dataSourceIncrementColumn?: string;
        dataSourceIncrementMode?: string;
        dataSourceMonitorMode?: string;
        dataSourceMonitorResource?: string;
        dataSourceStartFrom?: string;
        dataTargetInsertMode?: string;
        dataTargetPrimaryKeyField?: string;
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParamDataTargetRecordMapping[];
        database: string;
        ddlTopic?: string;
        dropCls?: outputs.Ckafka.DatahubTaskTargetResourceMySqlParamDropCls;
        dropInvalidMessage?: boolean;
        includeContentChanges?: string;
        includeQuery?: boolean;
        isTablePrefix?: boolean;
        isTableRegular?: boolean;
        keyColumns?: string;
        outputFormat?: string;
        recordWithSchema?: boolean;
        resource: string;
        signalDatabase?: string;
        snapshotMode?: string;
        table: string;
        topicRegex?: string;
        topicReplacement?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParamDataTargetRecordMapping {
        allowNull?: boolean;
        autoIncrement?: boolean;
        columnName?: string;
        columnSize?: string;
        decimalDigits?: string;
        defaultValue?: string;
        extraInfo?: string;
        jsonKey?: string;
        type?: string;
    }

    export interface DatahubTaskTargetResourceMySqlParamDropCls {
        dropClsLogSet?: string;
        dropClsOwneruin?: string;
        dropClsRegion?: string;
        dropClsTopicId?: string;
        dropInvalidMessageToCls?: boolean;
    }

    export interface DatahubTaskTargetResourcePostgreSqlParam {
        dataFormat?: string;
        dataTargetInsertMode?: string;
        dataTargetPrimaryKeyField?: string;
        dataTargetRecordMappings?: outputs.Ckafka.DatahubTaskTargetResourcePostgreSqlParamDataTargetRecordMapping[];
        database: string;
        dropInvalidMessage?: boolean;
        isTableRegular?: boolean;
        keyColumns?: string;
        pluginName: string;
        recordWithSchema?: boolean;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskTargetResourcePostgreSqlParamDataTargetRecordMapping {
        allowNull?: boolean;
        autoIncrement?: boolean;
        columnName?: string;
        columnSize?: string;
        decimalDigits?: string;
        defaultValue?: string;
        extraInfo?: string;
        jsonKey?: string;
        type?: string;
    }

    export interface DatahubTaskTargetResourceScfParam {
        batchSize?: number;
        functionName: string;
        maxRetries?: number;
        namespace?: string;
        qualifier?: string;
    }

    export interface DatahubTaskTargetResourceSqlServerParam {
        database: string;
        resource: string;
        snapshotMode?: string;
        table: string;
    }

    export interface DatahubTaskTargetResourceTdwParam {
        bid: string;
        isDomestic?: boolean;
        tdwHost?: string;
        tdwPort?: number;
        tid: string;
    }

    export interface DatahubTaskTargetResourceTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformParam {
        analyseResults?: outputs.Ckafka.DatahubTaskTransformParamAnalyseResult[];
        analysisFormat: string;
        content: string;
        failureParam: outputs.Ckafka.DatahubTaskTransformParamFailureParam;
        filterParams?: outputs.Ckafka.DatahubTaskTransformParamFilterParam[];
        mapParams?: outputs.Ckafka.DatahubTaskTransformParamMapParam[];
        outputFormat: string;
        regex?: string;
        result?: string;
        sourceType: string;
        useEventBus?: boolean;
    }

    export interface DatahubTaskTransformParamAnalyseResult {
        key: string;
        type?: string;
        value?: string;
    }

    export interface DatahubTaskTransformParamFailureParam {
        dlqType?: string;
        kafkaParam?: outputs.Ckafka.DatahubTaskTransformParamFailureParamKafkaParam;
        maxRetryAttempts?: number;
        retryInterval?: number;
        topicParam?: outputs.Ckafka.DatahubTaskTransformParamFailureParamTopicParam;
        type: string;
    }

    export interface DatahubTaskTransformParamFailureParamKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskTransformParamFailureParamKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskTransformParamFailureParamKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskTransformParamFailureParamTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId?: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformParamFilterParam {
        key: string;
        matchMode: string;
        type?: string;
        value: string;
    }

    export interface DatahubTaskTransformParamMapParam {
        key: string;
        type?: string;
        value?: string;
    }

    export interface DatahubTaskTransformsParam {
        batchAnalyse?: outputs.Ckafka.DatahubTaskTransformsParamBatchAnalyse;
        content: string;
        failureParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParam;
        fieldChains: outputs.Ckafka.DatahubTaskTransformsParamFieldChain[];
        filterParams?: outputs.Ckafka.DatahubTaskTransformsParamFilterParam[];
        keepMetadata?: boolean;
        outputFormat?: string;
        result?: string;
        rowParam?: outputs.Ckafka.DatahubTaskTransformsParamRowParam;
        sourceType?: string;
    }

    export interface DatahubTaskTransformsParamBatchAnalyse {
        format: string;
    }

    export interface DatahubTaskTransformsParamFailureParam {
        dlqType?: string;
        kafkaParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamKafkaParam;
        maxRetryAttempts?: number;
        retryInterval?: number;
        topicParam?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamTopicParam;
        type: string;
    }

    export interface DatahubTaskTransformsParamFailureParamKafkaParam {
        compressionType?: string;
        enableToleration?: boolean;
        msgMultiple?: number;
        offsetType?: string;
        partitionNum?: number;
        qpsLimit?: number;
        resource: string;
        resourceName?: string;
        selfBuilt: boolean;
        startTime?: number;
        tableMappings?: outputs.Ckafka.DatahubTaskTransformsParamFailureParamKafkaParamTableMapping[];
        topic?: string;
        topicId?: string;
        useAutoCreateTopic?: boolean;
        useTableMapping?: boolean;
        zoneId?: number;
    }

    export interface DatahubTaskTransformsParamFailureParamKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface DatahubTaskTransformsParamFailureParamTopicParam {
        compressionType?: string;
        msgMultiple?: number;
        offsetType?: string;
        resource: string;
        startTime?: number;
        topicId?: string;
        useAutoCreateTopic?: boolean;
    }

    export interface DatahubTaskTransformsParamFieldChain {
        analyse: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyse;
        analyseJsonResult?: string;
        analyseResults?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResult[];
        result?: string;
        sMTs?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMT[];
        secondaryAnalyse?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyse;
        secondaryAnalyseJsonResult?: string;
        secondaryAnalyseResults?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResult[];
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyse {
        format: string;
        inputValue?: string;
        inputValueType?: string;
        regex?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResult {
        key: string;
        operate: string;
        originalValue?: string;
        schemeType: string;
        value?: string;
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate;
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperate {
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateDate;
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateJsonPathReplace;
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateKV;
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateRegexReplace;
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateReplace;
        result?: string;
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSplit;
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSubstr;
        type: string;
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateDate {
        format?: string;
        targetType?: string;
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateJsonPathReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateKV {
        delimiter: string;
        keepOriginalKey?: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateRegexReplace {
        newValue: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSplit {
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateSubstr {
        end: number;
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainAnalyseResultValueOperateUrlDecode {
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMT {
        key: string;
        operate: string;
        originalValue?: string;
        schemeType: string;
        value?: string;
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperate;
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperate {
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateDate;
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateJsonPathReplace;
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateKV;
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateRegexReplace;
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateReplace;
        result?: string;
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateSplit;
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateSubstr;
        type: string;
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSMTValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateDate {
        format?: string;
        targetType?: string;
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateJsonPathReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateKV {
        delimiter: string;
        keepOriginalKey?: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateRegexReplace {
        newValue: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateSplit {
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateSubstr {
        end: number;
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainSMTValueOperateUrlDecode {
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyse {
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResult {
        key: string;
        operate: string;
        originalValue?: string;
        schemeType: string;
        value?: string;
        valueOperate?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate;
        valueOperates?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate[];
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperate {
        date?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateDate;
        jsonPathReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateJsonPathReplace;
        kV?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateKV;
        regexReplace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateRegexReplace;
        replace?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateReplace;
        result?: string;
        split?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSplit;
        substr?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSubstr;
        type: string;
        urlDecode?: outputs.Ckafka.DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateUrlDecode;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateDate {
        format?: string;
        targetType?: string;
        timeZone?: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateJsonPathReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateKV {
        delimiter: string;
        keepOriginalKey?: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateRegexReplace {
        newValue: string;
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateReplace {
        newValue: string;
        oldValue: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSplit {
        regex: string;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateSubstr {
        end: number;
        start: number;
    }

    export interface DatahubTaskTransformsParamFieldChainSecondaryAnalyseResultValueOperateUrlDecode {
        charsetName?: string;
    }

    export interface DatahubTaskTransformsParamFilterParam {
        key: string;
        matchMode: string;
        type?: string;
        value: string;
    }

    export interface DatahubTaskTransformsParamRowParam {
        entryDelimiter?: string;
        keyValueDelimiter?: string;
        rowContent: string;
    }

    export interface GetAclsAclList {
        host: string;
        operationType: string;
        permissionType: string;
        principal: string;
        resourceName: string;
        resourceType: string;
    }

    export interface GetConnectResourceResult {
        connectResourceLists: outputs.Ckafka.GetConnectResourceResultConnectResourceList[];
        totalCount: number;
    }

    export interface GetConnectResourceResultConnectResourceList {
        clickhouseConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListClickhouseConnectParam[];
        createTime: string;
        ctsdbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListCtsdbConnectParam[];
        currentStep: string;
        datahubTaskCount: number;
        description: string;
        dorisConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListDorisConnectParam[];
        dtsConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListDtsConnectParam[];
        errorMessage: string;
        esConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListEsConnectParam[];
        kafkaConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListKafkaConnectParam[];
        mariaDbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMariaDbConnectParam[];
        mongoDbConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMongoDbConnectParam[];
        mysqlConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListMysqlConnectParam[];
        postgreSqlConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListPostgreSqlConnectParam[];
        resourceId: string;
        resourceName: string;
        sqlServerConnectParams: outputs.Ckafka.GetConnectResourceResultConnectResourceListSqlServerConnectParam[];
        status: number;
        stepLists: string[];
        taskProgress: number;
        type: string;
    }

    export interface GetConnectResourceResultConnectResourceListClickhouseConnectParam {
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListCtsdbConnectParam {
        password: string;
        port: number;
        resource: string;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListDorisConnectParam {
        bePort: number;
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListDtsConnectParam {
        groupId: string;
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        topic: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListEsConnectParam {
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListKafkaConnectParam {
        brokerAddress: string;
        isUpdate: boolean;
        region: string;
        resource: string;
        selfBuilt: boolean;
    }

    export interface GetConnectResourceResultConnectResourceListMariaDbConnectParam {
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListMongoDbConnectParam {
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListMysqlConnectParam {
        clusterId: string;
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListPostgreSqlConnectParam {
        clusterId: string;
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetConnectResourceResultConnectResourceListSqlServerConnectParam {
        isUpdate: boolean;
        password: string;
        port: number;
        resource: string;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetDatahubGroupOffsetsTopicList {
        partitions: outputs.Ckafka.GetDatahubGroupOffsetsTopicListPartition[];
        topic: string;
    }

    export interface GetDatahubGroupOffsetsTopicListPartition {
        errorCode: number;
        lag: number;
        logEndOffset: number;
        metadata: string;
        offset: number;
        partition: number;
    }

    export interface GetDatahubTaskTaskList {
        createTime: string;
        datahubId: string;
        errorMessage: string;
        sourceResources: outputs.Ckafka.GetDatahubTaskTaskListSourceResource[];
        status: number;
        stepLists: string[];
        targetResources: outputs.Ckafka.GetDatahubTaskTaskListTargetResource[];
        taskCurrentStep: string;
        taskId: string;
        taskName: string;
        taskProgress: number;
        taskType: string;
    }

    export interface GetDatahubTaskTaskListSourceResource {
        clickHouseParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParam[];
        clsParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClsParam[];
        cosParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceCosParam[];
        ctsdbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceCtsdbParam[];
        dtsParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceDtsParam[];
        esParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParam[];
        eventBusParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEventBusParam[];
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceKafkaParam[];
        mariaDbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMariaDbParam[];
        mongoDbParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMongoDbParam[];
        mySqlParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParam[];
        postgreSqlParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourcePostgreSqlParam[];
        scfParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceScfParam[];
        sqlServerParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceSqlServerParam[];
        tdwParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceTdwParam[];
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceTopicParam[];
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParam {
        cluster: string;
        database: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParamDropCl[];
        dropInvalidMessage: boolean;
        ip: string;
        password: string;
        port: number;
        resource: string;
        schemas: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceClickHouseParamSchema[];
        selfBuilt: boolean;
        serviceVip: string;
        table: string;
        type: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceClickHouseParamSchema {
        allowNull: boolean;
        columnName: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceClsParam {
        contentKey: string;
        decodeJson: boolean;
        logSet: string;
        resource: string;
        timeField: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceCosParam {
        aggregateBatchSize: number;
        aggregateInterval: number;
        bucketName: string;
        directoryTimeFormat: string;
        formatOutputType: string;
        objectKey: string;
        objectKeyPrefix: string;
        region: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceCtsdbParam {
        ctsdbMetric: string;
        resource: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceDtsParam {
        groupId: string;
        groupPassword: string;
        groupUser: string;
        ip: string;
        port: number;
        resource: string;
        topic: string;
        tranSql: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParam {
        contentKey: string;
        databasePrimaryKey: string;
        dateFormat: string;
        documentIdField: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropCl[];
        dropDlqs: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlq[];
        dropInvalidJsonMessage: boolean;
        dropInvalidMessage: boolean;
        index: string;
        indexType: string;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlq {
        dlqType: string;
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParam[];
        maxRetryAttempts: number;
        retryInterval: number;
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqTopicParam[];
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParam {
        compressionType: string;
        connectorSyncType: string;
        enableToleration: boolean;
        keepPartition: boolean;
        msgMultiple: number;
        offsetType: string;
        partitionNum: number;
        qpsLimit: number;
        resource: string;
        resourceName: string;
        selfBuilt: boolean;
        startTime: number;
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParamTableMapping[];
        topic: string;
        topicId: string;
        useAutoCreateTopic: boolean;
        useTableMapping: boolean;
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceEsParamDropDlqTopicParam {
        compressionType: string;
        msgMultiple: number;
        offsetType: string;
        resource: string;
        startTime: number;
        topicId: string;
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourceEventBusParam {
        functionName: string;
        namespace: string;
        qualifier: string;
        resource: string;
        selfBuilt: boolean;
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceKafkaParam {
        compressionType: string;
        connectorSyncType: string;
        enableToleration: boolean;
        keepPartition: boolean;
        msgMultiple: number;
        offsetType: string;
        partitionNum: number;
        qpsLimit: number;
        resource: string;
        resourceName: string;
        selfBuilt: boolean;
        startTime: number;
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceKafkaParamTableMapping[];
        topic: string;
        topicId: string;
        useAutoCreateTopic: boolean;
        useTableMapping: boolean;
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListSourceResourceKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMariaDbParam {
        database: string;
        includeContentChanges: string;
        includeQuery: boolean;
        isTablePrefix: boolean;
        keyColumns: string;
        outputFormat: string;
        recordWithSchema: boolean;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMongoDbParam {
        collection: string;
        copyExisting: boolean;
        database: string;
        ip: string;
        listeningEvent: string;
        password: string;
        pipeline: string;
        port: number;
        readPreference: string;
        resource: string;
        selfBuilt: boolean;
        userName: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParam {
        dataSourceIncrementColumn: string;
        dataSourceIncrementMode: string;
        dataSourceMonitorMode: string;
        dataSourceMonitorResource: string;
        dataSourceStartFrom: string;
        dataTargetInsertMode: string;
        dataTargetPrimaryKeyField: string;
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParamDataTargetRecordMapping[];
        database: string;
        ddlTopic: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListSourceResourceMySqlParamDropCl[];
        dropInvalidMessage: boolean;
        includeContentChanges: string;
        includeQuery: boolean;
        isTablePrefix: boolean;
        isTableRegular: boolean;
        keyColumns: string;
        outputFormat: string;
        recordWithSchema: boolean;
        resource: string;
        signalDatabase: string;
        snapshotMode: string;
        table: string;
        topicRegex: string;
        topicReplacement: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParamDataTargetRecordMapping {
        allowNull: boolean;
        autoIncrement: boolean;
        columnName: string;
        columnSize: string;
        decimalDigits: string;
        defaultValue: string;
        extraInfo: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceMySqlParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListSourceResourcePostgreSqlParam {
        dataFormat: string;
        dataTargetInsertMode: string;
        dataTargetPrimaryKeyField: string;
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListSourceResourcePostgreSqlParamDataTargetRecordMapping[];
        database: string;
        dropInvalidMessage: boolean;
        isTableRegular: boolean;
        keyColumns: string;
        pluginName: string;
        recordWithSchema: boolean;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourcePostgreSqlParamDataTargetRecordMapping {
        allowNull: boolean;
        autoIncrement: boolean;
        columnName: string;
        columnSize: string;
        decimalDigits: string;
        defaultValue: string;
        extraInfo: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceScfParam {
        batchSize: number;
        functionName: string;
        maxRetries: number;
        namespace: string;
        qualifier: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceSqlServerParam {
        database: string;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceTdwParam {
        bid: string;
        isDomestic: boolean;
        tdwHost: string;
        tdwPort: number;
        tid: string;
    }

    export interface GetDatahubTaskTaskListSourceResourceTopicParam {
        compressionType: string;
        msgMultiple: number;
        offsetType: string;
        resource: string;
        startTime: number;
        topicId: string;
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResource {
        clickHouseParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParam[];
        clsParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClsParam[];
        cosParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceCosParam[];
        ctsdbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceCtsdbParam[];
        dtsParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceDtsParam[];
        esParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParam[];
        eventBusParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEventBusParam[];
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceKafkaParam[];
        mariaDbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMariaDbParam[];
        mongoDbParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMongoDbParam[];
        mySqlParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParam[];
        postgreSqlParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourcePostgreSqlParam[];
        scfParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceScfParam[];
        sqlServerParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceSqlServerParam[];
        tdwParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceTdwParam[];
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceTopicParam[];
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParam {
        cluster: string;
        database: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParamDropCl[];
        dropInvalidMessage: boolean;
        ip: string;
        password: string;
        port: number;
        resource: string;
        schemas: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceClickHouseParamSchema[];
        selfBuilt: boolean;
        serviceVip: string;
        table: string;
        type: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceClickHouseParamSchema {
        allowNull: boolean;
        columnName: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceClsParam {
        contentKey: string;
        decodeJson: boolean;
        logSet: string;
        resource: string;
        timeField: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceCosParam {
        aggregateBatchSize: number;
        aggregateInterval: number;
        bucketName: string;
        directoryTimeFormat: string;
        formatOutputType: string;
        objectKey: string;
        objectKeyPrefix: string;
        region: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceCtsdbParam {
        ctsdbMetric: string;
        resource: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceDtsParam {
        groupId: string;
        groupPassword: string;
        groupUser: string;
        ip: string;
        port: number;
        resource: string;
        topic: string;
        tranSql: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParam {
        contentKey: string;
        databasePrimaryKey: string;
        dateFormat: string;
        documentIdField: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropCl[];
        dropDlqs: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlq[];
        dropInvalidJsonMessage: boolean;
        dropInvalidMessage: boolean;
        index: string;
        indexType: string;
        password: string;
        port: number;
        resource: string;
        selfBuilt: boolean;
        serviceVip: string;
        uniqVpcId: string;
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlq {
        dlqType: string;
        kafkaParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParam[];
        maxRetryAttempts: number;
        retryInterval: number;
        topicParams: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqTopicParam[];
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParam {
        compressionType: string;
        connectorSyncType: string;
        enableToleration: boolean;
        keepPartition: boolean;
        msgMultiple: number;
        offsetType: string;
        partitionNum: number;
        qpsLimit: number;
        resource: string;
        resourceName: string;
        selfBuilt: boolean;
        startTime: number;
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParamTableMapping[];
        topic: string;
        topicId: string;
        useAutoCreateTopic: boolean;
        useTableMapping: boolean;
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceEsParamDropDlqTopicParam {
        compressionType: string;
        msgMultiple: number;
        offsetType: string;
        resource: string;
        startTime: number;
        topicId: string;
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourceEventBusParam {
        functionName: string;
        namespace: string;
        qualifier: string;
        resource: string;
        selfBuilt: boolean;
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceKafkaParam {
        compressionType: string;
        connectorSyncType: string;
        enableToleration: boolean;
        keepPartition: boolean;
        msgMultiple: number;
        offsetType: string;
        partitionNum: number;
        qpsLimit: number;
        resource: string;
        resourceName: string;
        selfBuilt: boolean;
        startTime: number;
        tableMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceKafkaParamTableMapping[];
        topic: string;
        topicId: string;
        useAutoCreateTopic: boolean;
        useTableMapping: boolean;
        zoneId: number;
    }

    export interface GetDatahubTaskTaskListTargetResourceKafkaParamTableMapping {
        database: string;
        table: string;
        topic: string;
        topicId: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMariaDbParam {
        database: string;
        includeContentChanges: string;
        includeQuery: boolean;
        isTablePrefix: boolean;
        keyColumns: string;
        outputFormat: string;
        recordWithSchema: boolean;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMongoDbParam {
        collection: string;
        copyExisting: boolean;
        database: string;
        ip: string;
        listeningEvent: string;
        password: string;
        pipeline: string;
        port: number;
        readPreference: string;
        resource: string;
        selfBuilt: boolean;
        userName: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParam {
        dataSourceIncrementColumn: string;
        dataSourceIncrementMode: string;
        dataSourceMonitorMode: string;
        dataSourceMonitorResource: string;
        dataSourceStartFrom: string;
        dataTargetInsertMode: string;
        dataTargetPrimaryKeyField: string;
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParamDataTargetRecordMapping[];
        database: string;
        ddlTopic: string;
        dropCls: outputs.Ckafka.GetDatahubTaskTaskListTargetResourceMySqlParamDropCl[];
        dropInvalidMessage: boolean;
        includeContentChanges: string;
        includeQuery: boolean;
        isTablePrefix: boolean;
        isTableRegular: boolean;
        keyColumns: string;
        outputFormat: string;
        recordWithSchema: boolean;
        resource: string;
        signalDatabase: string;
        snapshotMode: string;
        table: string;
        topicRegex: string;
        topicReplacement: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParamDataTargetRecordMapping {
        allowNull: boolean;
        autoIncrement: boolean;
        columnName: string;
        columnSize: string;
        decimalDigits: string;
        defaultValue: string;
        extraInfo: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceMySqlParamDropCl {
        dropClsLogSet: string;
        dropClsOwneruin: string;
        dropClsRegion: string;
        dropClsTopicId: string;
        dropInvalidMessageToCls: boolean;
    }

    export interface GetDatahubTaskTaskListTargetResourcePostgreSqlParam {
        dataFormat: string;
        dataTargetInsertMode: string;
        dataTargetPrimaryKeyField: string;
        dataTargetRecordMappings: outputs.Ckafka.GetDatahubTaskTaskListTargetResourcePostgreSqlParamDataTargetRecordMapping[];
        database: string;
        dropInvalidMessage: boolean;
        isTableRegular: boolean;
        keyColumns: string;
        pluginName: string;
        recordWithSchema: boolean;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourcePostgreSqlParamDataTargetRecordMapping {
        allowNull: boolean;
        autoIncrement: boolean;
        columnName: string;
        columnSize: string;
        decimalDigits: string;
        defaultValue: string;
        extraInfo: string;
        jsonKey: string;
        type: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceScfParam {
        batchSize: number;
        functionName: string;
        maxRetries: number;
        namespace: string;
        qualifier: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceSqlServerParam {
        database: string;
        resource: string;
        snapshotMode: string;
        table: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceTdwParam {
        bid: string;
        isDomestic: boolean;
        tdwHost: string;
        tdwPort: number;
        tid: string;
    }

    export interface GetDatahubTaskTaskListTargetResourceTopicParam {
        compressionType: string;
        msgMultiple: number;
        offsetType: string;
        resource: string;
        startTime: number;
        topicId: string;
        useAutoCreateTopic: boolean;
    }

    export interface GetDatahubTopicTopicList {
        name: string;
        note: string;
        partitionNum: number;
        retentionMs: number;
        status: number;
        topicId: string;
        topicName: string;
    }

    export interface GetGroupGroupList {
        group: string;
        protocol: string;
    }

    export interface GetGroupInfoResult {
        errorCode: string;
        group: string;
        members: outputs.Ckafka.GetGroupInfoResultMember[];
        protocol: string;
        protocolType: string;
        state: string;
    }

    export interface GetGroupInfoResultMember {
        assignments: outputs.Ckafka.GetGroupInfoResultMemberAssignment[];
        clientHost: string;
        clientId: string;
        memberId: string;
    }

    export interface GetGroupInfoResultMemberAssignment {
        topics: outputs.Ckafka.GetGroupInfoResultMemberAssignmentTopic[];
        version: number;
    }

    export interface GetGroupInfoResultMemberAssignmentTopic {
        partitions: number[];
        topic: string;
    }

    export interface GetGroupOffsetsTopicList {
        partitions: outputs.Ckafka.GetGroupOffsetsTopicListPartition[];
        topic: string;
    }

    export interface GetGroupOffsetsTopicListPartition {
        errorCode: number;
        lag: number;
        logEndOffset: number;
        metadata: string;
        offset: number;
        partition: number;
    }

    export interface GetInstancesFilter {
        name: string;
        values: string[];
    }

    export interface GetInstancesInstanceList {
        bandwidth: number;
        createTime: number;
        cvm: number;
        diskSize: number;
        diskType: string;
        expireTime: number;
        healthy: number;
        healthyMessage: string;
        instanceId: string;
        instanceName: string;
        instanceType: string;
        isInternal: number;
        maxPartitionNumber: number;
        maxTopicNumber: number;
        partitionNumber: number;
        publicNetwork: number;
        publicNetworkChargeType: string;
        rebalanceTime: string;
        renewFlag: number;
        status: number;
        subnetId: string;
        tags: outputs.Ckafka.GetInstancesInstanceListTag[];
        topicNum: number;
        version: string;
        vip: string;
        vipList: outputs.Ckafka.GetInstancesInstanceListVipList;
        vpcId: string;
        vport: string;
        zoneId: number;
        zoneIds: number[];
    }

    export interface GetInstancesInstanceListTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetInstancesInstanceListVipList {
        vip: string;
        vport: string;
    }

    export interface GetRegionResult {
        areaName: string;
        ipv6: number;
        multiZone: number;
        regionCode: string;
        regionCodeV3: string;
        regionId: number;
        regionName: string;
        support: string;
    }

    export interface GetTaskStatusResult {
        output: string;
        status: number;
    }

    export interface GetTopicFlowRankingResult {
        consumeSpeeds: outputs.Ckafka.GetTopicFlowRankingResultConsumeSpeed[];
        topicFlows: outputs.Ckafka.GetTopicFlowRankingResultTopicFlow[];
        topicMessageHeaps: outputs.Ckafka.GetTopicFlowRankingResultTopicMessageHeap[];
    }

    export interface GetTopicFlowRankingResultConsumeSpeed {
        consumerGroupName: string;
        speed: number;
    }

    export interface GetTopicFlowRankingResultTopicFlow {
        messageHeap: number;
        partitionNum: number;
        replicaNum: number;
        topicId: string;
        topicName: string;
        topicTraffic: string;
    }

    export interface GetTopicFlowRankingResultTopicMessageHeap {
        messageHeap: number;
        partitionNum: number;
        replicaNum: number;
        topicId: string;
        topicName: string;
        topicTraffic: string;
    }

    export interface GetTopicProduceConnectionResult {
        ipAddr: string;
        isUnSupportVersion: boolean;
        time: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfo {
        errorCode: string;
        group: string;
        members: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMember[];
        protocol: string;
        protocolType: string;
        state: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMember {
        assignments: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMemberAssignment[];
        clientHost: string;
        clientId: string;
        memberId: string;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMemberAssignment {
        topics: outputs.Ckafka.GetTopicSubscribeGroupGroupsInfoMemberAssignmentTopic[];
        version: number;
    }

    export interface GetTopicSubscribeGroupGroupsInfoMemberAssignmentTopic {
        partitions: number[];
        topic: string;
    }

    export interface GetTopicSyncReplicaTopicInSyncReplicaList {
        beginOffset: number;
        endOffset: number;
        inSyncReplica: string;
        leader: number;
        messageCount: number;
        outOfSyncReplica: string;
        partition: string;
        replica: string;
    }

    export interface GetTopicsInstanceList {
        cleanUpPolicy: string;
        createTime: string;
        enableWhiteList: boolean;
        forwardCosBucket: string;
        forwardInterval: number;
        forwardStatus: number;
        ipWhiteListCount: number;
        maxMessageBytes: number;
        note: string;
        partitionNum: number;
        replicaNum: number;
        retention: number;
        segment: number;
        segmentBytes: number;
        syncReplicaMinNum: number;
        topicId: string;
        topicName: string;
        uncleanLeaderElectionEnable: boolean;
    }

    export interface GetUsersUserList {
        accountName: string;
        createTime: string;
        updateTime: string;
    }

    export interface GetZoneResult {
        clusterInfos: outputs.Ckafka.GetZoneResultClusterInfo[];
        maxBandwidth: number;
        maxBuyInstanceNum: number;
        messagePrices: outputs.Ckafka.GetZoneResultMessagePrice[];
        physical: string;
        profession: string;
        publicNetwork: string;
        publicNetworkLimit: string;
        standard: string;
        standardS2: string;
        unitPrices: outputs.Ckafka.GetZoneResultUnitPrice[];
        zoneLists: outputs.Ckafka.GetZoneResultZoneList[];
    }

    export interface GetZoneResultClusterInfo {
        availableBandWidth: number;
        availableDiskSize: number;
        clusterId: number;
        clusterName: string;
        maxBandWidth: number;
        maxDiskSize: number;
        zoneId: number;
        zoneIds: number[];
    }

    export interface GetZoneResultMessagePrice {
        realTotalCost: number;
        totalCost: number;
    }

    export interface GetZoneResultUnitPrice {
        realTotalCost: number;
        totalCost: number;
    }

    export interface GetZoneResultZoneList {
        appId: number;
        exflag: string;
        flag: boolean;
        isInternalApp: number;
        salesInfos: outputs.Ckafka.GetZoneResultZoneListSalesInfo[];
        soldOut: string;
        zoneId: string;
        zoneName: string;
        zoneStatus: number;
    }

    export interface GetZoneResultZoneListSalesInfo {
        flag: boolean;
        platform: string;
        soldOut: boolean;
        version: string;
    }

    export interface InstanceConfig {
        autoCreateTopicEnable: boolean;
        defaultNumPartitions: number;
        defaultReplicationFactor: number;
    }

    export interface InstanceDynamicRetentionConfig {
        bottomRetention: number;
        diskQuotaPercentage: number;
        enable: number;
        stepForwardPercentage: number;
    }

    export interface InstanceTag {
        key: string;
        value: string;
    }

    export interface RouteBrokerVipList {
        vip: string;
        vport: string;
    }

    export interface RouteVipList {
        vip: string;
        vport: string;
    }

}

export namespace Clb {
    export interface AttachmentTarget {
        eniIp?: string;
        instanceId?: string;
        port: number;
        weight?: number;
    }

    export interface FunctionTargetsAttachmentFunctionTargets {
        function: outputs.Clb.FunctionTargetsAttachmentFunctionTargetsFunction;
        weight?: number;
    }

    export interface FunctionTargetsAttachmentFunctionTargetsFunction {
        functionName: string;
        functionNamespace: string;
        functionQualifier: string;
        functionQualifierType?: string;
    }

    export interface GetAttachmentsAttachmentList {
        clbId: string;
        listenerId: string;
        protocolType: string;
        ruleId: string;
        targets: outputs.Clb.GetAttachmentsAttachmentListTarget[];
    }

    export interface GetAttachmentsAttachmentListTarget {
        instanceId: string;
        port: number;
        weight: number;
    }

    export interface GetClusterResourcesClusterResourceSet {
        clusterId: string;
        clusterName: string;
        clustersZones: outputs.Clb.GetClusterResourcesClusterResourceSetClustersZone[];
        idle: string;
        isp: string;
        loadBalancerId: string;
        vip: string;
    }

    export interface GetClusterResourcesClusterResourceSetClustersZone {
        masterZones: string[];
        slaveZones: string[];
    }

    export interface GetClusterResourcesFilter {
        name: string;
        values: string[];
    }

    export interface GetCrossTargetsCrossTargetSet {
        eniId: string;
        instanceId: string;
        instanceName: string;
        ip: string;
        localVpcId: string;
        region: string;
        vpcId: string;
        vpcName: string;
    }

    export interface GetCrossTargetsFilter {
        name: string;
        values: string[];
    }

    export interface GetExclusiveClustersClusterSet {
        clusterId: string;
        clusterName: string;
        clusterTag: string;
        clusterType: string;
        clustersVersion: string;
        clustersZones: outputs.Clb.GetExclusiveClustersClusterSetClustersZone[];
        disasterRecoveryType: string;
        httpMaxNewConn: number;
        httpQps: number;
        httpsMaxNewConn: number;
        httpsQps: number;
        idleResourceCount: number;
        isp: string;
        loadBalanceDirectorCount: number;
        maxConn: number;
        maxInFlow: number;
        maxInPkg: number;
        maxNewConn: number;
        maxOutFlow: number;
        maxOutPkg: number;
        network: string;
        resourceCount: number;
        zone: string;
    }

    export interface GetExclusiveClustersClusterSetClustersZone {
        masterZones: string[];
        slaveZones: string[];
    }

    export interface GetExclusiveClustersFilter {
        name: string;
        values: string[];
    }

    export interface GetIdleInstancesIdleLoadBalancer {
        domain: string;
        forward: number;
        idleReason: string;
        loadBalancerId: string;
        loadBalancerName: string;
        region: string;
        status: number;
        vip: string;
    }

    export interface GetInstanceByCertIdCertSet {
        certId: string;
        loadBalancers: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancer[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancer {
        addressIPVersion: string;
        addressIPv6: string;
        anycastZone: string;
        attributeFlags: string[];
        backupZoneSets: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerBackupZoneSet[];
        chargeType: string;
        clusterIds: string[];
        clusterTag: string;
        configId: string;
        createTime: string;
        domain: string;
        exclusiveClusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveCluster[];
        expireTime: string;
        extraInfos: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExtraInfo[];
        forward: number;
        healthLogSetId: string;
        healthLogTopicId: string;
        ipv6Mode: string;
        isBlock: boolean;
        isBlockTime: string;
        isDdos: boolean;
        isolatedTime: string;
        isolation: number;
        loadBalancerDomain: string;
        loadBalancerId: string;
        loadBalancerName: string;
        loadBalancerPassToTarget: boolean;
        loadBalancerType: string;
        loadBalancerVips: string[];
        localBgp: boolean;
        log: string;
        logSetId: string;
        logTopicId: string;
        masterZones: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerMasterZone[];
        mixIpTarget: boolean;
        networkAttributes: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerNetworkAttribute[];
        nfvInfo: string;
        numericalVpcId: number;
        openBgp: number;
        prepaidAttributes: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerPrepaidAttribute[];
        projectId: number;
        secureGroups: string[];
        slaType: string;
        snat: boolean;
        snatIps: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerSnatIp[];
        snatPro: boolean;
        status: number;
        statusTime: string;
        subnetId: string;
        tags: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerTag[];
        targetRegionInfos: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerTargetRegionInfo[];
        vipIsp: string;
        vpcId: string;
        zones: string[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerBackupZoneSet {
        edgeZone: boolean;
        localZone: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
        zoneRegion: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveCluster {
        classicalClusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterClassicalCluster[];
        l4Clusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL4Cluster[];
        l7Clusters: outputs.Clb.GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL7Cluster[];
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterClassicalCluster {
        clusterId: string;
        clusterName: string;
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL4Cluster {
        clusterId: string;
        clusterName: string;
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExclusiveClusterL7Cluster {
        clusterId: string;
        clusterName: string;
        zone: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerExtraInfo {
        tgwGroupName: string;
        zhiTong: boolean;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerMasterZone {
        edgeZone: boolean;
        localZone: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
        zoneRegion: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerNetworkAttribute {
        bandwidthpkgSubType: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerPrepaidAttribute {
        period: number;
        renewFlag: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerSnatIp {
        ip: string;
        subnetId: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetInstanceByCertIdCertSetLoadBalancerTargetRegionInfo {
        region: string;
        vpcId: string;
    }

    export interface GetInstanceDetailFilter {
        name: string;
        values: string[];
    }

    export interface GetInstanceDetailLoadBalancerDetailSet {
        address: string;
        addressIpVersion: string;
        addressIpv6: string;
        addressIsp: string;
        chargeType: string;
        configId: string;
        createTime: string;
        domain: string;
        domains: string;
        extraInfos: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetExtraInfo[];
        ipv6Mode: string;
        isolation: number;
        listenerId: string;
        loadBalancerDomain: string;
        loadBalancerId: string;
        loadBalancerName: string;
        loadBalancerPassToTarget: number;
        loadBalancerType: string;
        locationId: string;
        networkAttributes: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetNetworkAttribute[];
        port: number;
        prepaidAttributes: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetPrepaidAttribute[];
        projectId: number;
        protocol: string;
        securityGroups: string[];
        slaveZones: string[];
        sniSwitch: number;
        status: number;
        tags: outputs.Clb.GetInstanceDetailLoadBalancerDetailSetTag[];
        targetAddress: string;
        targetHealth: string;
        targetId: string;
        targetPort: number;
        targetWeight: number;
        url: string;
        vpcId: string;
        zone: string;
        zones: string[];
    }

    export interface GetInstanceDetailLoadBalancerDetailSetExtraInfo {
        tgwGroupName: string;
        zhiTong: boolean;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetNetworkAttribute {
        bandwidthPkgSubType: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetPrepaidAttribute {
        period: number;
        renewFlag: string;
    }

    export interface GetInstanceDetailLoadBalancerDetailSetTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetInstanceTrafficLoadBalancerTraffic {
        domain: string;
        loadBalancerId: string;
        loadBalancerName: string;
        outBandwidth: number;
        region: string;
        vip: string;
    }

    export interface GetInstancesClbList {
        addressIpVersion: string;
        clbId: string;
        clbName: string;
        clbVips: string[];
        createTime: string;
        internetBandwidthMaxOut: number;
        internetChargeType: string;
        localZone: boolean;
        networkType: string;
        projectId: number;
        securityGroups: string[];
        status: number;
        statusTime: string;
        subnetId: string;
        tags: {[key: string]: any};
        targetRegionInfoRegion: string;
        targetRegionInfoVpcId: string;
        vipIsp: string;
        vpcId: string;
        zone: string;
        zoneId: number;
        zoneName: string;
        zoneRegion: string;
    }

    export interface GetListenerRulesRuleList {
        certificateCaId: string;
        certificateId: string;
        certificateSslMode: string;
        clbId: string;
        domain?: string;
        healthCheckHealthNum: number;
        healthCheckHttpCode: number;
        healthCheckHttpDomain: string;
        healthCheckHttpMethod: string;
        healthCheckHttpPath: string;
        healthCheckIntervalTime: number;
        healthCheckSwitch: boolean;
        healthCheckUnhealthNum: number;
        http2Switch: boolean;
        listenerId: string;
        ruleId: string;
        scheduler: string;
        sessionExpireTime: number;
        url?: string;
    }

    export interface GetListenersByTargetsBackend {
        privateIp: string;
        vpcId: string;
    }

    export interface GetListenersByTargetsLoadBalancer {
        listeners: outputs.Clb.GetListenersByTargetsLoadBalancerListener[];
        loadBalancerId: string;
        region: string;
        vip: string;
    }

    export interface GetListenersByTargetsLoadBalancerListener {
        endPort: number;
        listenerId: string;
        port: number;
        protocol: string;
        rules: outputs.Clb.GetListenersByTargetsLoadBalancerListenerRule[];
        targets: outputs.Clb.GetListenersByTargetsLoadBalancerListenerTarget[];
    }

    export interface GetListenersByTargetsLoadBalancerListenerRule {
        domain: string;
        locationId: string;
        targets: outputs.Clb.GetListenersByTargetsLoadBalancerListenerRuleTarget[];
        url: string;
    }

    export interface GetListenersByTargetsLoadBalancerListenerRuleTarget {
        port: number;
        privateIp: string;
        type: string;
        vpcId: number;
        weight: number;
    }

    export interface GetListenersByTargetsLoadBalancerListenerTarget {
        port: number;
        privateIp: string;
        type: string;
        vpcId: number;
        weight: number;
    }

    export interface GetListenersListenerList {
        certificateCaId: string;
        certificateId: string;
        certificateSslMode: string;
        clbId: string;
        healthCheckContextType: string;
        healthCheckHealthNum: number;
        healthCheckHttpCode: number;
        healthCheckHttpDomain: string;
        healthCheckHttpMethod: string;
        healthCheckHttpPath: string;
        healthCheckHttpVersion: string;
        healthCheckIntervalTime: number;
        healthCheckPort: number;
        healthCheckRecvContext: string;
        healthCheckSendContext: string;
        healthCheckSwitch: boolean;
        healthCheckTimeOut: number;
        healthCheckType: string;
        healthCheckUnhealthNum: number;
        listenerId: string;
        listenerName: string;
        port: number;
        protocol: string;
        scheduler: string;
        sessionExpireTime: number;
        sniSwitch: boolean;
    }

    export interface GetRedirectionsRedirectionList {
        clbId: string;
        sourceListenerId: string;
        sourceRuleId: string;
        targetListenerId: string;
        targetRuleId: string;
    }

    export interface GetResourcesFilter {
        name: string;
        values: string[];
    }

    export interface GetResourcesZoneResourceSet {
        edgeZone: boolean;
        ipVersion: string;
        localZone: boolean;
        masterZone: string;
        resourceSets: outputs.Clb.GetResourcesZoneResourceSetResourceSet[];
        slaveZone: string;
        zoneRegion: string;
        zoneResourceType: string;
    }

    export interface GetResourcesZoneResourceSetResourceSet {
        availabilitySets: outputs.Clb.GetResourcesZoneResourceSetResourceSetAvailabilitySet[];
        isp: string;
        types: string[];
    }

    export interface GetResourcesZoneResourceSetResourceSetAvailabilitySet {
        availability: string;
        type: string;
    }

    export interface GetTargetGroupListFilter {
        name: string;
        values: string[];
    }

    export interface GetTargetGroupListTargetGroupSet {
        associatedRules: outputs.Clb.GetTargetGroupListTargetGroupSetAssociatedRule[];
        createdTime: string;
        port: number;
        targetGroupId: string;
        targetGroupName: string;
        updatedTime: string;
        vpcId: string;
    }

    export interface GetTargetGroupListTargetGroupSetAssociatedRule {
        domain: string;
        listenerId: string;
        listenerName: string;
        loadBalancerId: string;
        loadBalancerName: string;
        locationId: string;
        port: number;
        protocol: string;
        url: string;
    }

    export interface GetTargetGroupsList {
        associatedRuleLists: outputs.Clb.GetTargetGroupsListAssociatedRuleList[];
        createTime: string;
        port: number;
        targetGroupId: string;
        targetGroupInstanceLists: outputs.Clb.GetTargetGroupsListTargetGroupInstanceList[];
        targetGroupName: string;
        updateTime: string;
        vpcId: string;
    }

    export interface GetTargetGroupsListAssociatedRuleList {
        domain: string;
        listenerId: string;
        listenerName: string;
        listenerPort: number;
        loadBalancerId: string;
        loadBalancerName: string;
        locationId: string;
        protocol: string;
        url: string;
    }

    export interface GetTargetGroupsListTargetGroupInstanceList {
        eniId: string;
        instanceId: string;
        instanceName: string;
        privateIpAddresses: any[];
        publicIpAddresses: any[];
        registeredTime: string;
        serverPort: number;
        serverType: string;
        weight: number;
    }

    export interface GetTargetHealthLoadBalancer {
        listeners: outputs.Clb.GetTargetHealthLoadBalancerListener[];
        loadBalancerId: string;
        loadBalancerName: string;
    }

    export interface GetTargetHealthLoadBalancerListener {
        listenerId: string;
        listenerName: string;
        port: number;
        protocol: string;
        rules: outputs.Clb.GetTargetHealthLoadBalancerListenerRule[];
    }

    export interface GetTargetHealthLoadBalancerListenerRule {
        domain: string;
        locationId: string;
        targets: outputs.Clb.GetTargetHealthLoadBalancerListenerRuleTarget[];
        url: string;
    }

    export interface GetTargetHealthLoadBalancerListenerRuleTarget {
        healthStatus: boolean;
        healthStatusDetail: string;
        ip: string;
        port: number;
        targetId: string;
    }

    export interface InstanceSnatIp {
        ip?: string;
        subnetId: string;
    }

    export interface ReplaceCertForLbsCertificate {
        certCaContent?: string;
        certCaId?: string;
        certCaName?: string;
        certContent?: string;
        certId?: string;
        certKey?: string;
        certName?: string;
        sslMode?: string;
    }

    export interface SnatIpIp {
        ip: string;
        subnetId: string;
    }

    export interface TargetGroupTargetGroupInstance {
        bindIp: string;
        newPort?: number;
        port: number;
        weight?: number;
    }

}

export namespace Clickhouse {
    export interface BackupStrategyDataBackupStrategy {
        backUpTables: outputs.Clickhouse.BackupStrategyDataBackupStrategyBackUpTable[];
        executeHour: number;
        retainDays: number;
        weekDays: string;
    }

    export interface BackupStrategyDataBackupStrategyBackUpTable {
        database: string;
        ips: string;
        rip: string;
        table: string;
        totalBytes: number;
        vCluster: string;
        zooPath: string;
    }

    export interface BackupStrategyMetaBackupStrategy {
        executeHour?: number;
        retainDays?: number;
        weekDays?: string;
    }

    export interface GetBackupJobDetailTableContent {
        database: string;
        ips: string;
        rip: string;
        table: string;
        totalBytes: number;
        vCluster: string;
        zooPath: string;
    }

    export interface GetBackupJobsBackUpJob {
        backUpSize: number;
        backUpTime: string;
        backUpType: string;
        expireTime: string;
        jobId: number;
        jobStatus: string;
        snapshot: string;
    }

    export interface InstanceCommonSpec {
        count: number;
        diskSize: number;
        specName: string;
    }

    export interface InstanceDataSpec {
        count: number;
        diskSize: number;
        specName: string;
    }

}

export namespace Cls {
    export interface AlarmAlarmTarget {
        endTimeOffset: number;
        logsetId: string;
        number: number;
        query: string;
        startTimeOffset: number;
        topicId: string;
    }

    export interface AlarmAnalysis {
        configInfos?: outputs.Cls.AlarmAnalysisConfigInfo[];
        content: string;
        name: string;
        type: string;
    }

    export interface AlarmAnalysisConfigInfo {
        key: string;
        value: string;
    }

    export interface AlarmCallBack {
        body: string;
        headers?: string[];
    }

    export interface AlarmMonitorTime {
        time: number;
        type: string;
    }

    export interface AlarmNoticeNoticeReceiver {
        endTime?: string;
        index?: number;
        receiverChannels: string[];
        receiverIds: number[];
        receiverType: string;
        startTime?: string;
    }

    export interface AlarmNoticeWebCallback {
        body?: string;
        callbackType: string;
        headers?: string[];
        index?: number;
        method?: string;
        url: string;
    }

    export interface CkafkaConsumerCkafka {
        instanceId: string;
        instanceName: string;
        topicId: string;
        topicName: string;
        vip: string;
        vport: string;
    }

    export interface CkafkaConsumerContent {
        enableTag: boolean;
        metaFields: string[];
        tagJsonNotTiled?: boolean;
        timestampAccuracy?: number;
    }

    export interface ConfigExcludePath {
        type?: string;
        value?: string;
    }

    export interface ConfigExtraContainerFile {
        container: string;
        excludeLabels?: string[];
        excludeNamespace?: string;
        filePattern: string;
        includeLabels?: string[];
        logPath: string;
        namespace: string;
        workload?: outputs.Cls.ConfigExtraContainerFileWorkload;
    }

    export interface ConfigExtraContainerFileWorkload {
        container?: string;
        kind: string;
        name: string;
        namespace?: string;
    }

    export interface ConfigExtraContainerStdout {
        allContainers: boolean;
        excludeLabels?: string[];
        excludeNamespace?: string;
        includeLabels?: string[];
        namespace?: string;
        workloads?: outputs.Cls.ConfigExtraContainerStdoutWorkload[];
    }

    export interface ConfigExtraContainerStdoutWorkload {
        container?: string;
        kind: string;
        name: string;
        namespace?: string;
    }

    export interface ConfigExtraExcludePath {
        type?: string;
        value?: string;
    }

    export interface ConfigExtraExtractRule {
        backtracking: number;
        beginRegex?: string;
        delimiter?: string;
        filterKeyRegexes?: outputs.Cls.ConfigExtraExtractRuleFilterKeyRegex[];
        keys?: string[];
        logRegex?: string;
        timeFormat?: string;
        timeKey?: string;
        unMatchLogKey?: string;
        unMatchUpLoadSwitch: boolean;
    }

    export interface ConfigExtraExtractRuleFilterKeyRegex {
        key?: string;
        regex?: string;
    }

    export interface ConfigExtraHostFile {
        customLabels?: string[];
        filePattern: string;
        logPath: string;
    }

    export interface ConfigExtractRule {
        address?: string;
        backtracking?: number;
        beginRegex?: string;
        delimiter?: string;
        filterKeyRegexes?: outputs.Cls.ConfigExtractRuleFilterKeyRegex[];
        isGbk?: number;
        jsonStandard?: number;
        keys?: string[];
        logRegex?: string;
        metaTags?: outputs.Cls.ConfigExtractRuleMetaTag[];
        metadataType?: number;
        parseProtocol?: string;
        pathRegex?: string;
        protocol?: string;
        timeFormat?: string;
        timeKey?: string;
        unMatchLogKey?: string;
        unMatchUpLoadSwitch?: boolean;
    }

    export interface ConfigExtractRuleFilterKeyRegex {
        key?: string;
        regex?: string;
    }

    export interface ConfigExtractRuleMetaTag {
        key?: string;
        value?: string;
    }

    export interface CosRechargeExtractRuleInfo {
        address?: string;
        backtracking?: number;
        beginRegex?: string;
        delimiter?: string;
        filterKeyRegexes?: outputs.Cls.CosRechargeExtractRuleInfoFilterKeyRegex[];
        isGbk?: number;
        jsonStandard?: number;
        keys?: string[];
        logRegex?: string;
        metaTags?: outputs.Cls.CosRechargeExtractRuleInfoMetaTag[];
        metadataType?: number;
        parseProtocol?: string;
        pathRegex?: string;
        protocol?: string;
        timeFormat?: string;
        timeKey?: string;
        unMatchLogKey?: string;
        unMatchUpLoadSwitch?: boolean;
    }

    export interface CosRechargeExtractRuleInfoFilterKeyRegex {
        key: string;
        regex: string;
    }

    export interface CosRechargeExtractRuleInfoMetaTag {
        key?: string;
        value?: string;
    }

    export interface CosShipperCompress {
        format: string;
    }

    export interface CosShipperContent {
        csv?: outputs.Cls.CosShipperContentCsv;
        format: string;
        json?: outputs.Cls.CosShipperContentJson;
    }

    export interface CosShipperContentCsv {
        delimiter: string;
        escapeChar: string;
        keys: string[];
        nonExistingField: string;
        printKey: boolean;
    }

    export interface CosShipperContentJson {
        enableTag: boolean;
        metaFields: string[];
    }

    export interface CosShipperFilterRule {
        key: string;
        regex: string;
        value: string;
    }

    export interface DataTransformDstResource {
        alias: string;
        topicId: string;
    }

    export interface GetMachineGroupConfigsConfig {
        configId: string;
        createTime: string;
        excludePaths: outputs.Cls.GetMachineGroupConfigsConfigExcludePath[];
        extractRules: outputs.Cls.GetMachineGroupConfigsConfigExtractRule[];
        logFormat: string;
        logType: string;
        name: string;
        output: string;
        path: string;
        updateTime: string;
        userDefineRule: string;
    }

    export interface GetMachineGroupConfigsConfigExcludePath {
        type: string;
        value: string;
    }

    export interface GetMachineGroupConfigsConfigExtractRule {
        address: string;
        backtracking: number;
        beginRegex: string;
        delimiter: string;
        filterKeyRegexes: outputs.Cls.GetMachineGroupConfigsConfigExtractRuleFilterKeyRegex[];
        isGbk: number;
        jsonStandard: number;
        keys: string[];
        logRegex: string;
        metaTags: outputs.Cls.GetMachineGroupConfigsConfigExtractRuleMetaTag[];
        metadataType: number;
        parseProtocol: string;
        pathRegex: string;
        protocol: string;
        timeFormat: string;
        timeKey: string;
        unMatchLogKey: string;
        unMatchUpLoadSwitch: boolean;
    }

    export interface GetMachineGroupConfigsConfigExtractRuleFilterKeyRegex {
        key: string;
        regex: string;
    }

    export interface GetMachineGroupConfigsConfigExtractRuleMetaTag {
        key: string;
        value: string;
    }

    export interface GetMachinesMachine {
        autoUpdate: number;
        errCode: number;
        errMsg: string;
        ip: string;
        offlineTime: string;
        status: number;
        updateStatus: number;
        version: string;
    }

    export interface GetShipperTasksTask {
        endTime: number;
        message: string;
        rangeEnd: number;
        rangeStart: number;
        shipperId: string;
        startTime: number;
        status: string;
        taskId: string;
        topicId: string;
    }

    export interface IndexRule {
        fullText?: outputs.Cls.IndexRuleFullText;
        keyValue?: outputs.Cls.IndexRuleKeyValue;
        tag?: outputs.Cls.IndexRuleTag;
    }

    export interface IndexRuleFullText {
        caseSensitive: boolean;
        containZH: boolean;
        tokenizer: string;
    }

    export interface IndexRuleKeyValue {
        caseSensitive: boolean;
        keyValues?: outputs.Cls.IndexRuleKeyValueKeyValue[];
    }

    export interface IndexRuleKeyValueKeyValue {
        key: string;
        value?: outputs.Cls.IndexRuleKeyValueKeyValueValue;
    }

    export interface IndexRuleKeyValueKeyValueValue {
        containZH?: boolean;
        sqlFlag?: boolean;
        tokenizer?: string;
        type: string;
    }

    export interface IndexRuleTag {
        caseSensitive: boolean;
        keyValues?: outputs.Cls.IndexRuleTagKeyValue[];
    }

    export interface IndexRuleTagKeyValue {
        key: string;
        value?: outputs.Cls.IndexRuleTagKeyValueValue;
    }

    export interface IndexRuleTagKeyValueValue {
        containZH?: boolean;
        sqlFlag?: boolean;
        tokenizer?: string;
        type: string;
    }

    export interface KafkaRechargeLogRechargeRule {
        defaultTimeSrc?: number;
        defaultTimeSwitch: boolean;
        encodingFormat: number;
        keys: string[];
        logRegex?: string;
        metadatas: string[];
        rechargeType: string;
        timeFormat?: string;
        timeKey?: string;
        timeRegex?: string;
        timeZone?: string;
        unMatchLogKey?: string;
        unMatchLogSwitch?: boolean;
        unMatchLogTimeSrc?: number;
    }

    export interface KafkaRechargeProtocol {
        mechanism?: string;
        password?: string;
        protocol?: string;
        userName?: string;
    }

    export interface MachineGroupMachineGroupType {
        type: string;
        values: string[];
    }

    export interface ScheduledSqlDstResource {
        bizType?: number;
        metricName?: string;
        region?: string;
        topicId: string;
    }

}

export namespace Cos {
    export interface BatchManifest {
        location: outputs.Cos.BatchManifestLocation;
        spec: outputs.Cos.BatchManifestSpec;
    }

    export interface BatchManifestLocation {
        etag: string;
        objectArn: string;
        objectVersionId?: string;
    }

    export interface BatchManifestSpec {
        fields?: string[];
        format: string;
    }

    export interface BatchOperation {
        cosInitiateRestoreObject?: outputs.Cos.BatchOperationCosInitiateRestoreObject;
        cosPutObjectCopy?: outputs.Cos.BatchOperationCosPutObjectCopy;
    }

    export interface BatchOperationCosInitiateRestoreObject {
        expirationInDays: number;
        jobTier: string;
    }

    export interface BatchOperationCosPutObjectCopy {
        accessControlDirective?: string;
        accessControlGrants?: outputs.Cos.BatchOperationCosPutObjectCopyAccessControlGrants;
        cannedAccessControlList?: string;
        metadataDirective?: string;
        modifiedSinceConstraint?: number;
        newObjectMetadata?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectMetadata;
        newObjectTaggings?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectTagging[];
        prefixReplace?: boolean;
        resourcesPrefix?: string;
        storageClass?: string;
        taggingDirective?: string;
        targetKeyPrefix?: string;
        targetResource: string;
        unmodifiedSinceConstraint?: number;
    }

    export interface BatchOperationCosPutObjectCopyAccessControlGrants {
        displayName?: string;
        identifier: string;
        permission: string;
        typeIdentifier: string;
    }

    export interface BatchOperationCosPutObjectCopyNewObjectMetadata {
        cacheControl?: string;
        contentDisposition?: string;
        contentEncoding?: string;
        contentType?: string;
        httpExpiresDate?: string;
        sseAlgorithm?: string;
        userMetadatas?: outputs.Cos.BatchOperationCosPutObjectCopyNewObjectMetadataUserMetadata[];
    }

    export interface BatchOperationCosPutObjectCopyNewObjectMetadataUserMetadata {
        key: string;
        value: string;
    }

    export interface BatchOperationCosPutObjectCopyNewObjectTagging {
        key: string;
        value: string;
    }

    export interface BatchReport {
        bucket: string;
        enabled: string;
        format: string;
        prefix?: string;
        reportScope: string;
    }

    export interface BucketCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders?: string[];
        maxAgeSeconds?: number;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificate {
        certificate: outputs.Cos.BucketDomainCertificateAttachmentDomainCertificateCertificate;
        domain: string;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificateCertificate {
        certType: string;
        customCert: outputs.Cos.BucketDomainCertificateAttachmentDomainCertificateCertificateCustomCert;
    }

    export interface BucketDomainCertificateAttachmentDomainCertificateCertificateCustomCert {
        cert: string;
        privateKey: string;
    }

    export interface BucketInventoryDestination {
        accountId?: string;
        bucket: string;
        encryption?: outputs.Cos.BucketInventoryDestinationEncryption;
        format: string;
        prefix?: string;
    }

    export interface BucketInventoryDestinationEncryption {
        sseCos?: string;
    }

    export interface BucketInventoryFilter {
        period?: outputs.Cos.BucketInventoryFilterPeriod;
        prefix?: string;
    }

    export interface BucketInventoryFilterPeriod {
        endTime?: string;
        startTime?: string;
    }

    export interface BucketInventoryOptionalFields {
        fields?: string[];
    }

    export interface BucketInventorySchedule {
        frequency: string;
    }

    export interface BucketLifecycleRule {
        expiration?: outputs.Cos.BucketLifecycleRuleExpiration;
        filterPrefix: string;
        id?: string;
        nonCurrentExpiration?: outputs.Cos.BucketLifecycleRuleNonCurrentExpiration;
        nonCurrentTransitions?: outputs.Cos.BucketLifecycleRuleNonCurrentTransition[];
        transitions?: outputs.Cos.BucketLifecycleRuleTransition[];
    }

    export interface BucketLifecycleRuleExpiration {
        date?: string;
        days?: number;
        deleteMarker?: boolean;
    }

    export interface BucketLifecycleRuleNonCurrentExpiration {
        nonCurrentDays?: number;
    }

    export interface BucketLifecycleRuleNonCurrentTransition {
        nonCurrentDays?: number;
        storageClass: string;
    }

    export interface BucketLifecycleRuleTransition {
        date?: string;
        days?: number;
        storageClass: string;
    }

    export interface BucketOriginDomainRule {
        domain: string;
        status?: string;
        type?: string;
    }

    export interface BucketOriginPullRule {
        customHttpHeaders?: {[key: string]: any};
        followHttpHeaders?: string[];
        followQueryString?: boolean;
        followRedirection?: boolean;
        host: string;
        prefix?: string;
        priority: number;
        protocol?: string;
        syncBackToSource?: boolean;
    }

    export interface BucketReplicaRule {
        destinationBucket: string;
        destinationStorageClass?: string;
        id?: string;
        prefix?: string;
        status: string;
    }

    export interface BucketWebsite {
        endpoint: string;
        errorDocument?: string;
        indexDocument?: string;
    }

    export interface GetBatchsJob {
        creationTime: string;
        description: string;
        jobId: string;
        operation: string;
        priority: number;
        progressSummaries: outputs.Cos.GetBatchsJobProgressSummary[];
        status: string;
        terminationDate: string;
    }

    export interface GetBatchsJobProgressSummary {
        numberOfTasksFailed: number;
        numberOfTasksSucceeded: number;
        totalNumberOfTasks: number;
    }

    export interface GetBucketInventorysInventory {
        destinations: outputs.Cos.GetBucketInventorysInventoryDestination[];
        filters: outputs.Cos.GetBucketInventorysInventoryFilter[];
        id: string;
        includedObjectVersions: string;
        isEnabled: string;
        optionalFields?: outputs.Cos.GetBucketInventorysInventoryOptionalField[];
        schedules: outputs.Cos.GetBucketInventorysInventorySchedule[];
    }

    export interface GetBucketInventorysInventoryDestination {
        accountId: string;
        bucket: string;
        encryptions: outputs.Cos.GetBucketInventorysInventoryDestinationEncryption[];
        format: string;
        prefix: string;
    }

    export interface GetBucketInventorysInventoryDestinationEncryption {
        sseCos: string;
    }

    export interface GetBucketInventorysInventoryFilter {
        periods: outputs.Cos.GetBucketInventorysInventoryFilterPeriod[];
        prefix: string;
    }

    export interface GetBucketInventorysInventoryFilterPeriod {
        endTime: string;
        startTime: string;
    }

    export interface GetBucketInventorysInventoryOptionalField {
        fields: string[];
    }

    export interface GetBucketInventorysInventorySchedule {
        frequency: string;
    }

    export interface GetBucketMultipartUploadsUpload {
        initiated: string;
        initiators: outputs.Cos.GetBucketMultipartUploadsUploadInitiator[];
        key: string;
        owners: outputs.Cos.GetBucketMultipartUploadsUploadOwner[];
        storageClass: string;
        uploadId: string;
    }

    export interface GetBucketMultipartUploadsUploadInitiator {
        displayName: string;
        id: string;
    }

    export interface GetBucketMultipartUploadsUploadOwner {
        displayName: string;
        id: string;
    }

    export interface GetBucketsBucketList {
        acl: string;
        aclBody: string;
        bucket: string;
        corsRules: outputs.Cos.GetBucketsBucketListCorsRule[];
        cosBucketUrl: string;
        lifecycleRules: outputs.Cos.GetBucketsBucketListLifecycleRule[];
        originDomainRules: outputs.Cos.GetBucketsBucketListOriginDomainRule[];
        originPullRules: outputs.Cos.GetBucketsBucketListOriginPullRule[];
        tags: {[key: string]: any};
        websites: outputs.Cos.GetBucketsBucketListWebsite[];
    }

    export interface GetBucketsBucketListCorsRule {
        allowedHeaders: string[];
        allowedMethods: string[];
        allowedOrigins: string[];
        exposeHeaders: string[];
        maxAgeSeconds: number;
    }

    export interface GetBucketsBucketListLifecycleRule {
        expirations: outputs.Cos.GetBucketsBucketListLifecycleRuleExpiration[];
        filterPrefix: string;
        nonCurrentExpirations: outputs.Cos.GetBucketsBucketListLifecycleRuleNonCurrentExpiration[];
        nonCurrentTransitions: outputs.Cos.GetBucketsBucketListLifecycleRuleNonCurrentTransition[];
        transitions: outputs.Cos.GetBucketsBucketListLifecycleRuleTransition[];
    }

    export interface GetBucketsBucketListLifecycleRuleExpiration {
        date: string;
        days: number;
    }

    export interface GetBucketsBucketListLifecycleRuleNonCurrentExpiration {
        nonCurrentDays: number;
    }

    export interface GetBucketsBucketListLifecycleRuleNonCurrentTransition {
        nonCurrentDays: number;
        storageClass: string;
    }

    export interface GetBucketsBucketListLifecycleRuleTransition {
        date: string;
        days: number;
        storageClass: string;
    }

    export interface GetBucketsBucketListOriginDomainRule {
        domain: string;
        status?: string;
        type?: string;
    }

    export interface GetBucketsBucketListOriginPullRule {
        customHttpHeaders?: {[key: string]: any};
        followHttpHeaders?: string[];
        followQueryString?: boolean;
        followRedirection?: boolean;
        host: string;
        prefix?: string;
        priority: number;
        protocol?: string;
        syncBackToSource?: boolean;
    }

    export interface GetBucketsBucketListWebsite {
        errorDocument: string;
        indexDocument: string;
    }

}

export namespace Css {
    export interface GetDomainsDomainList {
        bCName: number;
        createTime: string;
        currentCName: string;
        isDelayLive: number;
        isMiniProgramLive: number;
        name: string;
        playType: number;
        rentExpireTime: string;
        rentTag: number;
        status: number;
        targetDomain: string;
        type: number;
    }

    export interface PlayDomainCertAttachmentDomainInfo {
        domainName: string;
        status: number;
    }

    export interface PullStreamTaskWatermarkList {
        height: number;
        location: number;
        pictureUrl: string;
        width: number;
        xPosition: number;
        yPosition: number;
    }

}

export namespace Cvm {
    export interface ChcConfigBmcVirtualPrivateCloud {
        asVpcGateway?: boolean;
        ipv6AddressCount: number;
        privateIpAddresses: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface ChcConfigDeployVirtualPrivateCloud {
        asVpcGateway?: boolean;
        ipv6AddressCount: number;
        privateIpAddresses: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface GetChcDeniedActionsChcHostDeniedActionSet {
        chcId: string;
        denyActions: string[];
        state: string;
    }

    export interface GetChcHostsChcHostSet {
        bmcIp: string;
        bmcMac: string;
        bmcSecurityGroupIds: string[];
        bmcVirtualPrivateClouds: outputs.Cvm.GetChcHostsChcHostSetBmcVirtualPrivateCloud[];
        chcId: string;
        cpu: number;
        createdTime: string;
        cvmInstanceId: string;
        deployIp: string;
        deployMac: string;
        deploySecurityGroupIds: string[];
        deployVirtualPrivateClouds: outputs.Cvm.GetChcHostsChcHostSetDeployVirtualPrivateCloud[];
        deviceType: string;
        disk: string;
        hardwareDescription: string;
        instanceName: string;
        instanceState: string;
        memory: number;
        placements: outputs.Cvm.GetChcHostsChcHostSetPlacement[];
        serialNumber: string;
        tenantType: string;
    }

    export interface GetChcHostsChcHostSetBmcVirtualPrivateCloud {
        asVpcGateway: boolean;
        ipv6AddressCount: number;
        privateIpAddresses: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface GetChcHostsChcHostSetDeployVirtualPrivateCloud {
        asVpcGateway: boolean;
        ipv6AddressCount: number;
        privateIpAddresses: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface GetChcHostsChcHostSetPlacement {
        hostId: string;
        hostIds: string[];
        hostIps: string[];
        projectId: number;
        zone: string;
    }

    export interface GetChcHostsFilter {
        name: string;
        values: string[];
    }

    export interface GetImageSharePermissionSharePermissionSet {
        accountId: string;
        createdTime: string;
    }

    export interface GetImportImageOsImportImageOsListSupported {
        linuxes: string[];
        windows: string[];
    }

    export interface GetImportImageOsImportImageOsVersionSet {
        architectures: string[];
        osName: string;
        osVersions: string[];
    }

    export interface GetInstancesModificationFilter {
        name: string;
        values: string[];
    }

    export interface GetInstancesModificationInstanceTypeConfigStatusList {
        instanceTypeConfigs: outputs.Cvm.GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfig[];
        message: string;
        status: string;
    }

    export interface GetInstancesModificationInstanceTypeConfigStatusListInstanceTypeConfig {
        cpu: number;
        fpga: number;
        gpu: number;
        instanceFamily: string;
        instanceType: string;
        memory: number;
        zone: string;
    }

    export interface ImportImageTagSpecification {
        resourceType: string;
        tags: outputs.Cvm.ImportImageTagSpecificationTag[];
    }

    export interface ImportImageTagSpecificationTag {
        key: string;
        value: string;
    }

    export interface LaunchTemplateActionTimer {
        actionTime?: string;
        externals?: outputs.Cvm.LaunchTemplateActionTimerExternals;
        timerAction?: string;
    }

    export interface LaunchTemplateActionTimerExternals {
        releaseAddress?: boolean;
        storageBlockAttr?: outputs.Cvm.LaunchTemplateActionTimerExternalsStorageBlockAttr;
        unsupportNetworks?: string[];
    }

    export interface LaunchTemplateActionTimerExternalsStorageBlockAttr {
        maxSize: number;
        minSize: number;
        type: string;
    }

    export interface LaunchTemplateDataDisk {
        cdcId?: string;
        deleteWithInstance?: boolean;
        diskId?: string;
        diskSize: number;
        diskType?: string;
        encrypt?: boolean;
        kmsKeyId?: string;
        snapshotId?: string;
        throughputPerformance?: number;
    }

    export interface LaunchTemplateEnhancedService {
        automationService?: outputs.Cvm.LaunchTemplateEnhancedServiceAutomationService;
        monitorService?: outputs.Cvm.LaunchTemplateEnhancedServiceMonitorService;
        securityService?: outputs.Cvm.LaunchTemplateEnhancedServiceSecurityService;
    }

    export interface LaunchTemplateEnhancedServiceAutomationService {
        enabled?: boolean;
    }

    export interface LaunchTemplateEnhancedServiceMonitorService {
        enabled?: boolean;
    }

    export interface LaunchTemplateEnhancedServiceSecurityService {
        enabled?: boolean;
    }

    export interface LaunchTemplateInstanceChargePrepaid {
        period: number;
        renewFlag?: string;
    }

    export interface LaunchTemplateInstanceMarketOptions {
        marketType?: string;
        spotOptions: outputs.Cvm.LaunchTemplateInstanceMarketOptionsSpotOptions;
    }

    export interface LaunchTemplateInstanceMarketOptionsSpotOptions {
        maxPrice: string;
        spotInstanceType?: string;
    }

    export interface LaunchTemplateInternetAccessible {
        bandwidthPackageId?: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        publicIpAssigned?: boolean;
    }

    export interface LaunchTemplateLoginSettings {
        keepImageLogin?: string;
        keyIds?: string[];
        password?: string;
    }

    export interface LaunchTemplatePlacement {
        hostIds?: string[];
        hostIps?: string[];
        projectId?: number;
        zone: string;
    }

    export interface LaunchTemplateSystemDisk {
        cdcId?: string;
        diskId?: string;
        diskSize?: number;
        diskType?: string;
    }

    export interface LaunchTemplateTagSpecification {
        resourceType: string;
        tags: outputs.Cvm.LaunchTemplateTagSpecificationTag[];
    }

    export interface LaunchTemplateTagSpecificationTag {
        key: string;
        value: string;
    }

    export interface LaunchTemplateVersionActionTimer {
        actionTime: string;
        externals: outputs.Cvm.LaunchTemplateVersionActionTimerExternals;
        timerAction: string;
    }

    export interface LaunchTemplateVersionActionTimerExternals {
        releaseAddress: boolean;
        storageBlockAttr: outputs.Cvm.LaunchTemplateVersionActionTimerExternalsStorageBlockAttr;
        unsupportNetworks: string[];
    }

    export interface LaunchTemplateVersionActionTimerExternalsStorageBlockAttr {
        maxSize: number;
        minSize: number;
        type: string;
    }

    export interface LaunchTemplateVersionDataDisk {
        cdcId: string;
        deleteWithInstance: boolean;
        diskId: string;
        diskSize: number;
        diskType: string;
        encrypt: boolean;
        kmsKeyId: string;
        snapshotId: string;
        throughputPerformance: number;
    }

    export interface LaunchTemplateVersionEnhancedService {
        automationService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceAutomationService;
        monitorService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceMonitorService;
        securityService: outputs.Cvm.LaunchTemplateVersionEnhancedServiceSecurityService;
    }

    export interface LaunchTemplateVersionEnhancedServiceAutomationService {
        enabled: boolean;
    }

    export interface LaunchTemplateVersionEnhancedServiceMonitorService {
        enabled: boolean;
    }

    export interface LaunchTemplateVersionEnhancedServiceSecurityService {
        enabled: boolean;
    }

    export interface LaunchTemplateVersionInstanceChargePrepaid {
        period: number;
        renewFlag: string;
    }

    export interface LaunchTemplateVersionInstanceMarketOptions {
        marketType: string;
        spotOptions: outputs.Cvm.LaunchTemplateVersionInstanceMarketOptionsSpotOptions;
    }

    export interface LaunchTemplateVersionInstanceMarketOptionsSpotOptions {
        maxPrice: string;
        spotInstanceType: string;
    }

    export interface LaunchTemplateVersionInternetAccessible {
        bandwidthPackageId: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        publicIpAssigned: boolean;
    }

    export interface LaunchTemplateVersionLoginSettings {
        keepImageLogin: string;
        keyIds: string[];
        password: string;
    }

    export interface LaunchTemplateVersionPlacement {
        hostIds: string[];
        hostIps: string[];
        projectId: number;
        zone: string;
    }

    export interface LaunchTemplateVersionSystemDisk {
        cdcId: string;
        diskId: string;
        diskSize: number;
        diskType: string;
    }

    export interface LaunchTemplateVersionTagSpecification {
        resourceType: string;
        tags: outputs.Cvm.LaunchTemplateVersionTagSpecificationTag[];
    }

    export interface LaunchTemplateVersionTagSpecificationTag {
        key: string;
        value: string;
    }

    export interface LaunchTemplateVersionVirtualPrivateCloud {
        asVpcGateway: boolean;
        ipv6AddressCount: number;
        privateIpAddresses: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface LaunchTemplateVirtualPrivateCloud {
        asVpcGateway?: boolean;
        ipv6AddressCount?: number;
        privateIpAddresses?: string[];
        subnetId: string;
        vpcId: string;
    }

    export interface ModifyInstanceDiskTypeDataDisk {
        cdcId?: string;
        deleteWithInstance?: boolean;
        diskId?: string;
        diskSize: number;
        diskType?: string;
        encrypt?: boolean;
        kmsKeyId?: string;
        snapshotId?: string;
        throughputPerformance?: number;
    }

    export interface ModifyInstanceDiskTypeSystemDisk {
        cdcId?: string;
        diskId?: string;
        diskSize?: number;
        diskType?: string;
    }

    export interface RenewHostHostChargePrepaid {
        period: number;
        renewFlag?: string;
    }

    export interface RenewInstanceInstanceChargePrepaid {
        period: number;
        renewFlag?: string;
    }

}

export namespace Cynosdb {
    export interface AccountPrivilegesDatabasePrivilege {
        db: string;
        privileges: string[];
    }

    export interface AccountPrivilegesTablePrivilege {
        db: string;
        privileges: string[];
        tableName: string;
    }

    export interface AuditLogFileFilter {
        affectRows?: number;
        dbNames?: string[];
        execTime?: number;
        hosts?: string[];
        policyNames?: string[];
        sentRows?: number;
        sql?: string;
        sqlType?: string;
        sqlTypes?: string[];
        sqls?: string[];
        tableNames?: string[];
        threadIds?: string[];
        users?: string[];
    }

    export interface ClusterDatabasesUserHostPrivilege {
        dbHost: string;
        dbPrivilege: string;
        dbUserName: string;
    }

    export interface ClusterParamItem {
        currentValue: string;
        name: string;
        oldValue?: string;
    }

    export interface ClusterRoGroupAddr {
        ip: string;
        port: number;
    }

    export interface ClusterRoGroupInstance {
        instanceId: string;
        instanceName: string;
    }

    export interface ClusterRwGroupAddr {
        ip: string;
        port: number;
    }

    export interface ClusterRwGroupInstance {
        instanceId: string;
        instanceName: string;
    }

    export interface ExportInstanceErrorLogsErrorLogItemExport {
        content: string;
        level: string;
        timestamp: string;
    }

    export interface GetAccountAllGrantPrivilegesAccount {
        accountName: string;
        host?: string;
    }

    export interface GetAccountAllGrantPrivilegesDatabasePrivilege {
        db: string;
        privileges: string[];
    }

    export interface GetAccountAllGrantPrivilegesTablePrivilege {
        db: string;
        privileges: string[];
        tableName: string;
    }

    export interface GetAccountsAccountSet {
        accountName: string;
        createTime: string;
        description: string;
        host: string;
        maxUserConnections: number;
        updateTime: string;
    }

    export interface GetAuditLogsFilter {
        affectRows?: number;
        dbNames?: string[];
        execTime?: number;
        hosts?: string[];
        policyNames?: string[];
        sentRows?: number;
        sql?: string;
        sqlType?: string;
        sqlTypes?: string[];
        sqls?: string[];
        tableNames?: string[];
        threadIds?: string[];
        users?: string[];
    }

    export interface GetAuditLogsItem {
        affectRows: number;
        dbName: string;
        errCode: number;
        execTime: number;
        host: string;
        instanceName: string;
        policyName: string;
        sentRows: number;
        sql: string;
        sqlType: string;
        tableName: string;
        threadId: number;
        timestamp: string;
        user: string;
    }

    export interface GetClusterDetailDatabasesDbInfo {
        appId: number;
        characterSet: string;
        clusterId: string;
        collateRule: string;
        createTime: string;
        dbId: number;
        dbName: string;
        description: string;
        status: string;
        uin: string;
        updateTime: string;
        userHostPrivileges: outputs.Cynosdb.GetClusterDetailDatabasesDbInfoUserHostPrivilege[];
    }

    export interface GetClusterDetailDatabasesDbInfoUserHostPrivilege {
        dbHost: string;
        dbPrivilege: string;
        dbUserName: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoList {
        appId: number;
        clusterId: string;
        createdTime: string;
        deletedTime: string;
        instanceGrpId: string;
        instanceSets: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSet[];
        status: string;
        type: string;
        updatedTime: string;
        vip: string;
        vport: number;
        wanDomain: string;
        wanIp: string;
        wanPort: number;
        wanStatus: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSet {
        appId: number;
        businessType: string;
        clusterId: string;
        clusterName: string;
        cpu: number;
        createTime: string;
        cynosVersion: string;
        dbType: string;
        dbVersion: string;
        destroyDeadlineText: string;
        destroyTime: string;
        instanceId: string;
        instanceName: string;
        instanceRole: string;
        instanceType: string;
        isFreeze: string;
        isolateTime: string;
        maxCpu: number;
        memory: number;
        minCpu: number;
        netType: number;
        payMode: number;
        periodEndTime: string;
        physicalZone: string;
        processingTask: string;
        projectId: number;
        region: string;
        renewFlag: number;
        resourceTags: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetResourceTag[];
        serverlessStatus: string;
        status: string;
        statusDesc: string;
        storage: number;
        storageId: string;
        storagePayMode: number;
        subnetId: string;
        tasks: outputs.Cynosdb.GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetTask[];
        uin: string;
        updateTime: string;
        vip: string;
        vpcId: string;
        vport: number;
        wanDomain: string;
        wanIp: string;
        wanPort: number;
        wanStatus: string;
        zone: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetResourceTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetClusterInstanceGroupsInstanceGrpInfoListInstanceSetTask {
        objectId: string;
        objectType: string;
        taskId: number;
        taskStatus: string;
        taskType: string;
    }

    export interface GetClusterParamLogsClusterParamLog {
        clusterId: string;
        createTime: string;
        currentValue: string;
        instanceId: string;
        paramName: string;
        status: string;
        updateTime: string;
        updateValue: string;
    }

    export interface GetClusterParamsItem {
        currentValue: string;
        default: string;
        description: string;
        enumValues: string[];
        func: string;
        isFunc: boolean;
        isGlobal: number;
        matchType: string;
        matchValue: string;
        max: string;
        min: string;
        needReboot: number;
        paramName: string;
        paramType: string;
    }

    export interface GetClusterTable {
        database: string;
        tables: string[];
    }

    export interface GetClustersClusterList {
        autoRenewFlag: number;
        availableZone: string;
        chargeType: string;
        clusterId: string;
        clusterLimit: number;
        clusterName: string;
        clusterStatus: string;
        createTime: string;
        dbType: string;
        dbVersion: string;
        port: number;
        projectId: number;
        subnetId: string;
        vpcId: string;
    }

    export interface GetDescribeInstanceErrorLogsErrorLog {
        content: string;
        level: string;
        timestamp: number;
    }

    export interface GetDescribeInstanceSlowQueriesBinlog {
        binlogId: number;
        fileName: string;
        fileSize: number;
        finishTime: string;
        startTime: string;
    }

    export interface GetInstanceSlowQueriesSlowQuery {
        database: string;
        lockTime: number;
        queryTime: number;
        rowsExamined: number;
        rowsSent: number;
        sqlMd5: string;
        sqlTemplate: string;
        sqlText: string;
        timestamp: number;
        userHost: string;
        userName: string;
    }

    export interface GetInstancesInstanceList {
        clusterId?: string;
        createTime: string;
        instanceCpuCore: number;
        instanceId?: string;
        instanceMemorySize: number;
        instanceName: string;
        instanceStatus: string;
        instanceStorageSize: number;
        instanceType: string;
    }

    export interface GetParamTemplatesItem {
        dbMode: string;
        engineVersion: string;
        id: number;
        paramInfoSets: outputs.Cynosdb.GetParamTemplatesItemParamInfoSet[];
        templateDescription: string;
        templateName: string;
    }

    export interface GetParamTemplatesItemParamInfoSet {
        currentValue: string;
        default: string;
        description: string;
        enumValues: string[];
        max: string;
        min: string;
        needReboot: number;
        paramName: string;
        paramType: string;
    }

    export interface GetProjectSecurityGroupsGroup {
        createTime: string;
        inbounds: outputs.Cynosdb.GetProjectSecurityGroupsGroupInbound[];
        outbounds: outputs.Cynosdb.GetProjectSecurityGroupsGroupOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        action: string;
        addressModule: string;
        cidrIp: string;
        desc: string;
        id: string;
        ipProtocol: string;
        portRange: string;
        serviceModule: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        action: string;
        addressModule: string;
        cidrIp: string;
        desc: string;
        id: string;
        ipProtocol: string;
        portRange: string;
        serviceModule: string;
    }

    export interface GetProxyNodeFilter {
        exactMatch?: boolean;
        name?: string;
        names: string[];
        operator?: string;
        values: string[];
    }

    export interface GetProxyNodeProxyNodeInfo {
        appId: number;
        clusterId: string;
        cpu: number;
        mem: number;
        proxyGroupId: string;
        proxyNodeConnections: number;
        proxyNodeId: string;
        region: string;
        status: string;
        zone: string;
    }

    export interface GetResourcePackageListResourcePackageList {
        appId: number;
        bindInstanceInfos: outputs.Cynosdb.GetResourcePackageListResourcePackageListBindInstanceInfo[];
        expireTime: string;
        hasQuota: boolean;
        packageId: string;
        packageName: string;
        packageRegion: string;
        packageTotalSpec: number;
        packageType: string;
        packageUsedSpec: number;
        startTime: string;
        status: string;
    }

    export interface GetResourcePackageListResourcePackageListBindInstanceInfo {
        instanceId: string;
        instanceRegion: string;
        instanceType: string;
    }

    export interface GetResourcePackageSaleSpecsDetail {
        expireDay: number;
        maxPackageSpec: number;
        minPackageSpec: number;
        packageRegion: string;
        packageType: string;
        packageVersion: string;
    }

    export interface GetRollbackTimeRangeRollbackTimeRange {
        timeRangeEnd: string;
        timeRangeStart: string;
    }

    export interface GetZoneConfigList {
        cpu: number;
        machineType: string;
        maxIoBandwidth: number;
        maxStorageSize: number;
        memory: number;
        minStorageSize: number;
        zoneStockInfos: outputs.Cynosdb.GetZoneConfigListZoneStockInfo[];
    }

    export interface GetZoneConfigListZoneStockInfo {
        hasStock: boolean;
        zone: string;
    }

    export interface GetZoneRegionSet {
        dbType: string;
        modules: outputs.Cynosdb.GetZoneRegionSetModule[];
        region: string;
        regionId: number;
        regionZh: string;
        zoneSets: outputs.Cynosdb.GetZoneRegionSetZoneSet[];
    }

    export interface GetZoneRegionSetModule {
        isDisable: string;
        moduleName: string;
    }

    export interface GetZoneRegionSetZoneSet {
        hasPermission: boolean;
        isSupportNormal: number;
        isSupportServerless: number;
        isWholeRdmaZone: string;
        physicalZone: string;
        zone: string;
        zoneId: number;
        zoneZh: string;
    }

    export interface InstanceParamInstanceParamList {
        currentValue: string;
        paramName: string;
    }

    export interface ParamTemplateParamList {
        currentValue: string;
        paramName: string;
    }

    export interface ProxyEndPointInstanceWeight {
        instanceId: string;
        weight: number;
    }

    export interface ProxyProxyZone {
        proxyNodeCount?: number;
        proxyNodeZone?: string;
    }

    export interface ProxyRoInstance {
        instanceId?: string;
        weight?: number;
    }

    export interface RollBackClusterRollbackDatabase {
        newDatabase: string;
        oldDatabase: string;
    }

    export interface RollBackClusterRollbackTable {
        database: string;
        tables: outputs.Cynosdb.RollBackClusterRollbackTableTable[];
    }

    export interface RollBackClusterRollbackTableTable {
        newTable: string;
        oldTable: string;
    }

}

export namespace Dayu {
    export interface CcHttpPolicyRuleList {
        operator?: string;
        skey?: string;
        value?: string;
    }

    export interface CcHttpsPolicyRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface CcPolicyV2CcBlackWhiteIp {
        blackWhiteIp: string;
        createTime: string;
        domain: string;
        modifyTime: string;
        protocol: string;
        type: string;
    }

    export interface CcPolicyV2CcGeoIpPolicy {
        action: string;
        areaLists: number[];
        createTime: string;
        domain: string;
        modifyTime: string;
        protocol: string;
        regionType: string;
    }

    export interface CcPolicyV2CcPrecisionPolicy {
        domain: string;
        ip: string;
        policyAction: string;
        policyId: string;
        policys: outputs.Dayu.CcPolicyV2CcPrecisionPolicyPolicy[];
        protocol: string;
    }

    export interface CcPolicyV2CcPrecisionPolicyPolicy {
        fieldName: string;
        fieldType: string;
        value: string;
        valueOperator: string;
    }

    export interface CcPolicyV2CcPrecisionReqLimit {
        domain: string;
        instanceId: string;
        ip: string;
        level: string;
        policys: outputs.Dayu.CcPolicyV2CcPrecisionReqLimitPolicy[];
        protocol: string;
    }

    export interface CcPolicyV2CcPrecisionReqLimitPolicy {
        action: string;
        cookie?: string;
        executeDuration: number;
        mode: string;
        period: number;
        requestNum: number;
        uri?: string;
        userAgent?: string;
    }

    export interface CcPolicyV2Threshold {
        domain: string;
        threshold: number;
    }

    export interface DdosIpAttachmentV2BoundIpList {
        bizType?: string;
        deviceType?: string;
        instanceId?: string;
        ip: string;
    }

    export interface DdosPolicyDropOption {
        badConnThreshold: number;
        checkSyncConn: boolean;
        connTimeout: number;
        dConnLimit: number;
        dNewLimit: number;
        dropAbroad: boolean;
        dropIcmp: boolean;
        dropOther: boolean;
        dropTcp: boolean;
        dropUdp: boolean;
        icmpMbpsLimit: number;
        nullConnEnable: boolean;
        otherMbpsLimit: number;
        sConnLimit: number;
        sNewLimit: number;
        synLimit: number;
        synRate?: number;
        tcpMbpsLimit: number;
        udpMbpsLimit: number;
    }

    export interface DdosPolicyPacketFilter {
        action?: string;
        dEndPort?: number;
        dStartPort?: number;
        depth?: number;
        isInclude?: boolean;
        matchBegin?: string;
        matchStr?: string;
        matchType?: string;
        offset?: number;
        pktLengthMax?: number;
        pktLengthMin?: number;
        protocol?: string;
        sEndPort?: number;
        sStartPort?: number;
    }

    export interface DdosPolicyPortFilter {
        action?: string;
        endPort?: number;
        kind?: number;
        protocol?: string;
        startPort?: number;
    }

    export interface DdosPolicyV2Acl {
        action: string;
        dPortEnd: number;
        dPortStart: number;
        forwardProtocol: string;
        priority: number;
        sPortEnd: number;
        sPortStart: number;
    }

    export interface DdosPolicyV2BlackWhiteIp {
        ip: string;
        ipType: string;
    }

    export interface DdosPolicyV2DdosConnectLimit {
        badConnThreshold: number;
        connTimeout: number;
        dstConnLimit: number;
        dstNewLimit: number;
        nullConnEnable: number;
        sdConnLimit: number;
        sdNewLimit: number;
        synLimit: number;
        synRate: number;
    }

    export interface DdosPolicyV2DdosGeoIpBlockConfig {
        action: string;
        areaLists: number[];
        regionType: string;
    }

    export interface DdosPolicyV2DdosSpeedLimitConfig {
        bandwidth: number;
        dstPortList: string;
        mode: number;
        packetRate: number;
        protocolList: string;
    }

    export interface DdosPolicyV2PacketFilter {
        action: string;
        dPortEnd: number;
        dPortStart: number;
        depth: number;
        depth2: number;
        isNot: number;
        isNot2: number;
        matchBegin: string;
        matchBegin2: string;
        matchLogic: string;
        matchType: string;
        matchType2: string;
        offset: number;
        offset2: number;
        pktlenMax: number;
        pktlenMin: number;
        protocol: string;
        sPortEnd: number;
        sPortStart: number;
        str: string;
        str2: string;
    }

    export interface DdosPolicyV2ProtocolBlockConfig {
        dropIcmp: number;
        dropOther: number;
        dropTcp: number;
        dropUdp: number;
    }

    export interface DdosPolicyWatermarkFilter {
        autoRemove?: boolean;
        offset?: number;
        openSwitch?: boolean;
        tcpPortLists?: string[];
        udpPortLists?: string[];
    }

    export interface DdosPolicyWatermarkKey {
        content: string;
        createTime?: string;
        id: string;
        openSwitch: boolean;
    }

    export interface GetCcHttpPoliciesList {
        action: string;
        createTime: string;
        frequency: number;
        ipLists: string[];
        name: string;
        policyId: string;
        resourceId: string;
        resourceType: string;
        ruleLists: outputs.Dayu.GetCcHttpPoliciesListRuleList[];
        smode: string;
        switch: boolean;
    }

    export interface GetCcHttpPoliciesListRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface GetCcHttpsPoliciesList {
        action: string;
        createTime: string;
        domain: string;
        ipLists: string[];
        name: string;
        policyId: string;
        resourceId: string;
        resourceType: string;
        ruleId: string;
        ruleLists: outputs.Dayu.GetCcHttpsPoliciesListRuleList[];
        switch: boolean;
    }

    export interface GetCcHttpsPoliciesListRuleList {
        operator: string;
        skey: string;
        value: string;
    }

    export interface GetDdosPoliciesList {
        blackIps?: string[];
        createTime: string;
        dropOptions: outputs.Dayu.GetDdosPoliciesListDropOption[];
        name: string;
        packetFilters: outputs.Dayu.GetDdosPoliciesListPacketFilter[];
        policyId: string;
        portFilters: outputs.Dayu.GetDdosPoliciesListPortFilter[];
        sceneId: string;
        watermarkFilters: outputs.Dayu.GetDdosPoliciesListWatermarkFilter[];
        watermarkKeys: outputs.Dayu.GetDdosPoliciesListWatermarkKey[];
        whiteIps?: string[];
    }

    export interface GetDdosPoliciesListDropOption {
        badConnThreshold: number;
        checkSyncConn: boolean;
        connTimeout: number;
        dConnLimit: number;
        dNewLimit: number;
        dropAbroad: boolean;
        dropIcmp: boolean;
        dropOther: boolean;
        dropTcp: boolean;
        dropUdp: boolean;
        icmpMbpsLimit: number;
        nullConnEnable: boolean;
        otherMbpsLimit: number;
        sConnLimit: number;
        sNewLimit: number;
        synLimit: number;
        synRate: number;
        tcpMbpsLimit: number;
        udpMbpsLimit: number;
    }

    export interface GetDdosPoliciesListPacketFilter {
        action: string;
        dEndPort: number;
        dStartPort: number;
        depth: number;
        isInclude: boolean;
        matchBegin: string;
        matchStr: string;
        matchType: string;
        offset: number;
        pktLengthMax: number;
        pktLengthMin: number;
        protocol: string;
        sEndPort: number;
        sStartPort: number;
    }

    export interface GetDdosPoliciesListPortFilter {
        action: string;
        endPort: number;
        kind: number;
        protocol: string;
        startPort: number;
    }

    export interface GetDdosPoliciesListWatermarkFilter {
        autoRemove: boolean;
        offset: number;
        openSwitch: boolean;
        tcpPortLists: string[];
        udpPortLists: string[];
    }

    export interface GetDdosPoliciesListWatermarkKey {
        content: string;
        createTime?: string;
        id: string;
        openSwitch: boolean;
    }

    export interface GetDdosPolicyAttachmentsDayuDdosPolicyAttachmentList {
        policyId: string;
        resourceId: string;
        resourceType: string;
    }

    export interface GetDdosPolicyCasesList {
        appProtocols: string[];
        appType: string;
        createTime: string;
        hasAbroad: string;
        hasInitiateTcp: string;
        hasInitiateUdp: string;
        hasVpn: string;
        maxTcpPackageLen: string;
        maxUdpPackageLen: string;
        minTcpPackageLen: string;
        minUdpPackageLen: string;
        name: string;
        peerTcpPort: string;
        peerUdpPort: string;
        platformTypes: string[];
        resourceType: string;
        sceneId: string;
        tcpEndPort: string;
        tcpFootprint: string;
        tcpStartPort: string;
        udpEndPort: string;
        udpFootprint: string;
        udpStartPort: string;
        webApiUrls: string[];
    }

    export interface GetEipList {
        createdTime: string;
        eipAddressStatus: string;
        eipBoundRscEni: string;
        eipBoundRscIns?: string;
        eipBoundRscVip: string;
        eipLists: string[];
        expiredTime: string;
        instanceId?: string;
        modifyTime: string;
        protectionStatus: string;
        region: string;
    }

    export interface GetL4RulesList {
        dPort: number;
        healthCheckHealthNum: number;
        healthCheckInterval: number;
        healthCheckSwitch: boolean;
        healthCheckTimeout: number;
        healthCheckUnhealthNum: number;
        lbType: number;
        name: string;
        protocol: string;
        ruleId: string;
        sPort: number;
        sessionSwitch: boolean;
        sessionTime: number;
        sourceLists: outputs.Dayu.GetL4RulesListSourceList[];
        sourceType: number;
    }

    export interface GetL4RulesListSourceList {
        source: string;
        weight: number;
    }

    export interface GetL4RulesV2List {
        id: string;
        ip: string;
        keepEnable: boolean;
        keeptime: number;
        lbType: number;
        modifyTime: string;
        protocol: string;
        region: number;
        removeSwitch: boolean;
        ruleId: string;
        ruleName: string;
        sourceLists: outputs.Dayu.GetL4RulesV2ListSourceList[];
        sourcePort: number;
        sourceType: number;
        virtualPort: number;
    }

    export interface GetL4RulesV2ListSourceList {
        source: string;
        weight: number;
    }

    export interface GetL7RulesList {
        domain: string;
        healthCheckCode: number;
        healthCheckHealthNum: number;
        healthCheckInterval: number;
        healthCheckMethod: string;
        healthCheckPath: string;
        healthCheckSwitch: boolean;
        healthCheckUnhealthNum: number;
        name: string;
        protocol: string;
        ruleId: string;
        sourceLists: string[];
        sourceType: number;
        sslId: string;
        status: number;
        switch: boolean;
        threshold: number;
    }

    export interface GetL7RulesV2List {
        ccEnable: number;
        ccLevel: string;
        ccStatus: number;
        ccThreshold: number;
        certType: number;
        domain: string;
        httpsToHttpEnable: number;
        id: string;
        ip: string;
        keepEnable: number;
        keepTime: number;
        lbType: number;
        modifyTime: string;
        protocol: string;
        region: number;
        ruleName: string;
        sourceLists: outputs.Dayu.GetL7RulesV2ListSourceList[];
        sourceType: number;
        sslId: string;
        status: number;
        virtualPort: number;
    }

    export interface GetL7RulesV2ListSourceList {
        source: string;
        weight: number;
    }

    export interface L4RuleSourceList {
        source: string;
        weight: number;
    }

    export interface L4RuleV2Rules {
        keepEnable: boolean;
        keeptime: number;
        lbType: number;
        protocol: string;
        region: number;
        removeSwitch: boolean;
        ruleName: string;
        sourceLists: outputs.Dayu.L4RuleV2RulesSourceList[];
        sourcePort: number;
        sourceType: number;
        virtualPort: number;
    }

    export interface L4RuleV2RulesSourceList {
        source: string;
        weight: number;
    }

    export interface L7RuleV2Rule {
        ccEnable?: number;
        certType?: number;
        domain: string;
        httpsToHttpEnable?: number;
        keepEnable: number;
        keeptime: number;
        lbType: number;
        protocol: string;
        sourceLists: outputs.Dayu.L7RuleV2RuleSourceList[];
        sourceType: number;
        sslId?: string;
    }

    export interface L7RuleV2RuleSourceList {
        source: string;
        weight: number;
    }

}

export namespace Dbbrain {
    export interface GetDiagDbInstancesItem {
        auditPolicyStatus: string;
        auditRunningStatus: string;
        cpu: number;
        createTime: string;
        deadlineTime: string;
        deployMode: string;
        engineVersion: string;
        eventCount: number;
        groupId: string;
        groupName: string;
        healthScore: number;
        initFlag: number;
        instanceConfs: outputs.Dbbrain.GetDiagDbInstancesItemInstanceConf[];
        instanceId: string;
        instanceName: string;
        instanceType: number;
        internalVip: string;
        internalVport: number;
        isSupported: boolean;
        memory: number;
        product: string;
        region: string;
        secAuditStatus: string;
        source: string;
        status: number;
        taskStatus: number;
        uniqSubnetId: string;
        uniqVpcId: string;
        vip: string;
        volume: number;
        vport: number;
    }

    export interface GetDiagDbInstancesItemInstanceConf {
        dailyInspection: string;
        keyDelimiters: string[];
        overviewDisplay: string;
    }

    export interface GetDiagEventsList {
        diagItem: string;
        diagType: string;
        endTime: string;
        eventId: number;
        instanceId: string;
        metric: string;
        outline: string;
        region: string;
        severity: number;
        startTime: string;
    }

    export interface GetDiagHistoryEvent {
        diagItem: string;
        diagType: string;
        endTime: string;
        eventId: number;
        instanceId: string;
        metric: string;
        outline: string;
        region: string;
        severity: number;
        startTime: string;
    }

    export interface GetHealthScoresData {
        eventsTotalCount: number;
        healthLevel: string;
        healthScore: number;
        issueTypes: outputs.Dbbrain.GetHealthScoresDataIssueType[];
    }

    export interface GetHealthScoresDataIssueType {
        events: outputs.Dbbrain.GetHealthScoresDataIssueTypeEvent[];
        issueType: string;
        totalCount: number;
    }

    export interface GetHealthScoresDataIssueTypeEvent {
        count: number;
        diagType: string;
        endTime: string;
        eventId: number;
        metric: string;
        outline: string;
        scoreLost: number;
        severity: number;
        startTime: string;
    }

    export interface GetMysqlProcessListProcessList {
        command: string;
        db: string;
        host: string;
        id: string;
        info: string;
        state: string;
        time: string;
        user: string;
    }

    export interface GetNoPrimaryKeyTablesNoPrimaryKeyTable {
        engine: string;
        tableName: string;
        tableRows: number;
        tableSchema: string;
        totalLength: number;
    }

    export interface GetRedisTopBigKeysTopKey {
        encoding: string;
        expireTime: number;
        itemCount: number;
        key: string;
        length: number;
        maxElementSize: number;
        type: string;
    }

    export interface GetRedisTopKeyPrefixListItem {
        aveElementSize: number;
        count: number;
        itemCount: number;
        keyPreIndex: string;
        length: number;
        maxElementSize: number;
    }

    export interface GetSecurityAuditLogExportTasksList {
        asyncRequestId: number;
        createTime: string;
        dangerLevels: number[];
        endTime: string;
        logEndTime: string;
        logStartTime: string;
        progress: number;
        startTime: string;
        status: string;
        totalSize: number;
    }

    export interface GetSlowLogTimeSeriesStatsSeriesData {
        series: outputs.Dbbrain.GetSlowLogTimeSeriesStatsSeriesDataSeries[];
        timestamps: number[];
    }

    export interface GetSlowLogTimeSeriesStatsSeriesDataSeries {
        metric: string;
        unit: string;
        values: number[];
    }

    export interface GetSlowLogTimeSeriesStatsTimeSeries {
        count: number;
        timestamp: number;
    }

    export interface GetSlowLogTopSqlsRow {
        execTimes: number;
        lockTime: number;
        lockTimeAvg: number;
        lockTimeMax: number;
        lockTimeMin: number;
        lockTimeRatio: number;
        md5: string;
        queryTime: number;
        queryTimeAvg: number;
        queryTimeMax: number;
        queryTimeMin: number;
        queryTimeRatio: number;
        rowsExamined: number;
        rowsExaminedAvg: number;
        rowsExaminedMax: number;
        rowsExaminedMin: number;
        rowsExaminedRatio: number;
        rowsSent: number;
        rowsSentAvg: number;
        rowsSentMax: number;
        rowsSentMin: number;
        rowsSentRatio: number;
        schema: string;
        sqlTemplate: string;
        sqlText: string;
    }

    export interface GetSlowLogTopSqlsSchemaList {
        schema: string;
    }

    export interface GetSlowLogUserHostStatsItem {
        count: number;
        ratio: number;
        userHost: string;
    }

    export interface GetSlowLogsRow {
        database: string;
        lockTime: number;
        queryTime: number;
        rowsExamined: number;
        rowsSent: number;
        sqlText: string;
        timestamp: string;
        userHost: string;
        userName: string;
    }

    export interface GetSqlFiltersList {
        createTime: string;
        currentConcurrency: number;
        currentTime: string;
        expireTime: string;
        id: number;
        maxConcurrency: number;
        originKeys: string;
        originRule: string;
        rejectedSqlCount: number;
        sqlType: string;
        status: string;
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeries {
        seriesDatas: outputs.Dbbrain.GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesData[];
        tableSchema: string;
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesData {
        series: outputs.Dbbrain.GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesDataSeries[];
        timestamps: number[];
    }

    export interface GetTopSpaceSchemaTimeSeriesTopSpaceSchemaTimeSeriesSeriesDataSeries {
        metric: string;
        unit: string;
        values: number[];
    }

    export interface GetTopSpaceSchemasTopSpaceSchema {
        dataFree: number;
        dataLength: number;
        fragRatio: number;
        indexLength: number;
        physicalFileSize: number;
        tableRows: number;
        tableSchema: string;
        totalLength: number;
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeries {
        engine: string;
        seriesDatas: outputs.Dbbrain.GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesData[];
        tableName: string;
        tableSchema: string;
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesData {
        series: outputs.Dbbrain.GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesDataSeries[];
        timestamps: number[];
    }

    export interface GetTopSpaceTableTimeSeriesTopSpaceTableTimeSeriesSeriesDataSeries {
        metric: string;
        unit: string;
        values: number[];
    }

    export interface GetTopSpaceTablesTopSpaceTable {
        dataFree: number;
        dataLength: number;
        engine: string;
        fragRatio: number;
        indexLength: number;
        physicalFileSize: number;
        tableName: string;
        tableRows: number;
        tableSchema: string;
        totalLength: number;
    }

    export interface ModifyDiagDbInstanceOperationInstanceConfs {
        dailyInspection?: string;
        overviewDisplay?: string;
    }

    export interface SqlFilterSessionToken {
        password: string;
        user: string;
    }

    export interface TdsqlAuditLogFilter {
        affectRows?: number;
        dbNames?: string[];
        execTime?: number;
        hosts?: string[];
        sentRows?: number;
        users?: string[];
    }

}

export namespace Dc {
    export interface GetAccessPointsAccessPointSet {
        accessPointId: string;
        accessPointName: string;
        accessPointType: string;
        area: string;
        availablePortTypes: string[];
        city: string;
        coordinates: outputs.Dc.GetAccessPointsAccessPointSetCoordinate[];
        lineOperators: string[];
        location: string;
        regionId: string;
        state: string;
    }

    export interface GetAccessPointsAccessPointSetCoordinate {
        lat: number;
        lng: number;
    }

    export interface GetGatewayCcnRoutesInstanceList {
        asPaths: string[];
        cidrBlock: string;
        dcgId: string;
        routeId: string;
    }

    export interface GetGatewayInstancesInstanceList {
        cnnRouteType: string;
        createTime: string;
        dcgId: string;
        dcgIp: string;
        enableBgp: boolean;
        gatewayType: string;
        name: string;
        networkInstanceId: string;
        networkType: string;
    }

    export interface GetInstancesInstanceList {
        accessPointId: string;
        bandwidth: number;
        circuitCode: string;
        createTime: string;
        customerAddress: string;
        customerEmail: string;
        customerName: string;
        customerPhone: string;
        dcId: string;
        enabledTime: string;
        expiredTime: string;
        faultReportContactPerson: string;
        faultReportContactPhone: string;
        lineOperator: string;
        location: string;
        name: string;
        portType: string;
        redundantDcId: string;
        state: string;
        tencentAddress: string;
    }

    export interface GetInternetAddressStatisticsInternetAddressStatistic {
        region: string;
        subnetNum: number;
    }

    export interface GetPublicDirectConnectTunnelRoutesFilter {
        name: string;
        values: string[];
    }

    export interface GetPublicDirectConnectTunnelRoutesRoute {
        asPaths: string[];
        destinationCidrBlock: string;
        nextHop: string;
        routeId: string;
        routeType: string;
        status: string;
    }

}

export namespace Dcdb {
    export interface AccountPrivilegesAccount {
        host: string;
        user: string;
    }

    export interface AccountPrivilegesColumnPrivileges {
        column: string;
        database: string;
        privileges: string[];
        table: string;
    }

    export interface AccountPrivilegesDatabasePrivileges {
        database: string;
        privileges: string[];
    }

    export interface AccountPrivilegesTablePrivileges {
        database: string;
        privileges: string[];
        table: string;
    }

    export interface AccountPrivilegesViewPrivileges {
        database: string;
        privileges: string[];
        view: string;
    }

    export interface DbInstanceInitParam {
        param: string;
        value: string;
    }

    export interface DbInstanceResourceTag {
        tagKey: string;
        tagValue: string;
    }

    export interface DbParametersParams {
        param: string;
        value: string;
    }

    export interface GetAccountsList {
        createTime: string;
        delayThresh: number;
        description: string;
        host: string;
        readOnly: number;
        slaveConst: number;
        updateTime: string;
        userName: string;
    }

    export interface GetDatabaseObjectsFunc {
        func: string;
    }

    export interface GetDatabaseObjectsProc {
        proc: string;
    }

    export interface GetDatabaseObjectsTable {
        table: string;
    }

    export interface GetDatabaseObjectsView {
        view: string;
    }

    export interface GetDatabaseTablesCol {
        col: string;
        type: string;
    }

    export interface GetDatabasesList {
        dbName: string;
    }

    export interface GetInstanceNodeInfoNodesInfo {
        nodeId: string;
        role: string;
        shardId: string;
    }

    export interface GetInstancesList {
        appId: number;
        autoRenewFlag: number;
        createTime: string;
        dbEngine: string;
        dbVersion: string;
        instanceId: string;
        instanceName: string;
        instanceType: number;
        isAuditSupported: number;
        isTmp: number;
        isolatedTimestamp: string;
        memory: number;
        nodeCount: number;
        paymode: string;
        periodEndTime: string;
        projectId: number;
        region: string;
        resourceTags: outputs.Dcdb.GetInstancesListResourceTag[];
        shardCount: number;
        shardDetails: outputs.Dcdb.GetInstancesListShardDetail[];
        status: number;
        statusDesc: string;
        storage: number;
        subnetId: number;
        uin: string;
        updateTime: string;
        vip: string;
        vpcId: number;
        vport: number;
        wanDomain: string;
        wanPort: number;
        wanStatus: number;
        wanVip: string;
    }

    export interface GetInstancesListResourceTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetInstancesListShardDetail {
        cpu: number;
        createtime: string;
        memory: number;
        nodeCount: number;
        shardId: number;
        shardInstanceId: string;
        shardSerialId: string;
        status: number;
        storage: number;
    }

    export interface GetLogFilesFile {
        fileName: string;
        length: number;
        mtime: number;
        uri: string;
    }

    export interface GetOrdersDeal {
        count: number;
        dealName: string;
        flowId: number;
        instanceIds: string[];
        ownerUin: string;
        payMode: number;
    }

    export interface GetParametersList {
        constraints: outputs.Dcdb.GetParametersListConstraint[];
        default: string;
        haveSetValue: boolean;
        needRestart: boolean;
        param: string;
        value: string;
    }

    export interface GetParametersListConstraint {
        enum: string;
        ranges: outputs.Dcdb.GetParametersListConstraintRange[];
        string: string;
        type: string;
    }

    export interface GetParametersListConstraintRange {
        max: string;
        min: string;
    }

    export interface GetProjectSecurityGroupsGroup {
        createTime: string;
        inbounds: outputs.Dcdb.GetProjectSecurityGroupsGroupInbound[];
        outbounds: outputs.Dcdb.GetProjectSecurityGroupsGroupOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProjectsProject {
        appId: number;
        createTime: string;
        creatorUin: number;
        info: string;
        isDefault: number;
        name: string;
        ownerUin: number;
        projectId: number;
        srcAppId: number;
        srcPlat: string;
        status: number;
    }

    export interface GetSaleInfoRegionList {
        availableChoices: outputs.Dcdb.GetSaleInfoRegionListAvailableChoice[];
        region: string;
        regionId: number;
        regionName: string;
        zoneLists: outputs.Dcdb.GetSaleInfoRegionListZoneList[];
    }

    export interface GetSaleInfoRegionListAvailableChoice {
        masterZones: outputs.Dcdb.GetSaleInfoRegionListAvailableChoiceMasterZone[];
        slaveZones: outputs.Dcdb.GetSaleInfoRegionListAvailableChoiceSlaveZone[];
    }

    export interface GetSaleInfoRegionListAvailableChoiceMasterZone {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSaleInfoRegionListAvailableChoiceSlaveZone {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSaleInfoRegionListZoneList {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSecurityGroupsList {
        createTime: string;
        inbounds: outputs.Dcdb.GetSecurityGroupsListInbound[];
        outbounds: outputs.Dcdb.GetSecurityGroupsListOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
    }

    export interface GetSecurityGroupsListInbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetSecurityGroupsListOutbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetShardSpecSpecConfig {
        machine: string;
        specConfigInfos: outputs.Dcdb.GetShardSpecSpecConfigSpecConfigInfo[];
    }

    export interface GetShardSpecSpecConfigSpecConfigInfo {
        cpu: number;
        maxStorage: number;
        memory: number;
        minStorage: number;
        nodeCount: number;
        pid: number;
        qps: number;
        suitInfo: string;
    }

    export interface GetShardsList {
        cpu: number;
        createTime: string;
        instanceId: string;
        memory: number;
        memoryUsage: number;
        nodeCount: number;
        paymode: string;
        periodEndTime: string;
        projectId: number;
        proxyVersion: string;
        range: string;
        region: string;
        shardInstanceId: string;
        shardMasterZone: string;
        shardSerialId: string;
        shardSlaveZones: string[];
        status: number;
        statusDesc: string;
        storage: number;
        storageUsage: number;
        subnetId: string;
        vpcId: string;
        zone: string;
    }

    export interface GetSlowLogsData {
        checkSum: string;
        db: string;
        exampleSql: string;
        fingerPrint: string;
        host: string;
        lockTimeAvg: string;
        lockTimeMax: string;
        lockTimeMin: string;
        lockTimeSum: string;
        queryCount: string;
        queryTimeAvg: string;
        queryTimeMax: string;
        queryTimeMin: string;
        queryTimeSum: string;
        rowsExaminedSum: string;
        rowsSentSum: string;
        tsMax: string;
        tsMin: string;
        user: string;
    }

    export interface GetUpgradePriceAddShardConfig {
        shardCount: number;
        shardMemory: number;
        shardStorage: number;
    }

    export interface GetUpgradePriceExpandShardConfig {
        shardInstanceIds: string[];
        shardMemory: number;
        shardNodeCount?: number;
        shardStorage: number;
    }

    export interface GetUpgradePriceSplitShardConfig {
        shardInstanceIds: string[];
        shardMemory: number;
        shardStorage: number;
        splitRate: number;
    }

    export interface HourdbInstanceResourceTag {
        tagKey: string;
        tagValue: string;
    }

}

export namespace Dcx {
    export interface ExtraConfigBfdInfo {
        interval?: number;
        probeFailedTimes?: number;
    }

    export interface ExtraConfigBgpPeer {
        asn?: number;
        authKey?: string;
    }

    export interface ExtraConfigNqaInfo {
        destinationIp?: string;
        interval?: number;
        probeFailedTimes?: number;
    }

    export interface ExtraConfigRouteFilterPrefixes {
        cidr?: string;
    }

    export interface GetInstancesInstanceList {
        bandwidth: number;
        bgpAsn: number;
        bgpAuthKey: string;
        createTime: string;
        customerAddress: string;
        dcId: string;
        dcgId: string;
        dcxId: string;
        name: string;
        networkRegion: string;
        networkType: string;
        routeFilterPrefixes: string[];
        routeType: string;
        state: string;
        tencentAddress: string;
        vlan: number;
        vpcId: string;
    }

}

export namespace Deprecatedalb {
    export interface ServerAttachmentBackend {
        instanceId: string;
        port: number;
        weight: number;
    }

}

export namespace Deprecatedavailability {
    export interface GetZonesZone {
        description: string;
        id: string;
        name: string;
        state: string;
    }

}

export namespace Deprecatedcontainer {
    export interface GetClusterInstancesNode {
        abnormalReason: string;
        cpu: number;
        instanceId: string;
        isNormal: number;
        lanIp: string;
        mem: number;
        wanIp: string;
    }

    export interface GetClustersCluster {
        clusterId: string;
        clusterName: string;
        description: string;
        kubernetesVersion: string;
        nodesNum: number;
        nodesStatus: string;
        securityCertificationAuthority: string;
        securityClusterExternalEndpoint: string;
        securityPassword: string;
        securityUsername: string;
        totalCpu: number;
        totalMem: number;
    }

}

export namespace Deprecatedeip {
    export interface GetEipFilter {
        name: string;
        values: string[];
    }

}

export namespace Deprecatedeks {
    export interface ClusterDnsServer {
        domain?: string;
        servers?: string[];
    }

    export interface ClusterInternalLb {
        enabled: boolean;
        subnetId?: string;
    }

    export interface ClusterPublicLb {
        allowFromCidrs?: string[];
        enabled: boolean;
        extraParam?: string;
        securityGroup: string;
        securityPolicies?: string[];
    }

    export interface ContainerInstanceCbsVolume {
        diskId: string;
        name: string;
    }

    export interface ContainerInstanceContainer {
        args?: string[];
        commands?: string[];
        cpu?: number;
        envVars?: {[key: string]: any};
        image: string;
        livenessProbe?: outputs.Deprecatedeks.ContainerInstanceContainerLivenessProbe;
        memory?: number;
        name: string;
        readinessProbe?: outputs.Deprecatedeks.ContainerInstanceContainerReadinessProbe;
        volumeMounts?: outputs.Deprecatedeks.ContainerInstanceContainerVolumeMount[];
        workingDir?: string;
    }

    export interface ContainerInstanceContainerLivenessProbe {
        execCommands?: string[];
        failureThreshold?: number;
        httpGetPath?: string;
        httpGetPort?: number;
        httpGetScheme?: string;
        initDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocketPort?: number;
        timeoutSeconds?: number;
    }

    export interface ContainerInstanceContainerReadinessProbe {
        execCommands?: string[];
        failureThreshold?: number;
        httpGetPath?: string;
        httpGetPort?: number;
        httpGetScheme?: string;
        initDelaySeconds?: number;
        periodSeconds?: number;
        successThreshold?: number;
        tcpSocketPort?: number;
        timeoutSeconds?: number;
    }

    export interface ContainerInstanceContainerVolumeMount {
        mountPropagation?: string;
        name: string;
        path: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
    }

    export interface ContainerInstanceImageRegistryCredential {
        name?: string;
        password?: string;
        server?: string;
        username?: string;
    }

    export interface ContainerInstanceInitContainer {
        args?: string[];
        commands?: string[];
        cpu?: number;
        envVars?: {[key: string]: any};
        image: string;
        memory?: number;
        name: string;
        volumeMounts?: outputs.Deprecatedeks.ContainerInstanceInitContainerVolumeMount[];
        workingDir?: string;
    }

    export interface ContainerInstanceInitContainerVolumeMount {
        mountPropagation?: string;
        name: string;
        path: string;
        readOnly?: boolean;
        subPath?: string;
        subPathExpr?: string;
    }

    export interface ContainerInstanceNfsVolume {
        name: string;
        path: string;
        readOnly?: boolean;
        server: string;
    }

    export interface GetClusterCredentialAddress {
        ip: string;
        port: string;
        type: string;
    }

    export interface GetClusterCredentialInternalLb {
        enabled: boolean;
        subnetId: string;
    }

    export interface GetClusterCredentialPublicLb {
        allowFromCidrs: string[];
        enabled: boolean;
        extraParam: string;
        securityGroup: string;
        securityPolicies: string[];
    }

    export interface GetClustersList {
        clusterDesc: string;
        clusterId: string;
        clusterName: string;
        createdTime: string;
        dnsServers: outputs.Deprecatedeks.GetClustersListDnsServer[];
        enableVpcCoreDns: boolean;
        k8sVersion: string;
        needDeleteCbs: boolean;
        serviceSubnetId: string;
        status: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetClustersListDnsServer {
        domain: string;
        servers: string[];
    }

}

export namespace Deprecatedkubernetes {
    export interface AsScalingGroupAutoScalingConfig {
        configurationName: string;
        dataDisks?: outputs.Deprecatedkubernetes.AsScalingGroupAutoScalingConfigDataDisk[];
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        instanceTags?: {[key: string]: any};
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string[];
        password?: string;
        projectId?: number;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        systemDiskSize?: number;
        systemDiskType?: string;
    }

    export interface AsScalingGroupAutoScalingConfigDataDisk {
        diskSize?: number;
        diskType?: string;
        snapshotId?: string;
    }

    export interface AsScalingGroupAutoScalingGroup {
        defaultCooldown?: number;
        desiredCapacity: number;
        forwardBalancerIds?: outputs.Deprecatedkubernetes.AsScalingGroupAutoScalingGroupForwardBalancerId[];
        loadBalancerIds?: string[];
        maxSize: number;
        minSize: number;
        projectId?: number;
        retryPolicy?: string;
        scalingGroupName: string;
        subnetIds?: string[];
        tags?: {[key: string]: any};
        terminationPolicies?: string;
        vpcId: string;
        zones?: string[];
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerId {
        listenerId: string;
        loadBalancerId: string;
        ruleId?: string;
        targetAttributes: outputs.Deprecatedkubernetes.AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute[];
    }

    export interface AsScalingGroupAutoScalingGroupForwardBalancerIdTargetAttribute {
        port: number;
        weight: number;
    }

}

export namespace Deprecatedmonitor {
    export interface BindingObjectDimension {
        dimensionsJson: string;
        uniqueId: string;
    }

    export interface PolicyGroupBindingObject {
        dimensionsJson: string;
        isShielded: number;
        region: string;
        uniqueId: string;
    }

    export interface PolicyGroupCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        calcPeriod: number;
        calcType: number;
        calcValue: number;
        continuePeriod: number;
        metricId: number;
    }

    export interface PolicyGroupEventCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        eventId: number;
    }

    export interface PolicyGroupReceiver {
        endTime: number;
        needSendNotice: number;
        notifyWays: string[];
        personInterval: number;
        receiveLanguage: string;
        receiverGroupLists: number[];
        receiverType: string;
        receiverUserLists: number[];
        recoverNotifies: string[];
        roundInterval: number;
        roundNumber: number;
        sendFors: string[];
        startTime: number;
        uidLists: number[];
    }

}

export namespace Deprecatednats {
    export interface GetNatsNat {
        assignedEipSets: string[];
        bandwidth: number;
        createTime: string;
        id: string;
        maxConcurrent: number;
        name: string;
        state: number;
        vpcId: string;
    }

}

export namespace Deprecatedroute {
    export interface GetTableRoute {
        cidrBlock: string;
        description: string;
        nextHub: string;
        nextType: string;
    }

}

export namespace Deprecatedsecurity {
    export interface GroupRuleAddressTemplate {
        groupId?: string;
        templateId?: string;
    }

    export interface GroupRuleProtocolTemplate {
        groupId?: string;
        templateId?: string;
    }

}

export namespace Dnats {
    export interface GetDnatsDnatList {
        description?: string;
        elasticIp: string;
        elasticPort: string;
        natId: string;
        privateIp: string;
        privatePort: string;
        protocol: string;
        vpcId: string;
    }

}

export namespace Dnspod {
    export interface GetRecordsRecordCountInfo {
        listCount: number;
        subdomainCount: number;
        totalCount: number;
    }

    export interface GetRecordsResult {
        line: string;
        lineId: string;
        monitorStatus: string;
        mx: number;
        name: string;
        recordId: number;
        remark: string;
        status: string;
        ttl: number;
        type: string;
        updatedOn: string;
        value: string;
        weight: number;
    }

}

export namespace Domains {
    export interface GetDomainsList {
        autoRenew: number;
        buyStatus: string;
        codeTld: string;
        creationDate: string;
        domainId: string;
        domainName: string;
        expirationDate: string;
        isPremium: boolean;
        tld: string;
    }

}

export namespace Dts {
    export interface CompareTaskObjects {
        objectItems: outputs.Dts.CompareTaskObjectsObjectItem[];
        objectMode: string;
    }

    export interface CompareTaskObjectsObjectItem {
        dbMode: string;
        dbName: string;
        schemaName: string;
        tableMode: string;
        tables: outputs.Dts.CompareTaskObjectsObjectItemTable[];
        viewMode: string;
        views: outputs.Dts.CompareTaskObjectsObjectItemView[];
    }

    export interface CompareTaskObjectsObjectItemTable {
        tableName: string;
    }

    export interface CompareTaskObjectsObjectItemView {
        viewName: string;
    }

    export interface GetCompareTasksList {
        checkProcesses: outputs.Dts.GetCompareTasksListCheckProcess[];
        compareProcesses: outputs.Dts.GetCompareTasksListCompareProcess[];
        compareTaskId: string;
        conclusion: string;
        configs: outputs.Dts.GetCompareTasksListConfig[];
        createdAt: string;
        finishedAt: string;
        jobId: string;
        startedAt: string;
        status: string;
        taskName: string;
    }

    export interface GetCompareTasksListCheckProcess {
        message: string;
        percent: number;
        status: string;
        stepAll: number;
        stepNow: number;
        steps: outputs.Dts.GetCompareTasksListCheckProcessStep[];
    }

    export interface GetCompareTasksListCheckProcessStep {
        errors?: outputs.Dts.GetCompareTasksListCheckProcessStepError[];
        percent?: number;
        startTime?: string;
        status?: string;
        stepId?: string;
        stepMessage?: string;
        stepName?: string;
        stepNo?: number;
        warnings?: outputs.Dts.GetCompareTasksListCheckProcessStepWarning[];
    }

    export interface GetCompareTasksListCheckProcessStepError {
        helpDoc?: string;
        message?: string;
        solution?: string;
    }

    export interface GetCompareTasksListCheckProcessStepWarning {
        helpDoc?: string;
        message?: string;
        solution?: string;
    }

    export interface GetCompareTasksListCompareProcess {
        message: string;
        percent: number;
        status: string;
        stepAll: number;
        stepNow: number;
        steps: outputs.Dts.GetCompareTasksListCompareProcessStep[];
    }

    export interface GetCompareTasksListCompareProcessStep {
        errors?: outputs.Dts.GetCompareTasksListCompareProcessStepError[];
        percent?: number;
        startTime?: string;
        status?: string;
        stepId?: string;
        stepMessage?: string;
        stepName?: string;
        stepNo?: number;
        warnings?: outputs.Dts.GetCompareTasksListCompareProcessStepWarning[];
    }

    export interface GetCompareTasksListCompareProcessStepError {
        helpDoc?: string;
        message?: string;
        solution?: string;
    }

    export interface GetCompareTasksListCompareProcessStepWarning {
        helpDoc?: string;
        message?: string;
        solution?: string;
    }

    export interface GetCompareTasksListConfig {
        objectItems: outputs.Dts.GetCompareTasksListConfigObjectItem[];
        objectMode: string;
    }

    export interface GetCompareTasksListConfigObjectItem {
        dbMode?: string;
        dbName?: string;
        schemaName?: string;
        tableMode?: string;
        tables?: outputs.Dts.GetCompareTasksListConfigObjectItemTable[];
        viewMode?: string;
        views?: outputs.Dts.GetCompareTasksListConfigObjectItemView[];
    }

    export interface GetCompareTasksListConfigObjectItemTable {
        tableName?: string;
    }

    export interface GetCompareTasksListConfigObjectItemView {
        viewName?: string;
    }

    export interface GetMigrateDbInstancesInstance {
        hint: string;
        instanceId: string;
        instanceName: string;
        usable: number;
        vip: string;
        vport: number;
    }

    export interface GetMigrateJobsList {
        actions: outputs.Dts.GetMigrateJobsListAction[];
        briefMsg: string;
        compareTasks: outputs.Dts.GetMigrateJobsListCompareTask[];
        createTime: string;
        dstInfos: outputs.Dts.GetMigrateJobsListDstInfo[];
        endTime: string;
        expectRunTime: string;
        jobId: string;
        jobName: string;
        runMode?: string;
        srcInfos: outputs.Dts.GetMigrateJobsListSrcInfo[];
        startTime: string;
        status: string;
        stepInfos: outputs.Dts.GetMigrateJobsListStepInfo[];
        tags: outputs.Dts.GetMigrateJobsListTag[];
        tradeInfos: outputs.Dts.GetMigrateJobsListTradeInfo[];
        updateTime: string;
    }

    export interface GetMigrateJobsListAction {
        allActions: string[];
        allowedActions: string[];
    }

    export interface GetMigrateJobsListCompareTask {
        compareTaskId: string;
        status: string;
    }

    export interface GetMigrateJobsListDstInfo {
        accessType: string;
        databaseType: string;
        infos: outputs.Dts.GetMigrateJobsListDstInfoInfo[];
        nodeType: string;
        region: string;
    }

    export interface GetMigrateJobsListDstInfoInfo {
        account: string;
        accountMode: string;
        accountRole: string;
        ccnGwId: string;
        cvmInstanceId: string;
        dbKernel: string;
        engineVersion: string;
        host: string;
        instanceId: string;
        password: string;
        port: number;
        role: string;
        subnetId: string;
        tmpSecretId: string;
        tmpSecretKey: string;
        tmpToken: string;
        uniqVpnGwId: string;
        user: string;
        vpcId: string;
    }

    export interface GetMigrateJobsListSrcInfo {
        accessType: string;
        databaseType: string;
        extraAttrs: outputs.Dts.GetMigrateJobsListSrcInfoExtraAttr[];
        infos: outputs.Dts.GetMigrateJobsListSrcInfoInfo[];
        nodeType: string;
        region: string;
        supplier: string;
    }

    export interface GetMigrateJobsListSrcInfoExtraAttr {
        key: string;
        value: string;
    }

    export interface GetMigrateJobsListSrcInfoInfo {
        account: string;
        accountMode: string;
        accountRole: string;
        ccnGwId: string;
        cvmInstanceId: string;
        dbKernel: string;
        engineVersion: string;
        host: string;
        instanceId: string;
        password: string;
        port: number;
        role: string;
        subnetId: string;
        tmpSecretId: string;
        tmpSecretKey: string;
        tmpToken: string;
        uniqVpnGwId: string;
        user: string;
        vpcId: string;
    }

    export interface GetMigrateJobsListStepInfo {
        masterSlaveDistance: number;
        secondsBehindMaster: number;
        stepAll: number;
        stepInfos: outputs.Dts.GetMigrateJobsListStepInfoStepInfo[];
        stepNow: number;
    }

    export interface GetMigrateJobsListStepInfoStepInfo {
        errors: outputs.Dts.GetMigrateJobsListStepInfoStepInfoError[];
        percent: number;
        startTime: string;
        status: string;
        stepId: string;
        stepMessage: string;
        stepName: string;
        stepNo: number;
        warnings: outputs.Dts.GetMigrateJobsListStepInfoStepInfoWarning[];
    }

    export interface GetMigrateJobsListStepInfoStepInfoError {
        helpDoc: string;
        message: string;
        solution: string;
    }

    export interface GetMigrateJobsListStepInfoStepInfoWarning {
        helpDoc: string;
        message: string;
        solution: string;
    }

    export interface GetMigrateJobsListTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetMigrateJobsListTradeInfo {
        billingType: string;
        dealName: string;
        expireTime: string;
        instanceClass: string;
        isolateReason: string;
        isolateTime: string;
        lastDealName: string;
        offlineReason: string;
        offlineTime: string;
        payType: string;
        tradeStatus: string;
    }

    export interface GetMigrateJobsTagFilter {
        tagKey?: string;
        tagValue?: string;
    }

    export interface GetSyncJobsList {
        actions: string[];
        allActions: string[];
        createTime: string;
        details: outputs.Dts.GetSyncJobsListDetail[];
        dstAccessType: string;
        dstDatabaseType: string;
        dstInfos: outputs.Dts.GetSyncJobsListDstInfo[];
        dstRegion: string;
        endTime: string;
        expectRunTime: string;
        expireTime: string;
        jobId: string;
        jobName: string;
        objects: outputs.Dts.GetSyncJobsListObject[];
        options: outputs.Dts.GetSyncJobsListOption[];
        payMode: string;
        runMode: string;
        specification: string;
        srcAccessType: string;
        srcDatabaseType: string;
        srcInfos: outputs.Dts.GetSyncJobsListSrcInfo[];
        srcRegion: string;
        startTime: string;
        status: string;
        tags: outputs.Dts.GetSyncJobsListTag[];
    }

    export interface GetSyncJobsListDetail {
        currentStepProgress: number;
        masterSlaveDistance: number;
        message: string;
        progress: number;
        secondsBehindMaster: number;
        stepAll: number;
        stepInfos: outputs.Dts.GetSyncJobsListDetailStepInfo[];
        stepNow: number;
    }

    export interface GetSyncJobsListDetailStepInfo {
        errors: outputs.Dts.GetSyncJobsListDetailStepInfoError[];
        progress: number;
        startTime: string;
        status: string;
        stepId: string;
        stepName: string;
        stepNo: number;
        warnings: outputs.Dts.GetSyncJobsListDetailStepInfoWarning[];
    }

    export interface GetSyncJobsListDetailStepInfoError {
        code: string;
        helpDoc: string;
        message: string;
        solution: string;
    }

    export interface GetSyncJobsListDetailStepInfoWarning {
        code: string;
        helpDoc: string;
        message: string;
        solution: string;
    }

    export interface GetSyncJobsListDstInfo {
        account: string;
        accountMode: string;
        accountRole: string;
        ccnId: string;
        cvmInstanceId: string;
        dbKernel: string;
        dbName: string;
        engineVersion: string;
        instanceId: string;
        ip: string;
        password: string;
        port: number;
        region: string;
        subnetId: string;
        supplier: string;
        tmpSecretId: string;
        tmpSecretKey: string;
        tmpToken: string;
        uniqDcgId: string;
        uniqVpnGwId: string;
        user: string;
        vpcId: string;
    }

    export interface GetSyncJobsListObject {
        advancedObjects: string[];
        databases: outputs.Dts.GetSyncJobsListObjectDatabase[];
        mode: string;
    }

    export interface GetSyncJobsListObjectDatabase {
        dbMode: string;
        dbName: string;
        functionMode: string;
        functions: string[];
        newDbName: string;
        newSchemaName: string;
        procedureMode: string;
        procedures: string[];
        schemaName: string;
        tableMode: string;
        tables: outputs.Dts.GetSyncJobsListObjectDatabaseTable[];
        viewMode: string;
        views: outputs.Dts.GetSyncJobsListObjectDatabaseView[];
    }

    export interface GetSyncJobsListObjectDatabaseTable {
        filterCondition: string;
        newTableName: string;
        tableName: string;
    }

    export interface GetSyncJobsListObjectDatabaseView {
        newViewName: string;
        viewName: string;
    }

    export interface GetSyncJobsListOption {
        addAdditionalColumn: boolean;
        conflictHandleOptions: outputs.Dts.GetSyncJobsListOptionConflictHandleOption[];
        conflictHandleType: string;
        ddlOptions: outputs.Dts.GetSyncJobsListOptionDdlOption[];
        dealOfExistSameTable: string;
        initType: string;
        opTypes: string[];
    }

    export interface GetSyncJobsListOptionConflictHandleOption {
        conditionColumn: string;
        conditionOperator: string;
        conditionOrderInSrcAndDst: string;
    }

    export interface GetSyncJobsListOptionDdlOption {
        ddlObject: string;
        ddlValues: string[];
    }

    export interface GetSyncJobsListSrcInfo {
        account: string;
        accountMode: string;
        accountRole: string;
        ccnId: string;
        cvmInstanceId: string;
        dbKernel: string;
        dbName: string;
        engineVersion: string;
        instanceId: string;
        ip: string;
        password: string;
        port: number;
        region: string;
        subnetId: string;
        supplier: string;
        tmpSecretId: string;
        tmpSecretKey: string;
        tmpToken: string;
        uniqDcgId: string;
        uniqVpnGwId: string;
        user: string;
        vpcId: string;
    }

    export interface GetSyncJobsListTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetSyncJobsTagFilter {
        tagKey?: string;
        tagValue?: string;
    }

    export interface MigrateJobDstInfo {
        accessType: string;
        databaseType: string;
        extraAttrs?: outputs.Dts.MigrateJobDstInfoExtraAttr[];
        infos: outputs.Dts.MigrateJobDstInfoInfo[];
        nodeType: string;
        region: string;
        supplier?: string;
    }

    export interface MigrateJobDstInfoExtraAttr {
        key?: string;
        value?: string;
    }

    export interface MigrateJobDstInfoInfo {
        account?: string;
        accountMode?: string;
        accountRole?: string;
        ccnGwId?: string;
        cvmInstanceId?: string;
        dbKernel?: string;
        engineVersion: string;
        host?: string;
        instanceId?: string;
        password?: string;
        port?: number;
        role?: string;
        subnetId?: string;
        tmpSecretId?: string;
        tmpSecretKey?: string;
        tmpToken?: string;
        uniqDcgId?: string;
        uniqVpnGwId?: string;
        user?: string;
        vpcId?: string;
    }

    export interface MigrateJobMigrateOption {
        consistency: outputs.Dts.MigrateJobMigrateOptionConsistency;
        databaseTable: outputs.Dts.MigrateJobMigrateOptionDatabaseTable;
        extraAttrs?: outputs.Dts.MigrateJobMigrateOptionExtraAttr[];
        isDstReadOnly?: boolean;
        isMigrateAccount?: boolean;
        isOverrideRoot?: boolean;
        migrateType: string;
    }

    export interface MigrateJobMigrateOptionConsistency {
        mode?: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTable {
        advancedObjects: string[];
        databases?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabase[];
        objectMode: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabase {
        dbMode?: string;
        dbName?: string;
        eventMode?: string;
        events: string[];
        functionMode?: string;
        functions: string[];
        newDbName?: string;
        newSchemaName?: string;
        procedureMode?: string;
        procedures: string[];
        roleMode?: string;
        roles?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseRole[];
        schemaMode?: string;
        schemaName?: string;
        tableMode?: string;
        tables?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseTable[];
        triggerMode?: string;
        triggers: string[];
        viewMode?: string;
        views?: outputs.Dts.MigrateJobMigrateOptionDatabaseTableDatabaseView[];
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseRole {
        newRoleName?: string;
        roleName?: string;
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseTable {
        newTableName?: string;
        tableEditMode?: string;
        tableName?: string;
        tmpTables: string[];
    }

    export interface MigrateJobMigrateOptionDatabaseTableDatabaseView {
        newViewName?: string;
        viewName?: string;
    }

    export interface MigrateJobMigrateOptionExtraAttr {
        key?: string;
        value?: string;
    }

    export interface MigrateJobSrcInfo {
        accessType: string;
        databaseType: string;
        extraAttrs?: outputs.Dts.MigrateJobSrcInfoExtraAttr[];
        infos: outputs.Dts.MigrateJobSrcInfoInfo[];
        nodeType: string;
        region: string;
        supplier?: string;
    }

    export interface MigrateJobSrcInfoExtraAttr {
        key?: string;
        value?: string;
    }

    export interface MigrateJobSrcInfoInfo {
        account?: string;
        accountMode?: string;
        accountRole?: string;
        ccnGwId?: string;
        cvmInstanceId?: string;
        dbKernel?: string;
        engineVersion: string;
        host?: string;
        instanceId?: string;
        password?: string;
        port?: number;
        role?: string;
        subnetId?: string;
        tmpSecretId?: string;
        tmpSecretKey?: string;
        tmpToken?: string;
        uniqDcgId?: string;
        uniqVpnGwId?: string;
        user?: string;
        vpcId?: string;
    }

    export interface MigrateServiceTag {
        tagKey?: string;
        tagValue?: string;
    }

    export interface SyncConfigDstInfo {
        account?: string;
        accountMode?: string;
        accountRole?: string;
        ccnId?: string;
        cvmInstanceId?: string;
        dbKernel?: string;
        dbName?: string;
        encryptConn?: string;
        engineVersion?: string;
        instanceId?: string;
        ip?: string;
        password: string;
        port?: number;
        region?: string;
        role?: string;
        roleExternalId?: string;
        subnetId?: string;
        supplier?: string;
        tmpSecretId?: string;
        tmpSecretKey?: string;
        tmpToken?: string;
        uniqDcgId?: string;
        uniqVpnGwId?: string;
        user?: string;
        vpcId?: string;
    }

    export interface SyncConfigObjects {
        advancedObjects: string[];
        databases: outputs.Dts.SyncConfigObjectsDatabase[];
        mode?: string;
        onlineDdl: outputs.Dts.SyncConfigObjectsOnlineDdl;
    }

    export interface SyncConfigObjectsDatabase {
        dbMode?: string;
        dbName?: string;
        eventMode?: string;
        events: string[];
        functionMode?: string;
        functions: string[];
        newDbName?: string;
        newSchemaName?: string;
        procedureMode?: string;
        procedures: string[];
        schemaName?: string;
        tableMode?: string;
        tables?: outputs.Dts.SyncConfigObjectsDatabaseTable[];
        triggerMode?: string;
        triggers: string[];
        viewMode?: string;
        views?: outputs.Dts.SyncConfigObjectsDatabaseView[];
    }

    export interface SyncConfigObjectsDatabaseTable {
        filterCondition?: string;
        newTableName?: string;
        tableName?: string;
    }

    export interface SyncConfigObjectsDatabaseView {
        newViewName?: string;
        viewName?: string;
    }

    export interface SyncConfigObjectsOnlineDdl {
        status?: string;
    }

    export interface SyncConfigOptions {
        addAdditionalColumn: boolean;
        conflictHandleOption?: outputs.Dts.SyncConfigOptionsConflictHandleOption;
        conflictHandleType: string;
        ddlOptions?: outputs.Dts.SyncConfigOptionsDdlOption[];
        dealOfExistSameTable: string;
        initType: string;
        opTypes?: string[];
    }

    export interface SyncConfigOptionsConflictHandleOption {
        conditionColumn?: string;
        conditionOperator?: string;
        conditionOrderInSrcAndDst?: string;
    }

    export interface SyncConfigOptionsDdlOption {
        ddlObject?: string;
        ddlValues?: string[];
    }

    export interface SyncConfigSrcInfo {
        account?: string;
        accountMode?: string;
        accountRole?: string;
        ccnId?: string;
        cvmInstanceId?: string;
        dbKernel?: string;
        dbName?: string;
        encryptConn?: string;
        engineVersion?: string;
        instanceId?: string;
        ip?: string;
        password: string;
        port?: number;
        region?: string;
        role?: string;
        roleExternalId?: string;
        subnetId?: string;
        supplier?: string;
        tmpSecretId?: string;
        tmpSecretKey?: string;
        tmpToken?: string;
        uniqDcgId?: string;
        uniqVpnGwId?: string;
        user?: string;
        vpcId?: string;
    }

    export interface SyncJobTag {
        tagKey?: string;
        tagValue?: string;
    }

}

export namespace Eb {
    export interface EventConnectorConnectionDescription {
        apiGwParams?: outputs.Eb.EventConnectorConnectionDescriptionApiGwParams;
        ckafkaParams?: outputs.Eb.EventConnectorConnectionDescriptionCkafkaParams;
        resourceDescription: string;
    }

    export interface EventConnectorConnectionDescriptionApiGwParams {
        method: string;
        protocol: string;
    }

    export interface EventConnectorConnectionDescriptionCkafkaParams {
        offset: string;
        topicName: string;
    }

    export interface EventTargetTargetDescription {
        ckafkaTargetParams?: outputs.Eb.EventTargetTargetDescriptionCkafkaTargetParams;
        esTargetParams?: outputs.Eb.EventTargetTargetDescriptionEsTargetParams;
        resourceDescription: string;
        scfParams?: outputs.Eb.EventTargetTargetDescriptionScfParams;
    }

    export interface EventTargetTargetDescriptionCkafkaTargetParams {
        retryPolicy: outputs.Eb.EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicy;
        topicName: string;
    }

    export interface EventTargetTargetDescriptionCkafkaTargetParamsRetryPolicy {
        maxRetryAttempts: number;
        retryInterval: number;
    }

    export interface EventTargetTargetDescriptionEsTargetParams {
        indexPrefix: string;
        indexSuffixMode: string;
        indexTemplateType?: string;
        netMode: string;
        outputMode: string;
        rotationInterval: string;
    }

    export interface EventTargetTargetDescriptionScfParams {
        batchEventCount?: number;
        batchTimeout?: number;
        enableBatchDelivery?: boolean;
    }

    export interface EventTransformTransformation {
        etlFilter?: outputs.Eb.EventTransformTransformationEtlFilter;
        extraction?: outputs.Eb.EventTransformTransformationExtraction;
        transform?: outputs.Eb.EventTransformTransformationTransform;
    }

    export interface EventTransformTransformationEtlFilter {
        filter: string;
    }

    export interface EventTransformTransformationExtraction {
        extractionInputPath: string;
        format: string;
        textParams?: outputs.Eb.EventTransformTransformationExtractionTextParams;
    }

    export interface EventTransformTransformationExtractionTextParams {
        regex?: string;
        separator?: string;
    }

    export interface EventTransformTransformationTransform {
        outputStructs: outputs.Eb.EventTransformTransformationTransformOutputStruct[];
    }

    export interface EventTransformTransformationTransformOutputStruct {
        key: string;
        value: string;
        valueType: string;
    }

    export interface GetBusEventBus {
        addTime: string;
        connectionBriefs: outputs.Eb.GetBusEventBusConnectionBrief[];
        description: string;
        eventBusId: string;
        eventBusName: string;
        modTime: string;
        payMode: string;
        targetBriefs: outputs.Eb.GetBusEventBusTargetBrief[];
        type: string;
    }

    export interface GetBusEventBusConnectionBrief {
        status: string;
        type: string;
    }

    export interface GetBusEventBusTargetBrief {
        targetId: string;
        type: string;
    }

    export interface GetBusFilter {
        name: string;
        values: string[];
    }

    export interface GetEventRulesRule {
        addTime: string;
        deadLetterConfigs: outputs.Eb.GetEventRulesRuleDeadLetterConfig[];
        description: string;
        enable: boolean;
        eventBusId: string;
        modTime: string;
        ruleId: string;
        ruleName: string;
        status: string;
        targets: outputs.Eb.GetEventRulesRuleTarget[];
    }

    export interface GetEventRulesRuleDeadLetterConfig {
        ckafkaDeliveryParams: outputs.Eb.GetEventRulesRuleDeadLetterConfigCkafkaDeliveryParam[];
        disposeMethod: string;
    }

    export interface GetEventRulesRuleDeadLetterConfigCkafkaDeliveryParam {
        resourceDescription: string;
        topicName: string;
    }

    export interface GetEventRulesRuleTarget {
        targetId: string;
        type: string;
    }

    export interface GetSearchFilter {
        filters?: outputs.Eb.GetSearchFilterFilter[];
        key?: string;
        operator?: string;
        type?: string;
        value?: string;
    }

    export interface GetSearchFilterFilter {
        key: string;
        operator: string;
        value: string;
    }

    export interface GetSearchResult {
        message: string;
        region: string;
        ruleIds: string;
        source: string;
        status: string;
        subject: string;
        timestamp: string;
        type: string;
    }

    export interface PutEventsEventList {
        data: string;
        source: string;
        subject: string;
        time?: number;
        type: string;
    }

}

export namespace Eip {
    export interface GetAddressQuotaQuotaSet {
        quotaCurrent: number;
        quotaId: string;
        quotaLimit: number;
    }

}

export namespace Eips {
    export interface GetEipsEipList {
        createTime: string;
        eipId: string;
        eipName: string;
        eipType: string;
        eniId: string;
        instanceId: string;
        publicIp: string;
        status: string;
        tags: {[key: string]: any};
    }

}

export namespace Elasticsearch {
    export interface GetInstancesInstanceList {
        availabilityZone: string;
        basicSecurityType: number;
        chargeType: string;
        createTime: string;
        deployMode: number;
        elasticsearchDomain: string;
        elasticsearchPort: number;
        elasticsearchVip: string;
        instanceId: string;
        instanceName: string;
        kibanaUrl: string;
        licenseType: string;
        multiZoneInfos: outputs.Elasticsearch.GetInstancesInstanceListMultiZoneInfo[];
        nodeInfoLists: outputs.Elasticsearch.GetInstancesInstanceListNodeInfoList[];
        subnetId: string;
        tags: {[key: string]: any};
        version: string;
        vpcId: string;
    }

    export interface GetInstancesInstanceListMultiZoneInfo {
        availabilityZone: string;
        subnetId: string;
    }

    export interface GetInstancesInstanceListNodeInfoList {
        diskSize: number;
        diskType: string;
        encrypt: boolean;
        nodeNum: number;
        nodeType: string;
        type: string;
    }

    export interface InstanceEsAcl {
        blackLists: string[];
        whiteLists: string[];
    }

    export interface InstanceMultiZoneInfo {
        availabilityZone: string;
        subnetId: string;
    }

    export interface InstanceNodeInfoList {
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        nodeNum: number;
        nodeType: string;
        type?: string;
    }

    export interface InstanceWebNodeTypeInfo {
        nodeNum: number;
        nodeType: string;
    }

}

export namespace Emr {
    export interface ClusterResourceSpec {
        commonCount?: number;
        commonResourceSpec?: outputs.Emr.ClusterResourceSpecCommonResourceSpec;
        coreCount?: number;
        coreResourceSpec?: outputs.Emr.ClusterResourceSpecCoreResourceSpec;
        masterCount?: number;
        masterResourceSpec?: outputs.Emr.ClusterResourceSpecMasterResourceSpec;
        taskCount?: number;
        taskResourceSpec?: outputs.Emr.ClusterResourceSpecTaskResourceSpec;
    }

    export interface ClusterResourceSpecCommonResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecCoreResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecMasterResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface ClusterResourceSpecTaskResourceSpec {
        cpu?: number;
        diskSize?: number;
        diskType?: string;
        memSize?: number;
        rootSize?: number;
        spec?: string;
        storageType?: number;
    }

    export interface GetEmrCluster {
        addTime: string;
        chargeType: number;
        clusterId: string;
        clusterName: string;
        ftitle: string;
        id: number;
        masterIp: string;
        projectId: number;
        regionId: number;
        status: number;
        zone: string;
        zoneId: number;
    }

    export interface GetNodesNode {
        appId: number;
        applyTime: string;
        autoFlag: number;
        cdbIp: string;
        cdbNodeInfos: outputs.Emr.GetNodesNodeCdbNodeInfo[];
        cdbPort: number;
        chargeType: number;
        cpuNum: number;
        destroyable: number;
        deviceClass: string;
        diskSize: string;
        dynamicPodSpec: string;
        emrResourceId: string;
        expireTime: string;
        flag: number;
        freeTime: string;
        hardwareResourceType: string;
        hwDiskSize: number;
        hwDiskSizeDesc: string;
        hwMemSize: number;
        hwMemSizeDesc: string;
        ip: string;
        isAutoRenew: number;
        isDynamicSpec: number;
        mcMultiDisks: outputs.Emr.GetNodesNodeMcMultiDisk[];
        memDesc: string;
        memSize: number;
        mutable: number;
        nameTag: string;
        orderNo: string;
        regionId: number;
        rootSize: number;
        serialNo: string;
        services: string;
        spec: string;
        storageType: number;
        supportModifyPayMode: number;
        tags: outputs.Emr.GetNodesNodeTag[];
        wanIp: string;
        zoneId: number;
    }

    export interface GetNodesNodeCdbNodeInfo {
        applyTime: string;
        expireFlag: boolean;
        expireTime: string;
        instanceName: string;
        ip: string;
        isAutoRenew: number;
        memSize: number;
        payType: number;
        port: number;
        regionId: number;
        serialNo: string;
        service: string;
        status: number;
        volume: number;
        zoneId: number;
    }

    export interface GetNodesNodeMcMultiDisk {
        count: number;
        type: number;
        volume: number;
    }

    export interface GetNodesNodeTag {
        tagKey: string;
        tagValue: string;
    }

}

export namespace Eni {
    export interface EniIpv4 {
        description?: string;
        ip: string;
        primary: boolean;
    }

    export interface EniIpv4Info {
        description: string;
        ip: string;
        primary: boolean;
    }

}

export namespace Enis {
    export interface GetEnisEni {
        createTime: string;
        description: string;
        id: string;
        instanceId: string;
        ipv4s: outputs.Enis.GetEnisEniIpv4[];
        mac: string;
        name: string;
        primary: boolean;
        securityGroups: string[];
        state: string;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetEnisEniIpv4 {
        description: string;
        ip: string;
        primary: boolean;
    }

}

export namespace Gaap {
    export interface GetCertificatesCertificate {
        beginTime: string;
        createTime: string;
        endTime: string;
        id: string;
        issuerCn: string;
        name: string;
        subjectCn: string;
        type: string;
    }

    export interface GetDomainErrorPagesErrorPageInfoList {
        body: string;
        clearHeaders: string[];
        domain: string;
        errorCodes: number[];
        id: string;
        listenerId: string;
        newErrorCodes: number;
        setHeaders: {[key: string]: any};
    }

    export interface GetHttpDomainsDomain {
        basicAuth: boolean;
        basicAuthId: string;
        certificateId: string;
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `client_certificate_ids` instead.
         */
        clientCertificateId: string;
        clientCertificateIds: string[];
        domain: string;
        gaapAuth: boolean;
        gaapAuthId: string;
        realserverAuth: boolean;
        realserverCertificateDomain: string;
        /**
         * @deprecated It has been deprecated from version 1.28.0. Use `realserver_certificate_ids` instead.
         */
        realserverCertificateId: string;
        realserverCertificateIds: string[];
    }

    export interface GetHttpRulesRule {
        connectTimeout: number;
        domain: string;
        forwardHost: string;
        healthCheck: boolean;
        healthCheckMethod: string;
        healthCheckPath: string;
        healthCheckStatusCodes: number[];
        id: string;
        interval: number;
        listenerId: string;
        path: string;
        realserverType: string;
        realservers: outputs.Gaap.GetHttpRulesRuleRealserver[];
        scheduler: string;
        sni: string;
        sniSwitch: string;
    }

    export interface GetHttpRulesRuleRealserver {
        domain: string;
        id: string;
        ip: string;
        port: number;
        status: number;
        weight: number;
    }

    export interface GetLayer4ListenersListener {
        connectTimeout: number;
        createTime: string;
        healthCheck: boolean;
        id: string;
        interval: number;
        name: string;
        port: number;
        protocol: string;
        proxyId: string;
        realserverType: string;
        scheduler: string;
        status: number;
    }

    export interface GetLayer7ListenersListener {
        authType: number;
        certificateId: string;
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `client_certificate_ids` instead.
         */
        clientCertificateId: string;
        clientCertificateIds: string[];
        createTime: string;
        forwardProtocol: string;
        id: string;
        name: string;
        port: number;
        protocol: string;
        proxyId: string;
        status: number;
    }

    export interface GetProxiesProxy {
        accessRegion: string;
        bandwidth: number;
        concurrent: number;
        createTime: string;
        domain: string;
        forwardIp: string;
        id: string;
        ip: string;
        name: string;
        policyId: string;
        projectId: number;
        realserverRegion: string;
        scalable: boolean;
        status: string;
        supportProtocols: string[];
        tags: {[key: string]: any};
        version: string;
    }

    export interface GetRealserversRealserver {
        domain: string;
        id: string;
        ip: string;
        name: string;
        projectId: number;
        tags: {[key: string]: any};
    }

    export interface GetSecurityRulesRule {
        action: string;
        cidrIp: string;
        id: string;
        name: string;
        port: string;
        protocol: string;
    }

    export interface HttpRuleRealserver {
        id: string;
        ip: string;
        port: number;
        weight?: number;
    }

    export interface Layer4ListenerRealserverBindSet {
        id: string;
        ip: string;
        port: number;
        weight?: number;
    }

}

export namespace Ha {
    export interface GetVipEipAttachmentsHaVipEipAttachmentList {
        addressIp: string;
        havipId: string;
    }

    export interface GetVipsHaVipList {
        addressIp: string;
        createTime: string;
        id: string;
        instanceId: string;
        name: string;
        networkInterfaceId: string;
        state: string;
        subnetId: string;
        vip: string;
        vpcId: string;
    }

}

export namespace Image {
    export interface GetImageFilter {
        name: string;
        values: string[];
    }

}

export namespace Images {
    export interface GetImagesImage {
        architecture: string;
        createdTime: string;
        imageCreator: string;
        imageDescription: string;
        imageId: string;
        imageName: string;
        imageSize: number;
        imageSource: string;
        imageState: string;
        imageType: string;
        osName: string;
        platform: string;
        snapshots: outputs.Images.GetImagesImageSnapshot[];
        supportCloudInit: boolean;
        syncPercent: number;
    }

    export interface GetImagesImageSnapshot {
        diskSize: number;
        diskUsage: string;
        snapshotId: string;
        snapshotName: string;
    }

}

export namespace Instance {
    export interface GetTypesFilter {
        name: string;
        values: string[];
    }

    export interface GetTypesInstanceType {
        availabilityZone: string;
        cpuCoreCount: number;
        family: string;
        gpuCoreCount: number;
        instanceChargeType: string;
        instanceType: string;
        memorySize: number;
        status: string;
    }

    export interface InstanceDataDisk {
        dataDiskId: string;
        dataDiskSize: number;
        dataDiskSnapshotId?: string;
        dataDiskType: string;
        deleteWithInstance?: boolean;
        encrypt?: boolean;
        throughputPerformance?: number;
    }

}

export namespace Instances {
    export interface GetInstancesInstanceList {
        allocatePublicIp: boolean;
        availabilityZone: string;
        camRoleName: string;
        cpu: number;
        createTime: string;
        dataDisks: outputs.Instances.GetInstancesInstanceListDataDisk[];
        expiredTime: string;
        imageId: string;
        instanceChargeType: string;
        instanceChargeTypePrepaidRenewFlag: string;
        instanceId: string;
        instanceName: string;
        instanceType: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        memory: number;
        privateIp: string;
        projectId: number;
        publicIp: string;
        securityGroups: string[];
        status: string;
        subnetId: string;
        systemDiskId: string;
        systemDiskSize: number;
        systemDiskType: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetInstancesInstanceListDataDisk {
        dataDiskId: string;
        dataDiskSize: number;
        dataDiskType: string;
        deleteWithInstance: boolean;
    }

    export interface GetSetInstanceList {
        allocatePublicIp: boolean;
        availabilityZone: string;
        camRoleName: string;
        cpu: number;
        createTime: string;
        dataDisks: outputs.Instances.GetSetInstanceListDataDisk[];
        expiredTime: string;
        imageId: string;
        instanceChargeType: string;
        instanceChargeTypePrepaidRenewFlag: string;
        instanceId: string;
        instanceName: string;
        instanceType: string;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        memory: number;
        privateIp: string;
        projectId: number;
        publicIp: string;
        securityGroups: string[];
        status: string;
        subnetId: string;
        systemDiskId: string;
        systemDiskSize: number;
        systemDiskType: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetSetInstanceListDataDisk {
        dataDiskId: string;
        dataDiskSize: number;
        dataDiskType: string;
        deleteWithInstance: boolean;
    }

}

export namespace Key {
    export interface GetPairsKeyPairList {
        createTime: string;
        keyId: string;
        keyName: string;
        projectId: number;
        publicKey: string;
    }

}

export namespace Kms {
    export interface GetKeysKeyList {
        alias: string;
        createTime: number;
        creatorUin: number;
        deletionDate: number;
        description: string;
        keyId: string;
        keyRotationEnabled: boolean;
        keyState: string;
        keyUsage: string;
        nextRotateTime: number;
        origin: string;
        owner: string;
        validTo: number;
    }

}

export namespace Kubernetes {
    export interface ClusterAttachmentWorkerConfig {
        dataDisks?: outputs.Kubernetes.ClusterAttachmentWorkerConfigDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        gpuArgs?: outputs.Kubernetes.ClusterAttachmentWorkerConfigGpuArgs;
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ClusterAttachmentWorkerConfigGpuArgs {
        cuda?: {[key: string]: any};
        cudnn?: {[key: string]: any};
        customDriver?: {[key: string]: any};
        driver?: {[key: string]: any};
        migEnable?: boolean;
    }

    export interface ClusterAttachmentWorkerConfigOverrides {
        dataDisks?: outputs.Kubernetes.ClusterAttachmentWorkerConfigOverridesDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        gpuArgs?: outputs.Kubernetes.ClusterAttachmentWorkerConfigOverridesGpuArgs;
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverridesDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ClusterAttachmentWorkerConfigOverridesGpuArgs {
        cuda?: {[key: string]: any};
        cudnn?: {[key: string]: any};
        customDriver?: {[key: string]: any};
        driver?: {[key: string]: any};
        migEnable?: boolean;
    }

    export interface ClusterAuthOptions {
        autoCreateDiscoveryAnonymousAuth?: boolean;
        issuer?: string;
        jwksUri?: string;
        useTkeDefault?: boolean;
    }

    export interface ClusterClusterAudit {
        deleteAuditLogAndTopic?: boolean;
        enabled: boolean;
        logSetId?: string;
        topicId?: string;
    }

    export interface ClusterClusterExtraArgs {
        kubeApiservers?: string[];
        kubeControllerManagers?: string[];
        kubeSchedulers?: string[];
    }

    export interface ClusterEventPersistence {
        deleteEventLogAndTopic?: boolean;
        enabled: boolean;
        logSetId?: string;
        topicId?: string;
    }

    export interface ClusterExistInstance {
        desiredPodNumbers?: number[];
        instancesPara?: outputs.Kubernetes.ClusterExistInstanceInstancesPara;
        nodeRole?: string;
    }

    export interface ClusterExistInstanceInstancesPara {
        instanceIds: string[];
    }

    export interface ClusterExtensionAddon {
        name: string;
        param: string;
    }

    export interface ClusterLogAgent {
        enabled: boolean;
        kubeletRootDir?: string;
    }

    export interface ClusterMasterConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Kubernetes.ClusterMasterConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        hpcClusterId?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ClusterMasterConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ClusterNodePoolGlobalConfig {
        expander: string;
        ignoreDaemonSetsUtilization: boolean;
        isScaleInEnabled: boolean;
        maxConcurrentScaleIn: number;
        scaleInDelay: number;
        scaleInUnneededTime: number;
        scaleInUtilizationThreshold: number;
        skipNodesWithLocalStorage: boolean;
        skipNodesWithSystemPods: boolean;
    }

    export interface ClusterWorkerConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Kubernetes.ClusterWorkerConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        hpcClusterId?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ClusterWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ClusterWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

    export interface EncryptionProtectionKmsConfiguration {
        keyId?: string;
        kmsRegion?: string;
    }

    export interface GetAvailableClusterVersionsCluster {
        clusterId: string;
        versions: string[];
    }

    export interface GetChartsChartList {
        label: {[key: string]: any};
        latestVersion: string;
        name: string;
    }

    export interface GetClusterAuthenticationOptionsOidcConfig {
        autoCreateClientIds: string[];
        autoCreateOidcConfig: boolean;
        autoInstallPodIdentityWebhookAddon: boolean;
    }

    export interface GetClusterAuthenticationOptionsServiceAccount {
        autoCreateDiscoveryAnonymousAuth: boolean;
        issuer: string;
        jwksUri: string;
        useTkeDefault: boolean;
    }

    export interface GetClusterCommonNamesList {
        commonNames: string;
        subaccountUin: string;
    }

    export interface GetClusterLevelsList {
        alias: string;
        configMapCount: number;
        crdCount: number;
        enable: boolean;
        name: string;
        nodeCount: number;
        otherCount: number;
        podCount: number;
    }

    export interface GetClustersList {
        certificationAuthority: string;
        claimExpiredSeconds: number;
        clusterAsEnabled: boolean;
        clusterCidr: string;
        clusterDeployType: string;
        clusterDesc: string;
        clusterExternalEndpoint: string;
        clusterExtraArgs: outputs.Kubernetes.GetClustersListClusterExtraArg[];
        clusterId: string;
        clusterIpvs: boolean;
        clusterMaxPodNum: number;
        clusterMaxServiceNum: number;
        clusterName: string;
        clusterNodeNum: number;
        clusterOs: string;
        clusterVersion: string;
        /**
         * @deprecated It has been deprecated from version 1.18.1.
         */
        containerRuntime: string;
        deletionProtection: boolean;
        domain: string;
        eniSubnetIds: string[];
        ignoreClusterCidrConflict: boolean;
        isNonStaticIpMode: boolean;
        kubeConfig: string;
        kubeConfigIntranet: string;
        kubeProxyMode: string;
        networkType: string;
        nodeNameType: string;
        password: string;
        pgwEndpoint: string;
        projectId: number;
        securityPolicies: string[];
        serviceCidr: string;
        tags: {[key: string]: any};
        userName: string;
        vpcId: string;
        workerInstancesLists: outputs.Kubernetes.GetClustersListWorkerInstancesList[];
    }

    export interface GetClustersListClusterExtraArg {
        kubeApiservers: string[];
        kubeControllerManagers: string[];
        kubeSchedulers: string[];
    }

    export interface GetClustersListWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

    export interface NodePoolAutoScalingConfig {
        backupInstanceTypes?: string[];
        bandwidthPackageId?: string;
        camRoleName?: string;
        dataDisks?: outputs.Kubernetes.NodePoolAutoScalingConfigDataDisk[];
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostName: string;
        hostNameStyle: string;
        instanceChargeType: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag: string;
        instanceName: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string[];
        orderlySecurityGroupIds: string[];
        password?: string;
        publicIpAssigned?: boolean;
        /**
         * @deprecated The order of elements in this field cannot be guaranteed. Use `orderly_security_group_ids` instead.
         */
        securityGroupIds: string[];
        spotInstanceType?: string;
        spotMaxPrice?: string;
        systemDiskSize?: number;
        systemDiskType?: string;
    }

    export interface NodePoolAutoScalingConfigDataDisk {
        deleteWithInstance?: boolean;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        snapshotId?: string;
        throughputPerformance?: number;
    }

    export interface NodePoolNodeConfig {
        dataDisks?: outputs.Kubernetes.NodePoolNodeConfigDataDisk[];
        desiredPodNum?: number;
        dockerGraphPath?: string;
        extraArgs?: string[];
        gpuArgs?: outputs.Kubernetes.NodePoolNodeConfigGpuArgs;
        isSchedule?: boolean;
        mountTarget?: string;
        userData?: string;
    }

    export interface NodePoolNodeConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface NodePoolNodeConfigGpuArgs {
        cuda?: {[key: string]: any};
        cudnn?: {[key: string]: any};
        customDriver?: {[key: string]: any};
        driver?: {[key: string]: any};
        migEnable?: boolean;
    }

    export interface NodePoolTaint {
        effect: string;
        key: string;
        value: string;
    }

    export interface ScaleWorkerDataDisk {
        autoFormatAndMount?: boolean;
        diskSize?: number;
        diskType?: string;
        fileSystem?: string;
        mountTarget?: string;
    }

    export interface ScaleWorkerGpuArgs {
        cuda?: {[key: string]: any};
        cudnn?: {[key: string]: any};
        customDriver?: {[key: string]: any};
        driver?: {[key: string]: any};
        migEnable?: boolean;
    }

    export interface ScaleWorkerWorkerConfig {
        availabilityZone?: string;
        bandwidthPackageId?: string;
        camRoleName?: string;
        count?: number;
        dataDisks?: outputs.Kubernetes.ScaleWorkerWorkerConfigDataDisk[];
        desiredPodNum?: number;
        disasterRecoverGroupIds?: string;
        enhancedMonitorService?: boolean;
        enhancedSecurityService?: boolean;
        hostname?: string;
        hpcClusterId?: string;
        imgId?: string;
        instanceChargeType?: string;
        instanceChargeTypePrepaidPeriod?: number;
        instanceChargeTypePrepaidRenewFlag?: string;
        instanceName?: string;
        instanceType: string;
        internetChargeType?: string;
        internetMaxBandwidthOut?: number;
        keyIds?: string;
        password?: string;
        publicIpAssigned?: boolean;
        securityGroupIds?: string[];
        subnetId: string;
        systemDiskSize?: number;
        systemDiskType?: string;
        userData?: string;
    }

    export interface ScaleWorkerWorkerConfigDataDisk {
        autoFormatAndMount?: boolean;
        diskPartition?: string;
        diskSize?: number;
        diskType?: string;
        encrypt?: boolean;
        fileSystem?: string;
        kmsKeyId?: string;
        mountTarget?: string;
        snapshotId?: string;
    }

    export interface ScaleWorkerWorkerInstancesList {
        failedReason: string;
        instanceId: string;
        instanceRole: string;
        instanceState: string;
        lanIp: string;
    }

    export interface ServerlessNodePoolServerlessNode {
        displayName?: string;
        subnetId: string;
    }

    export interface ServerlessNodePoolTaint {
        effect: string;
        key: string;
        value: string;
    }

}

export namespace Lighthouse {
    export interface DiskAutoMountConfiguration {
        fileSystemType?: string;
        instanceId: string;
        mountPoint?: string;
    }

    export interface DiskDiskChargePrepaid {
        period: number;
        renewFlag?: string;
        timeUnit?: string;
    }

    export interface FirewallRuleFirewallRule {
        action?: string;
        cidrBlock?: string;
        firewallRuleDescription?: string;
        port?: string;
        protocol: string;
    }

    export interface FirewallTemplateTemplateRule {
        action?: string;
        cidrBlock?: string;
        firewallRuleDescription?: string;
        port?: string;
        protocol: string;
    }

    export interface GetAllSceneSceneSet {
        description: string;
        displayName: string;
        sceneId: string;
    }

    export interface GetBundleBundleSet {
        bundleDisplayLabel: string;
        bundleId: string;
        bundleSalesState: string;
        bundleType: string;
        cpu: number;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        memory: number;
        monthlyTraffic: number;
        prices: outputs.Lighthouse.GetBundleBundleSetPrice[];
        supportLinuxUnixPlatform: boolean;
        supportWindowsPlatform: boolean;
        systemDiskSize: number;
        systemDiskType: string;
    }

    export interface GetBundleBundleSetPrice {
        instancePrices: outputs.Lighthouse.GetBundleBundleSetPriceInstancePrice[];
    }

    export interface GetBundleBundleSetPriceInstancePrice {
        currency: string;
        discount: number;
        discountPrice: number;
        originalBundlePrice: number;
        originalPrice: number;
    }

    export interface GetBundleFilter {
        name: string;
        values: string[];
    }

    export interface GetDiskConfigDiskConfigSet {
        diskSalesState: string;
        diskStepSize: number;
        diskType: string;
        maxDiskSize: number;
        minDiskSize: number;
        zone: string;
    }

    export interface GetDiskConfigFilter {
        name: string;
        values: string[];
    }

    export interface GetDisksDiskList {
        attached: boolean;
        createdTime: string;
        deleteWithInstance: boolean;
        diskBackupCount: number;
        diskBackupQuota: number;
        diskChargeType: string;
        diskId: string;
        diskName: string;
        diskSize: number;
        diskState: string;
        diskType: string;
        diskUsage: string;
        expiredTime: string;
        instanceId: string;
        isolatedTime: string;
        latestOperation: string;
        latestOperationRequestId: string;
        latestOperationState: string;
        renewFlag: string;
        zone: string;
    }

    export interface GetDisksFilter {
        name: string;
        values: string[];
    }

    export interface GetFirewallRulesTemplateFirewallRuleSet {
        action: string;
        appType: string;
        cidrBlock: string;
        firewallRuleDescription: string;
        port: string;
        protocol: string;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSet {
        blueprints: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetBlueprint[];
        instanceId: string;
        softwareSets: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetSoftwareSet[];
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetBlueprint {
        blueprintId: string;
        blueprintName: string;
        blueprintState: string;
        blueprintType: string;
        communityUrl: string;
        createdTime: string;
        description: string;
        displayTitle: string;
        displayVersion: string;
        dockerVersion: string;
        guideUrl: string;
        imageId: string;
        imageUrl: string;
        osName: string;
        platform: string;
        platformType: string;
        requiredMemorySize: number;
        requiredSystemDiskSize: number;
        sceneIdSets: string[];
        supportAutomationTools: boolean;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetSoftwareSet {
        detailSets: outputs.Lighthouse.GetInstanceBlueprintBlueprintInstanceSetSoftwareSetDetailSet[];
        imageUrl: string;
        installDir: string;
        name: string;
        version: string;
    }

    export interface GetInstanceBlueprintBlueprintInstanceSetSoftwareSetDetailSet {
        key: string;
        title: string;
        value: string;
    }

    export interface GetInstanceDiskNumAttachDetailSet {
        attachedDiskCount: number;
        instanceId: string;
        maxAttachCount: number;
    }

    export interface GetInstanceTrafficPackageInstanceTrafficPackageSet {
        instanceId: string;
        trafficPackageSets: outputs.Lighthouse.GetInstanceTrafficPackageInstanceTrafficPackageSetTrafficPackageSet[];
    }

    export interface GetInstanceTrafficPackageInstanceTrafficPackageSetTrafficPackageSet {
        deadline: string;
        endTime: string;
        startTime: string;
        status: string;
        trafficOverflow: number;
        trafficPackageId: string;
        trafficPackageRemaining: number;
        trafficPackageTotal: number;
        trafficUsed: number;
    }

    export interface GetModifyInstanceBundleFilter {
        name: string;
        values: string[];
    }

    export interface GetModifyInstanceBundleModifyBundleSet {
        bundles: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundle[];
        modifyBundleState: string;
        modifyPrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetModifyPrice[];
        notSupportModifyMessage: string;
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundle {
        bundleDisplayLabel: string;
        bundleId: string;
        bundleSalesState: string;
        bundleType: string;
        bundleTypeDescription: string;
        cpu: number;
        internetChargeType: string;
        internetMaxBandwidthOut: number;
        memory: number;
        monthlyTraffic: number;
        prices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundlePrice[];
        supportLinuxUnixPlatform: boolean;
        supportWindowsPlatform: boolean;
        systemDiskSize: number;
        systemDiskType: string;
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundlePrice {
        instancePrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetBundlePriceInstancePrice[];
    }

    export interface GetModifyInstanceBundleModifyBundleSetBundlePriceInstancePrice {
        currency: string;
        discount: number;
        discountPrice: number;
        originalBundlePrice: number;
        originalPrice: number;
    }

    export interface GetModifyInstanceBundleModifyBundleSetModifyPrice {
        instancePrices: outputs.Lighthouse.GetModifyInstanceBundleModifyBundleSetModifyPriceInstancePrice[];
    }

    export interface GetModifyInstanceBundleModifyBundleSetModifyPriceInstancePrice {
        currency: string;
        discount: number;
        discountPrice: number;
        originalBundlePrice: number;
        originalPrice: number;
    }

    export interface GetRegionRegionSet {
        isChinaMainland: boolean;
        region: string;
        regionName: string;
        regionState: string;
    }

    export interface GetResetInstanceBlueprintFilter {
        name: string;
        values: string[];
    }

    export interface GetResetInstanceBlueprintResetInstanceBlueprintSet {
        blueprintInfos: outputs.Lighthouse.GetResetInstanceBlueprintResetInstanceBlueprintSetBlueprintInfo[];
        isResettable: boolean;
        nonResettableMessage: string;
    }

    export interface GetResetInstanceBlueprintResetInstanceBlueprintSetBlueprintInfo {
        blueprintId: string;
        blueprintName: string;
        blueprintState: string;
        blueprintType: string;
        communityUrl: string;
        createdTime: string;
        description: string;
        displayTitle: string;
        displayVersion: string;
        dockerVersion: string;
        guideUrl: string;
        imageId: string;
        imageUrl: string;
        osName: string;
        platform: string;
        platformType: string;
        requiredMemorySize: number;
        requiredSystemDiskSize: number;
        sceneIdSets: string[];
        supportAutomationTools: boolean;
    }

    export interface GetSceneSceneSet {
        description: string;
        displayName: string;
        sceneId: string;
    }

    export interface GetZoneZoneInfoSet {
        instanceDisplayLabel: string;
        zone: string;
        zoneName: string;
    }

    export interface InstanceContainer {
        command?: string;
        containerImage?: string;
        containerName?: string;
        envs?: outputs.Lighthouse.InstanceContainerEnv[];
        publishPorts?: outputs.Lighthouse.InstanceContainerPublishPort[];
        volumes?: outputs.Lighthouse.InstanceContainerVolume[];
    }

    export interface InstanceContainerEnv {
        key: string;
        value: string;
    }

    export interface InstanceContainerPublishPort {
        containerPort: number;
        hostPort: number;
        ip?: string;
        protocol?: string;
    }

    export interface InstanceContainerVolume {
        containerPath: string;
        hostPath: string;
    }

    export interface InstanceLoginConfiguration {
        autoGeneratePassword: string;
        password?: string;
    }

    export interface RenewDiskRenewDiskChargePrepaid {
        curInstanceDeadline?: string;
        period?: number;
        renewFlag?: string;
        timeUnit?: string;
    }

    export interface RenewInstanceInstanceChargePrepaid {
        period: number;
        renewFlag?: string;
    }

}

export namespace Mariadb {
    export interface AccountPrivilegesAccounts {
        host: string;
        user: string;
    }

    export interface AccountPrivilegesColumnPrivilege {
        column: string;
        database: string;
        privileges: string[];
        table: string;
    }

    export interface AccountPrivilegesDatabasePrivilege {
        database: string;
        privileges: string[];
    }

    export interface AccountPrivilegesFunctionPrivilege {
        database: string;
        functionName: string;
        privileges: string[];
    }

    export interface AccountPrivilegesProcedurePrivilege {
        database: string;
        privileges: string[];
        procedure: string;
    }

    export interface AccountPrivilegesTablePrivilege {
        database: string;
        privileges: string[];
        table: string;
    }

    export interface AccountPrivilegesViewPrivilege {
        database: string;
        privileges: string[];
        view: string;
    }

    export interface GetAccountsList {
        createTime: string;
        delayThresh: number;
        description: string;
        host: string;
        readOnly: number;
        slaveConst: number;
        updateTime: string;
        userName: string;
    }

    export interface GetDatabaseObjectsFunc {
        func: string;
    }

    export interface GetDatabaseObjectsProc {
        proc: string;
    }

    export interface GetDatabaseObjectsTable {
        table: string;
    }

    export interface GetDatabaseObjectsView {
        view: string;
    }

    export interface GetDatabaseTableCol {
        col: string;
        type: string;
    }

    export interface GetDatabasesDatabase {
        dbName: string;
    }

    export interface GetDbInstancesInstance {
        dbVersionId: string;
        instanceId: string;
        instanceName: string;
        memory: number;
        projectId: number;
        region: string;
        resourceTags: outputs.Mariadb.GetDbInstancesInstanceResourceTag[];
        storage: number;
        subnetId: string;
        vpcId: string;
        zone: string;
    }

    export interface GetDbInstancesInstanceResourceTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetDcnDetailDcnDetail {
        cpu: number;
        createTime: string;
        dcnFlag: number;
        dcnStatus: number;
        encryptStatus: number;
        instanceId: string;
        instanceName: string;
        instanceType: number;
        memory: number;
        payMode: number;
        periodEndTime: string;
        region: string;
        replicaConfigs: outputs.Mariadb.GetDcnDetailDcnDetailReplicaConfig[];
        replicaStatuses: outputs.Mariadb.GetDcnDetailDcnDetailReplicaStatus[];
        status: number;
        statusDesc: string;
        storage: number;
        vip: string;
        vipv6: string;
        vport: number;
        zone: string;
    }

    export interface GetDcnDetailDcnDetailReplicaConfig {
        delayReplicationType: string;
        dueTime: string;
        replicationDelay: number;
        roReplicationMode: string;
    }

    export interface GetDcnDetailDcnDetailReplicaStatus {
        delay: number;
        status: string;
    }

    export interface GetInstanceNodeInfoNodesInfo {
        nodeId: string;
        role: string;
    }

    export interface GetInstanceSpecsSpec {
        machine: string;
        specInfos: outputs.Mariadb.GetInstanceSpecsSpecSpecInfo[];
    }

    export interface GetInstanceSpecsSpecSpecInfo {
        cpu: number;
        machine: string;
        maxStorage: number;
        memory: number;
        minStorage: number;
        nodeCount: number;
        pid: number;
        qps: number;
        suitInfo: string;
    }

    export interface GetLogFilesFile {
        fileName: string;
        length: number;
        mtime: number;
        uri: string;
    }

    export interface GetOrdersDeal {
        count: number;
        dealName: string;
        flowId: number;
        instanceIds: string[];
        ownerUin: string;
        payMode: number;
    }

    export interface GetProjectSecurityGroupsGroup {
        createTime: string;
        inbounds: outputs.Mariadb.GetProjectSecurityGroupsGroupInbound[];
        outbounds: outputs.Mariadb.GetProjectSecurityGroupsGroupOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsGroupInbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProjectSecurityGroupsGroupOutbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetSaleInfoRegionList {
        availableChoices: outputs.Mariadb.GetSaleInfoRegionListAvailableChoice[];
        region: string;
        regionId: number;
        regionName: string;
        zoneLists: outputs.Mariadb.GetSaleInfoRegionListZoneList[];
    }

    export interface GetSaleInfoRegionListAvailableChoice {
        masterZones: outputs.Mariadb.GetSaleInfoRegionListAvailableChoiceMasterZone[];
        slaveZones: outputs.Mariadb.GetSaleInfoRegionListAvailableChoiceSlaveZone[];
    }

    export interface GetSaleInfoRegionListAvailableChoiceMasterZone {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSaleInfoRegionListAvailableChoiceSlaveZone {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSaleInfoRegionListZoneList {
        onSale: boolean;
        zone: string;
        zoneId: number;
        zoneName: string;
    }

    export interface GetSecurityGroupsList {
        createTime: string;
        inbounds: outputs.Mariadb.GetSecurityGroupsListInbound[];
        outbounds: outputs.Mariadb.GetSecurityGroupsListOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetSecurityGroupsListInbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetSecurityGroupsListOutbound {
        action: string;
        cidrIp: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetSlowLogsData {
        checkSum: string;
        db: string;
        exampleSql: string;
        fingerPrint: string;
        host: string;
        lockTimeAvg: string;
        lockTimeMax: string;
        lockTimeMin: string;
        lockTimeSum: string;
        queryCount: string;
        queryTimeAvg: string;
        queryTimeMax: string;
        queryTimeMin: string;
        queryTimeSum: string;
        rowsExaminedSum: string;
        rowsSentSum: string;
        tsMax: string;
        tsMin: string;
        user: string;
    }

    export interface InstanceInitParam {
        param: string;
        value: string;
    }

    export interface ParametersParam {
        param: string;
        value: string;
    }

}

export namespace Mdl {
    export interface StreamLiveInputInputSetting {
        appName?: string;
        delayTime?: number;
        inputAddress?: string;
        inputDomain?: string;
        password?: string;
        sourceType?: string;
        sourceUrl?: string;
        streamName?: string;
        userName?: string;
    }

}

export namespace Mongodb {
    export interface GetInstanceBackupsBackupList {
        backupDesc: string;
        backupMethod: number;
        backupName: string;
        backupSize: number;
        backupType: number;
        endTime: string;
        instanceId: string;
        startTime: string;
        status: number;
    }

    export interface GetInstanceConnectionsClient {
        count: number;
        internalService: boolean;
        ip: string;
    }

    export interface GetInstanceCurrentOpCurrentOp {
        microsecsRunning: number;
        nodeName: string;
        ns: string;
        op: string;
        opId: number;
        operation: string;
        query: string;
        replicaSetName: string;
        state: string;
    }

    export interface GetInstanceParamsInstanceEnumParam {
        currentValue: string;
        defaultValue: string;
        enumValues: string[];
        needRestart: string;
        paramName: string;
        status: number;
        tips: string[];
        valueType: string;
    }

    export interface GetInstanceParamsInstanceIntegerParam {
        currentValue: string;
        defaultValue: string;
        max: string;
        min: string;
        needRestart: string;
        paramName: string;
        status: number;
        tips: string[];
        valueType: string;
    }

    export interface GetInstanceParamsInstanceMultiParam {
        currentValue: string;
        defaultValue: string;
        enumValues: string[];
        needRestart: string;
        paramName: string;
        status: number;
        tips: string[];
        valueType: string;
    }

    export interface GetInstanceParamsInstanceTextParam {
        currentValue: string;
        defaultValue: string;
        needRestart: string;
        paramName: string;
        status: string;
        textValue: string;
        tips: string[];
        valueType: string;
    }

    export interface GetInstancesInstanceList {
        autoRenewFlag: number;
        availableZone: string;
        chargeType: string;
        clusterType: string;
        cpu: number;
        createTime: string;
        engineVersion: string;
        instanceId: string;
        instanceName: string;
        machineType: string;
        memory: number;
        projectId: number;
        shardQuantity: number;
        status: number;
        subnetId: string;
        tags: {[key: string]: any};
        vip: string;
        volume: number;
        vpcId: string;
        vport: number;
    }

    export interface GetZoneConfigList {
        availableZone: string;
        clusterType: string;
        cpu: number;
        defaultStorage: number;
        engineVersion: string;
        machineType: string;
        maxReplicateSetNum: number;
        maxStorage: number;
        memory: number;
        minReplicateSetNum: number;
        minStorage: number;
    }

    export interface InstanceAccountAuthRole {
        mask: number;
        namespace: string;
    }

    export interface InstanceBackupDownloadTaskBackupSet {
        replicaSetId: string;
    }

    export interface InstanceStandbyInstanceList {
        standbyInstanceId: string;
        standbyInstanceRegion: string;
    }

}

export namespace Monitor {
    export interface AlarmNoticeClsNotice {
        enable?: number;
        logSetId: string;
        region: string;
        topicId: string;
    }

    export interface AlarmNoticeUrlNotice {
        endTime?: number;
        isValid: number;
        startTime?: number;
        url: string;
        validationCode?: string;
        weekdays?: number[];
    }

    export interface AlarmNoticeUserNotice {
        endTime: number;
        groupIds?: number[];
        needPhoneArriveNotice?: number;
        noticeWays: string[];
        phoneCallType?: string;
        phoneCircleInterval?: number;
        phoneCircleTimes?: number;
        phoneInnerInterval?: number;
        phoneOrders?: number[];
        receiverType: string;
        startTime: number;
        userIds?: number[];
        weekdays?: number[];
    }

    export interface AlarmPolicyConditions {
        isUnionRule?: number;
        rules?: outputs.Monitor.AlarmPolicyConditionsRule[];
    }

    export interface AlarmPolicyConditionsRule {
        continuePeriod: number;
        description: string;
        filter?: outputs.Monitor.AlarmPolicyConditionsRuleFilter;
        isPowerNotice: number;
        metricName?: string;
        noticeFrequency: number;
        operator?: string;
        period?: number;
        ruleType: string;
        unit: string;
        value?: string;
    }

    export interface AlarmPolicyConditionsRuleFilter {
        dimensions?: string;
        type?: string;
    }

    export interface AlarmPolicyEventCondition {
        continuePeriod: number;
        description: string;
        filter?: outputs.Monitor.AlarmPolicyEventConditionFilter;
        isPowerNotice: number;
        metricName?: string;
        noticeFrequency: number;
        operator?: string;
        period?: number;
        ruleType: string;
        unit: string;
        value?: string;
    }

    export interface AlarmPolicyEventConditionFilter {
        dimensions?: string;
        type?: string;
    }

    export interface AlarmPolicyPolicyTag {
        key: string;
        value: string;
    }

    export interface AlarmPolicyTriggerTask {
        taskConfig: string;
        type: string;
    }

    export interface BindingReceiverReceivers {
        endTime?: number;
        notifyWays: string[];
        receiveLanguage?: string;
        receiverGroupLists?: number[];
        receiverType: string;
        receiverUserLists?: number[];
        startTime?: number;
    }

    export interface GetAlarmNoticesAlarmNotice {
        ampConsumerId: string;
        clsNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeClsNotice[];
        id: string;
        isPreset: number;
        name: string;
        noticeLanguage: string;
        noticeType: string;
        policyIds: string[];
        updatedAt: string;
        updatedBy: string;
        urlNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeUrlNotice[];
        userNotices: outputs.Monitor.GetAlarmNoticesAlarmNoticeUserNotice[];
    }

    export interface GetAlarmNoticesAlarmNoticeClsNotice {
        enable: number;
        logSetId: string;
        region: string;
        topicId: string;
    }

    export interface GetAlarmNoticesAlarmNoticeUrlNotice {
        endTime: number;
        startTime: number;
        url: string;
        weekdays: number[];
    }

    export interface GetAlarmNoticesAlarmNoticeUserNotice {
        endTime: number;
        groupIds: number[];
        needPhoneArriveNotice: number;
        noticeWays: string[];
        phoneCallType: string;
        phoneCircleInterval: number;
        phoneCircleTimes: number;
        phoneInnerInterval: number;
        phoneOrders: number[];
        receiverType: string;
        startTime: number;
        userIds: number[];
        weekdays: number[];
    }

    export interface GetBindingObjectsList {
        dimensionsJson: string;
        isShielded: number;
        region: string;
        uniqueId: string;
    }

    export interface GetDataDimension {
        name: string;
        value: string;
    }

    export interface GetDataList {
        timestamp: number;
        value: number;
    }

    export interface GetPolicyConditionsList {
        eventMetrics: outputs.Monitor.GetPolicyConditionsListEventMetric[];
        isSupportMultiRegion: boolean;
        metrics: outputs.Monitor.GetPolicyConditionsListMetric[];
        name: string;
        policyViewName: string;
        supportRegions: string[];
    }

    export interface GetPolicyConditionsListEventMetric {
        eventId: number;
        eventShowName: string;
        needRecovered: boolean;
    }

    export interface GetPolicyConditionsListMetric {
        calcTypeKeys: number[];
        calcTypeNeed: boolean;
        calcValueDefault: string;
        calcValueFixed: string;
        calcValueMax: string;
        calcValueMin: string;
        calcValueNeed: boolean;
        continueTimeDefault: number;
        continueTimeKeys: number[];
        continueTimeNeed: boolean;
        metricId: number;
        metricShowName: string;
        metricUnit: string;
        periodDefault: number;
        periodKeys: number[];
        periodNeed: boolean;
        periodNumDefault: number;
        periodNumKeys: number[];
        periodNumNeed: boolean;
        statTypeP10: string;
        statTypeP1800: string;
        statTypeP300: string;
        statTypeP3600: string;
        statTypeP5: string;
        statTypeP60: string;
        statTypeP600: string;
        statTypeP86400: string;
    }

    export interface GetPolicyGroupsList {
        canSetDefault: boolean;
        conditions: outputs.Monitor.GetPolicyGroupsListCondition[];
        eventConditions: outputs.Monitor.GetPolicyGroupsListEventCondition[];
        groupId: number;
        groupName: string;
        insertTime: number;
        isDefault: number;
        isOpen: boolean;
        lastEditUin: string;
        noShieldedSum: number;
        parentGroupId: number;
        policyViewName: string;
        projectId: number;
        receivers: outputs.Monitor.GetPolicyGroupsListReceiver[];
        remark: string;
        updateTime: number;
        useSum: number;
    }

    export interface GetPolicyGroupsListCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        calcType: number;
        calcValue: string;
        continueTime: number;
        metricId: number;
        metricShowName: string;
        metricUnit: string;
        period: number;
        ruleId: number;
    }

    export interface GetPolicyGroupsListEventCondition {
        alarmNotifyPeriod: number;
        alarmNotifyType: number;
        eventId: number;
        eventShowName: string;
        ruleId: number;
    }

    export interface GetPolicyGroupsListReceiver {
        endTime: number;
        needSendNotice: number;
        notifyWays: string[];
        personInterval: number;
        receiveLanguage: string;
        receiverGroupLists: number[];
        receiverType: string;
        receiverUserLists: number[];
        recoverNotifies: string[];
        roundInterval: number;
        roundNumber: number;
        sendFors: string[];
        startTime: number;
        uidLists: number[];
    }

    export interface GetProductEventDimension {
        name?: string;
        value?: string;
    }

    export interface GetProductEventList {
        additionMsgs: outputs.Monitor.GetProductEventListAdditionMsg[];
        dimensions: outputs.Monitor.GetProductEventListDimension[];
        eventCname: string;
        eventEname: string;
        eventId: number;
        eventName: string;
        groupInfos: outputs.Monitor.GetProductEventListGroupInfo[];
        instanceId: string;
        instanceName: string;
        isAlarmConfig: number;
        productCname: string;
        productEname: string;
        productName: string;
        projectId: string;
        region: string;
        startTime: number;
        status: string;
        supportAlarm: number;
        type: string;
        updateTime: number;
    }

    export interface GetProductEventListAdditionMsg {
        key: string;
        name: string;
        value: string;
    }

    export interface GetProductEventListDimension {
        key: string;
        name: string;
        value: string;
    }

    export interface GetProductEventListGroupInfo {
        groupId: string;
        groupName: string;
    }

    export interface GetProductNamespaceList {
        namespace: string;
        productChineseName: string;
        productName: string;
    }

    export interface GrafanaSsoAccountRole {
        organization: string;
        role: string;
    }

    export interface PolicyBindingObjectDimension {
        dimensionsJson: string;
        uniqueId: string;
    }

    export interface TmpAlertRuleAnnotation {
        key: string;
        value: string;
    }

    export interface TmpAlertRuleLabel {
        key: string;
        value: string;
    }

    export interface TmpTkeAlertPolicyAlertRule {
        clusterId?: string;
        id?: string;
        name: string;
        notification?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleNotification;
        rules: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRule[];
        templateId?: string;
        updatedAt?: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleNotification {
        alertManager?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleNotificationAlertManager;
        enabled: boolean;
        notifyWays?: string[];
        phoneArriveNotice?: boolean;
        phoneCircleInterval?: number;
        phoneCircleTimes?: number;
        phoneInnerInterval?: number;
        phoneNotifyOrders?: number[];
        receiverGroups?: string[];
        repeatInterval?: string;
        timeRangeEnd?: string;
        timeRangeStart?: string;
        type: string;
        webHook?: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleNotificationAlertManager {
        clusterId?: string;
        clusterType?: string;
        url: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRule {
        annotations?: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRuleAnnotation[];
        describe?: string;
        for: string;
        labels: outputs.Monitor.TmpTkeAlertPolicyAlertRuleRuleLabel[];
        name: string;
        rule: string;
        ruleState?: number;
        template: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRuleAnnotation {
        name: string;
        value: string;
    }

    export interface TmpTkeAlertPolicyAlertRuleRuleLabel {
        name: string;
        value: string;
    }

    export interface TmpTkeClusterAgentAgents {
        clusterId: string;
        clusterName: string;
        clusterType: string;
        enableExternal: boolean;
        externalLabels?: outputs.Monitor.TmpTkeClusterAgentAgentsExternalLabel[];
        inClusterPodConfig?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfig;
        notInstallBasicScrape?: boolean;
        notScrape?: boolean;
        region: string;
        status: string;
    }

    export interface TmpTkeClusterAgentAgentsExternalLabel {
        name: string;
        value?: string;
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfig {
        hostNet: boolean;
        nodeSelectors?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelector[];
        tolerations?: outputs.Monitor.TmpTkeClusterAgentAgentsInClusterPodConfigToleration[];
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfigNodeSelector {
        name?: string;
        value?: string;
    }

    export interface TmpTkeClusterAgentAgentsInClusterPodConfigToleration {
        effect?: string;
        key?: string;
        operator?: string;
    }

    export interface TmpTkeConfigPodMonitor {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeConfigRawJob {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeConfigServiceMonitor {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeGlobalNotificationNotification {
        alertManagers?: outputs.Monitor.TmpTkeGlobalNotificationNotificationAlertManager[];
        enabled: boolean;
        notifyWays?: string[];
        phoneArriveNotice?: boolean;
        phoneCircleInterval?: number;
        phoneCircleTimes?: number;
        phoneInnerInterval?: number;
        phoneNotifyOrders?: number[];
        receiverGroups?: string[];
        repeatInterval?: string;
        timeRangeEnd?: string;
        timeRangeStart?: string;
        type: string;
        webHook?: string;
    }

    export interface TmpTkeGlobalNotificationNotificationAlertManager {
        clusterId?: string;
        clusterType?: string;
        url: string;
    }

    export interface TmpTkeTemplateAttachmentTargets {
        clusterId?: string;
        clusterName?: string;
        clusterType?: string;
        instanceId: string;
        instanceName?: string;
        region: string;
        syncTime?: string;
        version?: string;
    }

    export interface TmpTkeTemplateTemplate {
        describe: string;
        isDefault?: boolean;
        level: string;
        name: string;
        podMonitors: outputs.Monitor.TmpTkeTemplateTemplatePodMonitor[];
        rawJobs: outputs.Monitor.TmpTkeTemplateTemplateRawJob[];
        recordRules: outputs.Monitor.TmpTkeTemplateTemplateRecordRule[];
        serviceMonitors: outputs.Monitor.TmpTkeTemplateTemplateServiceMonitor[];
        templateId?: string;
        updateTime?: string;
        version?: string;
    }

    export interface TmpTkeTemplateTemplatePodMonitor {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateRawJob {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateRecordRule {
        config: string;
        name: string;
        templateId?: string;
    }

    export interface TmpTkeTemplateTemplateServiceMonitor {
        config: string;
        name: string;
        templateId?: string;
    }

}

export namespace Mps {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        audio: outputs.Mps.AdaptiveDynamicStreamingTemplateStreamInfoAudio;
        removeAudio?: number;
        removeVideo?: number;
        video: outputs.Mps.AdaptiveDynamicStreamingTemplateStreamInfoVideo;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        audioChannel?: number;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        bitrate: number;
        codec: string;
        fillType?: string;
        fps: number;
        gop?: number;
        height?: number;
        resolutionAdaptive?: string;
        vcrf?: number;
        width?: number;
    }

    export interface AiAnalysisTemplateClassificationConfigure {
        switch: string;
    }

    export interface AiAnalysisTemplateCoverConfigure {
        switch: string;
    }

    export interface AiAnalysisTemplateFrameTagConfigure {
        switch: string;
    }

    export interface AiAnalysisTemplateTagConfigure {
        switch: string;
    }

    export interface AiRecognitionTemplateAsrFullTextConfigure {
        subtitleFormat?: string;
        switch: string;
    }

    export interface AiRecognitionTemplateAsrWordsConfigure {
        labelSets?: string[];
        switch: string;
    }

    export interface AiRecognitionTemplateFaceConfigure {
        defaultLibraryLabelSets?: string[];
        faceLibrary?: string;
        score?: number;
        switch: string;
        userDefineLibraryLabelSets?: string[];
    }

    export interface AiRecognitionTemplateOcrFullTextConfigure {
        switch: string;
    }

    export interface AiRecognitionTemplateOcrWordsConfigure {
        labelSets?: string[];
        switch: string;
    }

    export interface TranscodeTemplateAudioTemplate {
        audioChannel?: number;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface TranscodeTemplateEnhanceConfig {
        videoEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhance;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhance {
        artifactRepair?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair;
        colorEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance;
        denoise?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceDenoise;
        faceEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance;
        frameRate?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate;
        hdr?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceHdr;
        imageQualityEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance;
        lowLightEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance;
        scratchRepair?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair;
        sharpEnhance?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance;
        superResolution?: outputs.Mps.TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceArtifactRepair {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceColorEnhance {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceDenoise {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceFaceEnhance {
        intensity?: number;
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceFrameRate {
        fps?: number;
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceHdr {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceImageQualityEnhance {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceLowLightEnhance {
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceScratchRepair {
        intensity?: number;
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceSharpEnhance {
        intensity?: number;
        switch?: string;
    }

    export interface TranscodeTemplateEnhanceConfigVideoEnhanceSuperResolution {
        size?: number;
        switch?: string;
        type?: string;
    }

    export interface TranscodeTemplateTehdConfig {
        maxVideoBitrate?: number;
        type: string;
    }

    export interface TranscodeTemplateVideoTemplate {
        bitrate: number;
        codec: string;
        fillType?: string;
        fps: number;
        gop?: number;
        height?: number;
        resolutionAdaptive?: string;
        vcrf?: number;
        width?: number;
    }

    export interface WatermarkTemplateImageTemplate {
        height?: string;
        imageContent: string;
        repeatType?: string;
        width?: string;
    }

    export interface WatermarkTemplateSvgTemplate {
        height?: string;
        width?: string;
    }

    export interface WatermarkTemplateTextTemplate {
        fontAlpha: number;
        fontColor: string;
        fontSize: string;
        fontType: string;
    }

    export interface WorkflowAiAnalysisTask {
        definition: number;
        extendedParameter?: string;
    }

    export interface WorkflowAiContentReviewTask {
        definition: number;
    }

    export interface WorkflowAiRecognitionTask {
        definition: number;
    }

    export interface WorkflowMediaProcessTask {
        adaptiveDynamicStreamingTaskSets?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet[];
        animatedGraphicTaskSets?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSet[];
        imageSpriteTaskSets?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSet[];
        sampleSnapshotTaskSets?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSet[];
        snapshotByTimeOffsetTaskSets?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet[];
        transcodeTaskSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSet[];
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSet {
        definition: number;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage;
        segmentObjectName?: string;
        subStreamObjectName?: string;
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSet {
        definition: number;
        endTimeOffset?: number;
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameter {
        coordinateOrigin?: string;
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate;
        type: string;
        xPos?: string;
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplate {
        height?: string;
        imageContent: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        repeatType?: string;
        width?: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskAdaptiveDynamicStreamingTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        url: string;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSet {
        definition: number;
        endTimeOffset: number;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage;
        startTimeOffset: number;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskAnimatedGraphicTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSet {
        definition: number;
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage;
        webVttObjectName?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetObjectNumberFormat {
        increment?: number;
        initialValue?: number;
        minLength?: number;
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskImageSpriteTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSet {
        definition: number;
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage;
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetObjectNumberFormat {
        increment?: number;
        initialValue?: number;
        minLength?: number;
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSet {
        definition: number;
        endTimeOffset?: number;
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameter {
        coordinateOrigin?: string;
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate;
        type: string;
        xPos?: string;
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplate {
        height?: string;
        imageContent: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        repeatType?: string;
        width?: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskSampleSnapshotTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        url: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSet {
        definition: number;
        extTimeOffsetSets?: string[];
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage;
        timeOffsetSets?: number[];
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetObjectNumberFormat {
        increment?: number;
        initialValue?: number;
        minLength?: number;
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSet {
        definition: number;
        endTimeOffset?: number;
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameter {
        coordinateOrigin?: string;
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate;
        type: string;
        xPos?: string;
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplate {
        height?: string;
        imageContent: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        repeatType?: string;
        width?: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskSnapshotByTimeOffsetTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSet {
        definition: number;
        endTimeOffset?: number;
        headTailParameter?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter;
        mosaicSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet[];
        objectNumberFormat?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat;
        outputObjectPath?: string;
        outputStorage?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage;
        overrideParameter?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter;
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameter;
        segmentObjectName?: string;
        startTimeOffset?: number;
        watermarkSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameter {
        headSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet[];
        tailSets?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSet {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterHeadSetUrlInputInfo {
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSet {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetHeadTailParameterTailSetUrlInputInfo {
        url: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetMosaicSet {
        coordinateOrigin?: string;
        endTimeOffset?: number;
        height?: string;
        startTimeOffset?: number;
        width?: string;
        xPos?: string;
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetObjectNumberFormat {
        increment?: number;
        initialValue?: number;
        minLength?: number;
        placeHolder?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameter {
        audioTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate;
        container?: string;
        removeAudio?: number;
        removeVideo?: number;
        subtitleTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate;
        tehdConfig?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig;
        videoTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterAudioTemplate {
        audioChannel?: number;
        bitrate?: number;
        codec?: string;
        sampleRate?: number;
        streamSelects?: number[];
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterSubtitleTemplate {
        fontAlpha?: number;
        fontColor?: string;
        fontSize?: string;
        fontType?: string;
        path?: string;
        streamIndex?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterTehdConfig {
        maxVideoBitrate?: number;
        type?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetOverrideParameterVideoTemplate {
        bitrate?: number;
        codec?: string;
        contentAdaptStream?: number;
        fillType?: string;
        fps?: number;
        gop?: number;
        height?: number;
        resolutionAdaptive?: string;
        vcrf?: number;
        width?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameter {
        audioTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate;
        container: string;
        removeAudio?: number;
        removeVideo?: number;
        tehdConfig?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig;
        videoTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterAudioTemplate {
        audioChannel?: number;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterTehdConfig {
        maxVideoBitrate?: number;
        type: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetRawParameterVideoTemplate {
        bitrate: number;
        codec: string;
        fillType?: string;
        fps: number;
        gop?: number;
        height?: number;
        resolutionAdaptive?: string;
        vcrf?: number;
        width?: number;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSet {
        definition: number;
        endTimeOffset?: number;
        rawParameter: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameter {
        coordinateOrigin?: string;
        imageTemplate?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate;
        type: string;
        xPos?: string;
        yPos?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplate {
        height?: string;
        imageContent: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent;
        repeatType?: string;
        width?: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContent {
        cosInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo;
        type: string;
        urlInputInfo?: outputs.Mps.WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentCosInputInfo {
        bucket: string;
        object: string;
        region: string;
    }

    export interface WorkflowMediaProcessTaskTranscodeTaskSetWatermarkSetRawParameterImageTemplateImageContentUrlInputInfo {
        url: string;
    }

    export interface WorkflowOutputStorage {
        cosOutputStorage?: outputs.Mps.WorkflowOutputStorageCosOutputStorage;
        type: string;
    }

    export interface WorkflowOutputStorageCosOutputStorage {
        bucket?: string;
        region?: string;
    }

    export interface WorkflowTaskNotifyConfig {
        cmqModel?: string;
        cmqRegion?: string;
        notifyMode?: string;
        notifyType?: string;
        notifyUrl?: string;
        queueName?: string;
        topicName?: string;
    }

    export interface WorkflowTrigger {
        cosFileUploadTrigger?: outputs.Mps.WorkflowTriggerCosFileUploadTrigger;
        type: string;
    }

    export interface WorkflowTriggerCosFileUploadTrigger {
        bucket: string;
        dir?: string;
        formats: string[];
        region: string;
    }

}

export namespace Mysql {
    export interface AuditLogFileFilter {
        affectRows?: number;
        dbNames?: string[];
        execTime?: number;
        hosts?: string[];
        policyNames?: string[];
        sql?: string;
        sqlType?: string;
        sqlTypes?: string[];
        sqls?: string[];
        tableNames?: string[];
        users?: string[];
    }

    export interface BackupDownloadRestrictionLimitVpc {
        region: string;
        vpcLists: string[];
    }

    export interface GetBackupListList {
        backupId: number;
        backupModel: string;
        creator: string;
        finishTime: string;
        internetUrl: string;
        intranetUrl: string;
        size: number;
        time: string;
    }

    export interface GetBackupSummariesItem {
        autoBackupCount: number;
        autoBackupVolume: number;
        backupVolume: number;
        binlogBackupCount: number;
        binlogBackupVolume: number;
        dataBackupCount: number;
        dataBackupVolume: number;
        instanceId: string;
        manualBackupCount: number;
        manualBackupVolume: number;
    }

    export interface GetBinLogItem {
        binlogFinishTime: string;
        binlogStartTime: string;
        cosStorageType: number;
        date: string;
        instanceId: string;
        internetUrl: string;
        intranetUrl: string;
        name: string;
        region: string;
        remoteInfos: outputs.Mysql.GetBinLogItemRemoteInfo[];
        size: number;
        status: string;
        type: string;
    }

    export interface GetBinLogItemRemoteInfo {
        finishTime: string;
        region: string;
        startTime: string;
        status: string;
        subBackupIds: number[];
        url: string;
    }

    export interface GetCloneListItem {
        cloneJobId: number;
        dstInstanceId: string;
        endTime: string;
        newRegionId: number;
        rollbackStrategy: string;
        rollbackTargetTime: string;
        srcInstanceId: string;
        srcRegionId: number;
        startTime: string;
        taskStatus: string;
    }

    export interface GetDatabasesDatabaseList {
        characterSet: string;
        databaseName: string;
    }

    export interface GetDefaultParamsParamList {
        currentValue: string;
        default: string;
        description: string;
        enumValues: string[];
        max: number;
        min: number;
        name: string;
        needReboot: number;
        paramType: string;
    }

    export interface GetErrorLogItem {
        content: string;
        timestamp: number;
    }

    export interface GetInstanceInstanceList {
        autoRenewFlag: number;
        chargeType: string;
        cpuCoreCount: number;
        createTime: string;
        deadLineTime: string;
        deviceType: string;
        drInstanceIds: string[];
        engineVersion: string;
        initFlag: number;
        instanceName: string;
        instanceRole: string;
        internetHost: string;
        internetPort: number;
        internetStatus: number;
        intranetIp: string;
        intranetPort: number;
        masterInstanceId: string;
        memorySize: number;
        mysqlId: string;
        payType: number;
        projectId: number;
        roGroups: outputs.Mysql.GetInstanceInstanceListRoGroup[];
        roInstanceIds: string[];
        slaveSyncMode: number;
        status: number;
        subnetId: string;
        volumeSize: number;
        vpcId: string;
        zone: string;
    }

    export interface GetInstanceInstanceListRoGroup {
        groupId: string;
        instanceIds: string[];
    }

    export interface GetInstanceParamRecordItem {
        instanceId: string;
        isSuccess: boolean;
        modifyTime: string;
        newValue: string;
        oldValue: string;
        paramName: string;
    }

    export interface GetInstanceRebootTimeItem {
        instanceId: string;
        timeInSeconds: number;
    }

    export interface GetParameterListParameterList {
        currentValue: string;
        defaultValue: string;
        description: string;
        enumValues: string[];
        max: number;
        min: number;
        needReboot: number;
        parameterName: string;
        parameterType: string;
    }

    export interface GetProjectSecurityGroupGroup {
        createTime: string;
        inbounds: outputs.Mysql.GetProjectSecurityGroupGroupInbound[];
        outbounds: outputs.Mysql.GetProjectSecurityGroupGroupOutbound[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupGroupInbound {
        action: string;
        cidrIp: string;
        desc: string;
        dir: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProjectSecurityGroupGroupOutbound {
        action: string;
        cidrIp: string;
        desc: string;
        dir: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProxyCustomCustomConf {
        cpu: number;
        device: string;
        deviceType: string;
        memory: number;
        type: string;
    }

    export interface GetProxyCustomWeightRule {
        lessThan: number;
        weight: number;
    }

    export interface GetRollbackRangeTimeItem {
        code: number;
        instanceId: string;
        message: string;
        times: outputs.Mysql.GetRollbackRangeTimeItemTime[];
    }

    export interface GetRollbackRangeTimeItemTime {
        begin: string;
        end: string;
    }

    export interface GetSlowLogDataItem {
        database: string;
        lockTime: number;
        md5: string;
        queryTime: number;
        rowsExamined: number;
        rowsSent: number;
        sqlTemplate: string;
        sqlText: string;
        timestamp: number;
        userHost: string;
        userName: string;
    }

    export interface GetSlowLogItem {
        date: string;
        internetUrl: string;
        intranetUrl: string;
        name: string;
        size: number;
        type: string;
    }

    export interface GetSwitchRecordItem {
        switchTime: string;
        switchType: string;
    }

    export interface GetUserTaskItem {
        asyncRequestId: string;
        code: number;
        endTime: string;
        instanceIds: string[];
        jobId: number;
        message: string;
        progress: number;
        startTime: string;
        taskStatus: string;
        taskType: string;
    }

    export interface GetZoneConfigList {
        disasterRecoveryZones: string[];
        engineVersions: string[];
        firstSlaveZones: string[];
        hourInstanceSaleMaxNum: number;
        isDefault: number;
        isSupportDisasterRecovery: number;
        isSupportVpc: number;
        name: string;
        payTypes: number[];
        remoteRoZones: string[];
        secondSlaveZones: string[];
        sells: outputs.Mysql.GetZoneConfigListSell[];
        slaveDeployModes: number[];
        supportSlaveSyncModes: number[];
    }

    export interface GetZoneConfigListSell {
        cdbType: string;
        cpu: number;
        info: string;
        maxVolumeSize: number;
        memSize: number;
        minVolumeSize: number;
        qps: number;
        volumeStep: number;
    }

    export interface ParamTemplateParamList {
        currentValue: string;
        name: string;
    }

    export interface PasswordComplexityParamList {
        currentValue?: string;
        name?: string;
    }

    export interface PrivilegeColumn {
        columnName: string;
        databaseName: string;
        privileges: string[];
        tableName: string;
    }

    export interface PrivilegeDatabase {
        databaseName: string;
        privileges: string[];
    }

    export interface PrivilegeTable {
        databaseName: string;
        privileges: string[];
        tableName: string;
    }

    export interface ProxyProxyNodeCustom {
        cpu: number;
        mem: number;
        nodeCount: number;
        region: string;
        zone: string;
    }

    export interface RoGroupRoGroupInfo {
        minRoInGroup?: number;
        replicationDelayTime?: number;
        roGroupName?: string;
        roMaxDelayTime?: number;
        roOfflineDelay?: number;
        weightMode?: string;
    }

    export interface RoGroupRoWeightValue {
        instanceId: string;
        weight: number;
    }

    export interface RollbackDatabase {
        databaseName: string;
        newDatabaseName: string;
    }

    export interface RollbackTable {
        database: string;
        tables: outputs.Mysql.RollbackTableTable[];
    }

    export interface RollbackTableTable {
        newTableName: string;
        tableName: string;
    }

}

export namespace Nat {
    export interface GetDcRouteNatDirectConnectGatewayRouteSet {
        createTime: string;
        destinationCidrBlock: string;
        gatewayId: string;
        gatewayType: string;
        updateTime: string;
    }

    export interface GetGatewaySnatsSnatList {
        createTime: string;
        description: string;
        instanceId?: string;
        instancePrivateIpAddr?: string;
        natGatewayId: string;
        publicIpAddrs: string[];
        resourceType: string;
        snatId: string;
        subnetCidrBlock?: string;
        subnetId?: string;
    }

    export interface GetGatewaysNat {
        assignedEipSets: string[];
        bandwidth: number;
        createTime: string;
        id: string;
        maxConcurrent: number;
        name: string;
        state: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

}

export namespace Organization {
    export interface OrgMemberOrgPermission {
        id: number;
        name: string;
    }

}

export namespace Placement {
    export interface GetGroupsPlacementGroupList {
        createTime: string;
        currentNum: number;
        cvmQuotaTotal: number;
        instanceIds: string[];
        name: string;
        placementGroupId: string;
        type: string;
    }

}

export namespace Postgresql {
    export interface GetBackupDownloadUrlsBackupDownloadRestriction {
        ipRestrictionEffect?: string;
        ipSets?: string[];
        restrictionType?: string;
        vpcIdSets?: string[];
        vpcRestrictionEffect?: string;
    }

    export interface GetBaseBackupsBaseBackupSet {
        backupMethod: string;
        backupMode: string;
        dbInstanceId: string;
        expireTime: string;
        finishTime: string;
        id: string;
        name: string;
        size: number;
        startTime: string;
        state: string;
    }

    export interface GetBaseBackupsFilter {
        name?: string;
        values?: string[];
    }

    export interface GetDbInstanceClassesClassInfoSet {
        cpu: number;
        maxStorage: number;
        memory: number;
        minStorage: number;
        qps: number;
        specCode: string;
    }

    export interface GetDbInstanceVersionsVersionSet {
        availableUpgradeTargets: string[];
        dbEngine: string;
        dbKernelVersion: string;
        dbMajorVersion: string;
        dbVersion: string;
        status: string;
        supportedFeatureNames: string[];
    }

    export interface GetDefaultParametersParamInfoSet {
        advanced: boolean;
        classificationCn: string;
        classificationEn: string;
        currentValue: string;
        defaultValue: string;
        enumValues: string[];
        id: number;
        lastModifyTime: string;
        max: number;
        min: number;
        name: string;
        needReboot: boolean;
        paramDescriptionCh: string;
        paramDescriptionEn: string;
        paramValueType: string;
        specRelated: boolean;
        specRelationSets: outputs.Postgresql.GetDefaultParametersParamInfoSetSpecRelationSet[];
        standbyRelated: number;
        unit: string;
        versionRelationSets: outputs.Postgresql.GetDefaultParametersParamInfoSetVersionRelationSet[];
    }

    export interface GetDefaultParametersParamInfoSetSpecRelationSet {
        enumValues: string[];
        max: number;
        memory: string;
        min: number;
        name: string;
        unit: string;
        value: string;
    }

    export interface GetDefaultParametersParamInfoSetVersionRelationSet {
        dbKernelVersion: string;
        enumValues: string[];
        max: number;
        min: number;
        name: string;
        unit: string;
        value: string;
    }

    export interface GetInstancesInstanceList {
        autoRenewFlag: number;
        availabilityZone: string;
        chargeType: string;
        charset: string;
        createTime: string;
        engineVersion: string;
        id: string;
        memory: number;
        name: string;
        privateAccessIp: string;
        privateAccessPort: number;
        projectId: number;
        publicAccessHost: string;
        publicAccessPort: number;
        publicAccessSwitch: boolean;
        rootUser: string;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetLogBackupsFilter {
        name?: string;
        values?: string[];
    }

    export interface GetLogBackupsLogBackupSet {
        backupMethod: string;
        backupMode: string;
        dbInstanceId: string;
        expireTime: string;
        finishTime: string;
        id: string;
        name: string;
        size: number;
        startTime: string;
        state: string;
    }

    export interface GetParameterTemplatesFilter {
        name?: string;
        values?: string[];
    }

    export interface GetParameterTemplatesList {
        dbEngine: string;
        dbMajorVersion: string;
        templateDescription: string;
        templateId: string;
        templateName: string;
    }

    export interface GetReadonlyGroupsFilter {
        name?: string;
        values?: string[];
    }

    export interface GetReadonlyGroupsReadOnlyGroupList {
        dbInstanceNetInfos: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListDbInstanceNetInfo[];
        masterDbInstanceId: string;
        maxReplayLag: number;
        maxReplayLatency: number;
        minDelayEliminateReserve: number;
        networkAccessLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListNetworkAccessList[];
        projectId: number;
        readOnlyDbInstanceLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceList[];
        readOnlyGroupId: string;
        readOnlyGroupName: string;
        rebalance: number;
        region: string;
        replayLagEliminate: number;
        replayLatencyEliminate: number;
        status: string;
        subnetId: string;
        vpcId: string;
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListDbInstanceNetInfo {
        address: string;
        ip: string;
        netType: string;
        port: number;
        protocolType: string;
        status: string;
        subnetId: string;
        vpcId: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListNetworkAccessList {
        resourceId: string;
        resourceType: number;
        subnetId: string;
        vip: string;
        vip6: string;
        vpcId: string;
        vpcStatus: number;
        vport: number;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceList {
        appId: number;
        autoRenew: number;
        createTime: string;
        dbCharset: string;
        dbEngine: string;
        dbEngineConfig: string;
        dbInstanceClass: string;
        dbInstanceCpu: number;
        dbInstanceId: string;
        dbInstanceMemory: number;
        dbInstanceName: string;
        dbInstanceNetInfos: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbInstanceNetInfo[];
        dbInstanceStatus: string;
        dbInstanceStorage: number;
        dbInstanceType: string;
        dbInstanceVersion: string;
        dbKernelVersion: string;
        dbMajorVersion: string;
        dbNodeSets: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbNodeSet[];
        dbVersion: string;
        expireTime: string;
        isSupportTDE: number;
        isolatedTime: string;
        masterDbInstanceId: string;
        networkAccessLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListNetworkAccessList[];
        offlineTime: string;
        payType: string;
        projectId: number;
        readOnlyInstanceNum: number;
        region: string;
        statusInReadonlyGroup: string;
        subnetId: string;
        supportIpv6: number;
        tagLists: outputs.Postgresql.GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListTagList[];
        type: string;
        uid: number;
        updateTime: string;
        vpcId: string;
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbInstanceNetInfo {
        address: string;
        ip: string;
        netType: string;
        port: number;
        protocolType: string;
        status: string;
        subnetId: string;
        vpcId: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListDbNodeSet {
        role: string;
        zone: string;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListNetworkAccessList {
        resourceId: string;
        resourceType: number;
        subnetId: string;
        vip: string;
        vip6: string;
        vpcId: string;
        vpcStatus: number;
        vport: number;
    }

    export interface GetReadonlyGroupsReadOnlyGroupListReadOnlyDbInstanceListTagList {
        tagKey: string;
        tagValue: string;
    }

    export interface GetRegionsRegionSet {
        region: string;
        regionId: number;
        regionName: string;
        regionState: string;
        supportInternational: number;
    }

    export interface GetSpecinfosList {
        cpu: number;
        engineVersion: string;
        engineVersionName: string;
        id: string;
        memory: number;
        qps: number;
        storageMax: number;
        storageMin: number;
    }

    export interface GetXlogsList {
        endTime: string;
        externalAddr: string;
        id: number;
        internalAddr: string;
        size: number;
        startTime: string;
    }

    export interface GetZonesZoneSet {
        standbyZoneSets: string[];
        zone: string;
        zoneId: number;
        zoneName: string;
        zoneState: string;
        zoneSupportIpv6: number;
    }

    export interface InstanceBackupPlan {
        backupPeriods?: string[];
        baseBackupRetentionPeriod?: number;
        maxBackupStartTime?: string;
        minBackupStartTime?: string;
    }

    export interface InstanceDbNodeSet {
        role?: string;
        zone: string;
    }

    export interface ParameterTemplateModifyParamEntrySet {
        expectedValue: string;
        name: string;
    }

}

export namespace PrivateDns {
    export interface GetRecordsFilter {
        name: string;
        values: string[];
    }

    export interface GetRecordsRecordSet {
        createdOn: string;
        enabled: number;
        extra: string;
        mx: number;
        recordId: string;
        recordType: string;
        recordValue: string;
        status: string;
        subDomain: string;
        ttl: number;
        updatedOn: string;
        weight: number;
        zoneId: string;
    }

    export interface ZoneAccountVpcSet {
        region: string;
        uin: string;
        uniqVpcId: string;
        vpcName: string;
    }

    export interface ZoneTagSet {
        tagKey: string;
        tagValue: string;
    }

    export interface ZoneVpcSet {
        region: string;
        uniqVpcId: string;
    }

}

export namespace Projects {
    export interface GetProjectsProject {
        createTime: string;
        creatorUin: number;
        projectId: number;
        projectInfo: string;
        projectName: string;
    }

}

export namespace Protocol {
    export interface GetTemplateGroupsGroupList {
        id: string;
        name: string;
        templateIds: string[];
    }

    export interface GetTemplatesTemplateList {
        id: string;
        name: string;
        protocols: string[];
    }

}

export namespace Pts {
    export interface FileFileInfo {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface JobDataset {
        fileId?: string;
        headLines?: string[];
        headerColumns?: string[];
        headerInFile: boolean;
        lineCount?: number;
        name: string;
        size?: number;
        split: boolean;
        tailLines?: string[];
        type?: string;
        updatedAt?: string;
    }

    export interface JobDomainNameConfig {
        dnsConfig?: outputs.Pts.JobDomainNameConfigDnsConfig;
        hostAliases?: outputs.Pts.JobDomainNameConfigHostAlias[];
    }

    export interface JobDomainNameConfigDnsConfig {
        nameservers?: string[];
    }

    export interface JobDomainNameConfigHostAlias {
        hostNames?: string[];
        ip?: string;
    }

    export interface JobLoad {
        geoRegionsLoadDistributions?: outputs.Pts.JobLoadGeoRegionsLoadDistribution[];
        loadSpec?: outputs.Pts.JobLoadLoadSpec;
        vpcLoadDistribution?: outputs.Pts.JobLoadVpcLoadDistribution;
    }

    export interface JobLoadGeoRegionsLoadDistribution {
        percentage?: number;
        region?: string;
        regionId: number;
    }

    export interface JobLoadLoadSpec {
        concurrency?: outputs.Pts.JobLoadLoadSpecConcurrency;
        requestsPerSecond?: outputs.Pts.JobLoadLoadSpecRequestsPerSecond;
        scriptOrigin?: outputs.Pts.JobLoadLoadSpecScriptOrigin;
    }

    export interface JobLoadLoadSpecConcurrency {
        gracefulStopSeconds?: number;
        iterationCount?: number;
        maxRequestsPerSecond?: number;
        stages?: outputs.Pts.JobLoadLoadSpecConcurrencyStage[];
    }

    export interface JobLoadLoadSpecConcurrencyStage {
        durationSeconds?: number;
        targetVirtualUsers?: number;
    }

    export interface JobLoadLoadSpecRequestsPerSecond {
        durationSeconds?: number;
        gracefulStopSeconds?: number;
        maxRequestsPerSecond?: number;
        resources?: number;
        startRequestsPerSecond?: number;
        targetRequestsPerSecond?: number;
    }

    export interface JobLoadLoadSpecScriptOrigin {
        durationSeconds: number;
        machineNumber: number;
        machineSpecification: string;
    }

    export interface JobLoadVpcLoadDistribution {
        region?: string;
        regionId: number;
        subnetIds?: string[];
        vpcId?: string;
    }

    export interface JobPlugin {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface JobProtocol {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface JobRequestFile {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface JobTestScript {
        encodedContent?: string;
        encodedHttpArchive?: string;
        loadWeight?: number;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface ProjectTag {
        tagKey?: string;
        tagValue?: string;
    }

    export interface ScenarioDataset {
        fileId?: string;
        headLines?: string[];
        headerColumns?: string[];
        headerInFile: boolean;
        lineCount?: number;
        name: string;
        size?: number;
        split: boolean;
        tailLines?: string[];
        type?: string;
        updatedAt?: string;
    }

    export interface ScenarioDomainNameConfig {
        dnsConfig?: outputs.Pts.ScenarioDomainNameConfigDnsConfig;
        hostAliases?: outputs.Pts.ScenarioDomainNameConfigHostAlias[];
    }

    export interface ScenarioDomainNameConfigDnsConfig {
        nameservers?: string[];
    }

    export interface ScenarioDomainNameConfigHostAlias {
        hostNames?: string[];
        ip?: string;
    }

    export interface ScenarioLoad {
        geoRegionsLoadDistributions?: outputs.Pts.ScenarioLoadGeoRegionsLoadDistribution[];
        loadSpec?: outputs.Pts.ScenarioLoadLoadSpec;
        vpcLoadDistribution?: outputs.Pts.ScenarioLoadVpcLoadDistribution;
    }

    export interface ScenarioLoadGeoRegionsLoadDistribution {
        percentage?: number;
        region?: string;
        regionId: number;
    }

    export interface ScenarioLoadLoadSpec {
        concurrency?: outputs.Pts.ScenarioLoadLoadSpecConcurrency;
        requestsPerSecond?: outputs.Pts.ScenarioLoadLoadSpecRequestsPerSecond;
        scriptOrigin?: outputs.Pts.ScenarioLoadLoadSpecScriptOrigin;
    }

    export interface ScenarioLoadLoadSpecConcurrency {
        gracefulStopSeconds?: number;
        iterationCount?: number;
        maxRequestsPerSecond?: number;
        stages?: outputs.Pts.ScenarioLoadLoadSpecConcurrencyStage[];
    }

    export interface ScenarioLoadLoadSpecConcurrencyStage {
        durationSeconds?: number;
        targetVirtualUsers?: number;
    }

    export interface ScenarioLoadLoadSpecRequestsPerSecond {
        durationSeconds?: number;
        gracefulStopSeconds?: number;
        maxRequestsPerSecond?: number;
        resources?: number;
        startRequestsPerSecond?: number;
        targetRequestsPerSecond?: number;
    }

    export interface ScenarioLoadLoadSpecScriptOrigin {
        durationSeconds: number;
        machineNumber: number;
        machineSpecification: string;
    }

    export interface ScenarioLoadVpcLoadDistribution {
        region?: string;
        regionId: number;
        subnetIds?: string[];
        vpcId?: string;
    }

    export interface ScenarioPlugin {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface ScenarioProtocol {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface ScenarioRequestFile {
        fileId?: string;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

    export interface ScenarioSlaPolicy {
        alertChannel?: outputs.Pts.ScenarioSlaPolicyAlertChannel;
        slaRules?: outputs.Pts.ScenarioSlaPolicySlaRule[];
    }

    export interface ScenarioSlaPolicyAlertChannel {
        ampConsumerId?: string;
        noticeId?: string;
    }

    export interface ScenarioSlaPolicySlaRule {
        abortFlag?: boolean;
        aggregation?: string;
        condition?: string;
        for?: string;
        labelFilters?: outputs.Pts.ScenarioSlaPolicySlaRuleLabelFilter[];
        metric?: string;
        value?: number;
    }

    export interface ScenarioSlaPolicySlaRuleLabelFilter {
        labelName?: string;
        labelValue?: string;
    }

    export interface ScenarioTestScript {
        encodedContent?: string;
        encodedHttpArchive?: string;
        loadWeight?: number;
        name?: string;
        size?: number;
        type?: string;
        updatedAt?: string;
    }

}

export namespace Redis {
    export interface BackupDownloadRestrictionLimitVpc {
        region: string;
        vpcLists: string[];
    }

    export interface GetBackupBackupSet {
        backupId: string;
        backupSize: number;
        backupType: string;
        endTime: string;
        expireTime: string;
        fileType: string;
        fullBackup: number;
        instanceId: string;
        instanceName: string;
        instanceType: number;
        locked: number;
        region: string;
        remark: string;
        startTime: string;
        status: number;
    }

    export interface GetBackupDownloadInfoBackupInfo {
        downloadUrl: string;
        fileName: string;
        fileSize: number;
        innerDownloadUrl: string;
    }

    export interface GetBackupDownloadInfoLimitVpc {
        region: string;
        vpcLists: string[];
    }

    export interface GetInstanceNodeInfoProxy {
        nodeId: string;
        zoneId: number;
    }

    export interface GetInstanceNodeInfoRedi {
        clusterId: number;
        nodeId: string;
        nodeRole: string;
        zoneId: number;
    }

    export interface GetInstanceShardsInstanceShard {
        connected: number;
        keys: number;
        role: number;
        runid: string;
        shardId: string;
        shardName: string;
        slots: string;
        storage: number;
        storageSlope: number;
    }

    export interface GetInstanceTaskListTask {
        endTime: string;
        instanceId: string;
        instanceName: string;
        progress: number;
        projectId: number;
        result: number;
        startTime: string;
        taskId: number;
        taskType: string;
    }

    export interface GetInstanceZoneInfoReplicaGroup {
        groupId: number;
        groupName: string;
        redisNodes: outputs.Redis.GetInstanceZoneInfoReplicaGroupRedisNode[];
        role: string;
        zoneId: string;
    }

    export interface GetInstanceZoneInfoReplicaGroupRedisNode {
        keys: number;
        nodeId: string;
        role: string;
        slot: string;
        status: string;
    }

    export interface GetInstancesInstanceList {
        chargeType: string;
        createTime: string;
        ip: string;
        memSize: number;
        name: string;
        nodeInfos: outputs.Redis.GetInstancesInstanceListNodeInfo[];
        port: number;
        projectId: number;
        redisId: string;
        redisReplicasNum: number;
        redisShardNum: number;
        status: string;
        subnetId: string;
        tags: {[key: string]: any};
        /**
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        typeId: number;
        vpcId: string;
        zone: string;
    }

    export interface GetInstancesInstanceListNodeInfo {
        id: number;
        master: boolean;
        zoneId: number;
    }

    export interface GetParamRecordsInstanceParamHistory {
        modifyTime: string;
        newValue: string;
        paramName: string;
        preValue: string;
        status: number;
    }

    export interface GetZoneConfigList {
        /**
         * @deprecated It has been deprecated from version 1.26.0. Use `shard_memories` instead.
         */
        memSizes: number[];
        redisReplicasNums: number[];
        redisShardNums: number[];
        shardMemories: number[];
        /**
         * @deprecated It has been deprecated from version 1.33.1. Please use 'type_id' instead.
         */
        type: string;
        typeId: number;
        version: string;
        zone: string;
    }

    export interface InstanceNodeInfo {
        id: number;
        master: boolean;
        zoneId: number;
    }

    export interface ParamTemplateParamDetail {
        currentValue: string;
        default: string;
        description: string;
        enumValues: string[];
        max: string;
        min: string;
        name: string;
        needReboot: number;
        paramType: string;
    }

    export interface ParamTemplateParamsOverride {
        key: string;
        value: string;
    }

}

export namespace Reserved {
    export interface GetInstanceConfigsConfigList {
        availabilityZone: string;
        configId: string;
        currencyCode: string;
        duration: number;
        instanceType: string;
        offeringType: string;
        platform: string;
        price: number;
        usagePrice: number;
    }

    export interface GetInstancesReservedInstanceList {
        availabilityZone: string;
        endTime: string;
        instanceCount: number;
        instanceType: string;
        reservedInstanceId: string;
        startTime: string;
        status: string;
    }

}

export namespace Rum {
    export interface GetProjectProjectSet {
        createTime: string;
        creator: string;
        desc: string;
        enableUrlGroup: number;
        instanceId: string;
        instanceKey: string;
        instanceName: string;
        isStar: number;
        key: string;
        name: string;
        pid: number;
        projectStatus: number;
        rate: string;
        repo: string;
        type: string;
        url: string;
    }

    export interface GetTawInstanceInstanceSet {
        areaId: number;
        chargeStatus: number;
        chargeType: number;
        clusterId: number;
        createdAt: string;
        dataRetentionDays: number;
        instanceDesc: string;
        instanceId: string;
        instanceName: string;
        instanceStatus: number;
        tags: outputs.Rum.GetTawInstanceInstanceSetTag[];
        updatedAt: string;
    }

    export interface GetTawInstanceInstanceSetTag {
        key: string;
        value: string;
    }

    export interface GetWhitelistWhitelistSet {
        aid: string;
        createTime: string;
        createUser: string;
        remark: string;
        ttl: string;
        whitelistUin: string;
        wid: string;
    }

}

export namespace Scf {
    export interface FunctionAliasRoutingConfig {
        additionalVersionMatches?: outputs.Scf.FunctionAliasRoutingConfigAdditionalVersionMatch[];
        additionalVersionWeights?: outputs.Scf.FunctionAliasRoutingConfigAdditionalVersionWeight[];
    }

    export interface FunctionAliasRoutingConfigAdditionalVersionMatch {
        expression: string;
        key: string;
        method: string;
        version: string;
    }

    export interface FunctionAliasRoutingConfigAdditionalVersionWeight {
        version: string;
        weight: number;
    }

    export interface FunctionCfsConfig {
        cfsId: string;
        ipAddress: string;
        localMountDir: string;
        mountInsId: string;
        mountSubnetId: string;
        mountVpcId: string;
        remoteMountDir: string;
        userGroupId: string;
        userId: string;
    }

    export interface FunctionEventInvokeConfigAsyncTriggerConfig {
        msgTtl: number;
        retryConfigs: outputs.Scf.FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig[];
    }

    export interface FunctionEventInvokeConfigAsyncTriggerConfigRetryConfig {
        retryNum: number;
    }

    export interface FunctionImageConfig {
        args?: string;
        command?: string;
        entryPoint?: string;
        imageType: string;
        imageUri: string;
        registryId?: string;
    }

    export interface FunctionLayer {
        layerName: string;
        layerVersion: number;
    }

    export interface FunctionTrigger {
        cosRegion?: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface FunctionTriggerInfo {
        createTime: string;
        customArgument: string;
        enable: boolean;
        modifyTime: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface GetAccountInfoAccountLimit {
        namespaces: outputs.Scf.GetAccountInfoAccountLimitNamespace[];
        namespacesCount: number;
    }

    export interface GetAccountInfoAccountLimitNamespace {
        concurrentExecutions: number;
        functionsCount: number;
        initTimeoutLimit: number;
        maxMsgTtl: number;
        minMsgTtl: number;
        namespace: string;
        retryNumLimit: number;
        testModelLimit: number;
        timeoutLimit: number;
        triggers: outputs.Scf.GetAccountInfoAccountLimitNamespaceTrigger[];
    }

    export interface GetAccountInfoAccountLimitNamespaceTrigger {
        apigw: number;
        ckafka: number;
        clb: number;
        cls: number;
        cm: number;
        cmq: number;
        cos: number;
        eb: number;
        mps: number;
        timer: number;
        total: number;
        vod: number;
    }

    export interface GetAccountInfoAccountUsage {
        namespaces: outputs.Scf.GetAccountInfoAccountUsageNamespace[];
        namespacesCount: number;
        totalAllocatedConcurrencyMem: number;
        totalConcurrencyMem: number;
        userConcurrencyMemLimit: number;
    }

    export interface GetAccountInfoAccountUsageNamespace {
        functions: string[];
        functionsCount: number;
        namespace: string;
        totalAllocatedConcurrencyMem: number;
        totalAllocatedProvisionedMem: number;
        totalConcurrencyMem: number;
    }

    export interface GetAsyncEventManagementEventList {
        endTime: string;
        invokeRequestId: string;
        invokeType: string;
        qualifier: string;
        startTime: string;
        status: string;
    }

    export interface GetAsyncEventStatusResult {
        invokeRequestId: string;
        status: string;
        statusCode: number;
    }

    export interface GetFunctionAliasesAlias {
        addTime: string;
        description: string;
        functionVersion: string;
        modTime: string;
        name: string;
        routingConfigs: outputs.Scf.GetFunctionAliasesAliasRoutingConfig[];
    }

    export interface GetFunctionAliasesAliasRoutingConfig {
        additionVersionMatchs: outputs.Scf.GetFunctionAliasesAliasRoutingConfigAdditionVersionMatch[];
        additionalVersionWeights: outputs.Scf.GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeight[];
    }

    export interface GetFunctionAliasesAliasRoutingConfigAdditionVersionMatch {
        expression: string;
        key: string;
        method: string;
        version: string;
    }

    export interface GetFunctionAliasesAliasRoutingConfigAdditionalVersionWeight {
        version: string;
        weight: number;
    }

    export interface GetFunctionVersionsVersion {
        addTime: string;
        description: string;
        modTime: string;
        status: string;
        version: string;
    }

    export interface GetFunctionsFunction {
        clsLogsetId: string;
        clsTopicId: string;
        codeError: string;
        codeResult: string;
        codeSize: number;
        createTime: string;
        description: string;
        eipFixed: boolean;
        eips: string[];
        enableEipConfig: boolean;
        enablePublicNet: boolean;
        environment: {[key: string]: any};
        errNo: number;
        handler: string;
        host: string;
        installDependency: boolean;
        l5Enable: boolean;
        memSize: number;
        modifyTime: string;
        name: string;
        namespace: string;
        role: string;
        runtime: string;
        status: string;
        statusDesc: string;
        subnetId: string;
        tags: {[key: string]: any};
        timeout: number;
        triggerInfos: outputs.Scf.GetFunctionsFunctionTriggerInfo[];
        vip: string;
        vpcId: string;
    }

    export interface GetFunctionsFunctionTriggerInfo {
        createTime: string;
        customArgument: string;
        enable: boolean;
        modifyTime: string;
        name: string;
        triggerDesc: string;
        type: string;
    }

    export interface GetLayerVersionsLayerVersion {
        addTime: string;
        compatibleRuntimes: string[];
        description: string;
        layerName: string;
        layerVersion: number;
        licenseInfo: string;
        stamp: string;
        status: string;
    }

    export interface GetLayersLayer {
        addTime: string;
        compatibleRuntimes: string[];
        description: string;
        layerName: string;
        layerVersion: number;
        licenseInfo: string;
        stamp: string;
        status: string;
    }

    export interface GetLogsLog {
        billDuration: number;
        duration: number;
        functionName: string;
        invokeFinished: number;
        level: string;
        log: string;
        memUsage: number;
        requestId: string;
        retCode: number;
        retMsg: string;
        source: string;
        startTime: string;
    }

    export interface GetNamespacesNamespace {
        createTime: string;
        description: string;
        modifyTime: string;
        namespace: string;
        type: string;
    }

    export interface GetRequestStatusData {
        duration: number;
        functionName: string;
        memUsage: number;
        requestId: string;
        retCode: number;
        retMsg: string;
        retryNum: number;
        startTime: string;
    }

    export interface GetTriggersFilter {
        name: string;
        values: string[];
    }

    export interface GetTriggersTrigger {
        addTime: string;
        availableStatus: string;
        bindStatus: string;
        customArgument: string;
        enable: number;
        modTime: string;
        qualifier: string;
        resourceId: string;
        triggerAttribute: string;
        triggerDesc: string;
        triggerName: string;
        type: string;
    }

    export interface LayerContent {
        cosBucketName?: string;
        cosBucketRegion?: string;
        cosObjectName?: string;
        zipFile?: string;
    }

    export interface ProvisionedConcurrencyConfigTriggerAction {
        provisionedType?: string;
        triggerCronConfig: string;
        triggerName: string;
        triggerProvisionedConcurrencyNum: number;
    }

}

export namespace Security {
    export interface GetGroupsSecurityGroup {
        beAssociateCount: number;
        createTime: string;
        description: string;
        egresses: string[];
        ingresses: string[];
        name: string;
        projectId: number;
        securityGroupId: string;
        tags: {[key: string]: any};
    }

    export interface GroupRuleSetEgress {
        action: string;
        addressTemplateGroup?: string;
        addressTemplateId?: string;
        cidrBlock?: string;
        description?: string;
        ipv6CidrBlock?: string;
        policyIndex: number;
        port: string;
        protocol: string;
        serviceTemplateGroup?: string;
        serviceTemplateId?: string;
        sourceSecurityId?: string;
    }

    export interface GroupRuleSetIngress {
        action: string;
        addressTemplateGroup?: string;
        addressTemplateId?: string;
        cidrBlock?: string;
        description?: string;
        ipv6CidrBlock?: string;
        policyIndex: number;
        port: string;
        protocol: string;
        serviceTemplateGroup?: string;
        serviceTemplateId?: string;
        sourceSecurityId?: string;
    }

}

export namespace Ses {
    export interface TemplateTemplateContent {
        html?: string;
        text?: string;
    }

}

export namespace Sqlserver {
    export interface BusinessIntelligenceInstanceResourceTag {
        tagKey?: string;
        tagValue?: string;
    }

    export interface ConfigInstanceParamParamList {
        currentValue?: string;
        name?: string;
    }

    export interface ConfigInstanceRoGroupWeightPair {
        readOnlyInstanceId: string;
        readOnlyWeight: number;
    }

    export interface GeneralCloudInstanceResourceTag {
        tagKey?: string;
        tagValue?: string;
    }

    export interface GetAccountDbAttachmentsList {
        accountName: string;
        dbName: string;
        instanceId: string;
        privilege: string;
    }

    export interface GetAccountsList {
        createTime: string;
        instanceId: string;
        name: string;
        remark: string;
        status: number;
        updateTime: string;
    }

    export interface GetBackupCommandsList {
        command: string;
        requestId: string;
    }

    export interface GetBackupUploadSizeCosUploadBackupFileSet {
        fileName: string;
        size: number;
    }

    export interface GetBackupsList {
        dbLists: string[];
        endTime: string;
        fileName: string;
        id: string;
        instanceId: string;
        internetUrl: string;
        intranetUrl: string;
        size: number;
        startTime: string;
        status: number;
        strategy: number;
        triggerModel: number;
    }

    export interface GetBasicInstancesInstanceList {
        availabilityZone: string;
        chargeType: string;
        cpu: number;
        createTime: string;
        engineVersion: string;
        id: string;
        memory: number;
        name: string;
        projectId: number;
        status: number;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        usedStorage: number;
        vip: string;
        vpcId: string;
        vport: number;
    }

    export interface GetDbsDbList {
        charset: string;
        createTime: string;
        instanceId: string;
        name: string;
        remark: string;
        status: string;
    }

    export interface GetInsAttributeTdeConfig {
        certificateAttribution: string;
        encryption: string;
        quoteUin: string;
    }

    export interface GetInstanceParamRecordsItem {
        instanceId: string;
        modifyTime: string;
        newValue: string;
        oldValue: string;
        paramName: string;
        status: number;
    }

    export interface GetInstancesInstanceList {
        availabilityZone: string;
        chargeType: string;
        createTime: string;
        engineVersion: string;
        haType: string;
        id: string;
        memory: number;
        name: string;
        projectId: number;
        roFlag: string;
        status: number;
        storage: number;
        subnetId: string;
        tags: {[key: string]: any};
        usedStorage: number;
        vip: string;
        vpcId: string;
        vport: number;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSet {
        createTime: string;
        inboundSets: outputs.Sqlserver.GetProjectSecurityGroupsSecurityGroupSetInboundSet[];
        outboundSets: outputs.Sqlserver.GetProjectSecurityGroupsSecurityGroupSetOutboundSet[];
        projectId: number;
        securityGroupId: string;
        securityGroupName: string;
        securityGroupRemark: string;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSetInboundSet {
        action: string;
        cidrIp: string;
        dir: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetProjectSecurityGroupsSecurityGroupSetOutboundSet {
        action: string;
        cidrIp: string;
        dir: string;
        ipProtocol: string;
        portRange: string;
    }

    export interface GetPublishSubscribesPublishSubscribeList {
        databaseTuples: outputs.Sqlserver.GetPublishSubscribesPublishSubscribeListDatabaseTuple[];
        publishInstanceId: string;
        publishInstanceIp: string;
        publishInstanceName: string;
        publishSubscribeId: number;
        publishSubscribeName: string;
        subscribeInstanceId: string;
        subscribeInstanceIp: string;
        subscribeInstanceName: string;
    }

    export interface GetPublishSubscribesPublishSubscribeListDatabaseTuple {
        lastSyncTime: string;
        publishDatabase: string;
        status: string;
        subscribeDatabase: string;
    }

    export interface GetQueryXeventEvent {
        endTime: string;
        eventType: string;
        externalAddr: string;
        fileName: string;
        id: number;
        internalAddr: string;
        size: number;
        startTime: string;
        status: number;
    }

    export interface GetReadonlyGroupsList {
        id: string;
        isOfflineDelay: number;
        masterInstanceId: string;
        maxDelayTime: number;
        minInstances: number;
        name: string;
        readonlyInstanceSets: string[];
        status: number;
        vip: string;
        vport: number;
    }

    export interface GetRegionsRegionSet {
        region: string;
        regionId: number;
        regionName: string;
        regionState: string;
    }

    export interface GetRollbackTimeDetail {
        dbName: string;
        endTime: string;
        startTime: string;
    }

    export interface GetSlowlogsSlowlog {
        count: number;
        endTime: string;
        externalAddr: string;
        id: number;
        internalAddr: string;
        size: number;
        startTime: string;
        status: number;
    }

    export interface GetZoneConfigZoneList {
        availabilityZone: string;
        specinfoLists: outputs.Sqlserver.GetZoneConfigZoneListSpecinfoList[];
        zoneId: number;
    }

    export interface GetZoneConfigZoneListSpecinfoList {
        chargeType: string;
        cpu: number;
        dbVersion: string;
        dbVersionName: string;
        machineType: string;
        maxStorageSize: number;
        memory: number;
        minStorageSize: number;
        qps: number;
        specId: number;
    }

    export interface MigrationMigrateDbSet {
        dbName?: string;
    }

    export interface MigrationRenameRestore {
        newName?: string;
        oldName?: string;
    }

    export interface MigrationSource {
        cvmId?: string;
        instanceId?: string;
        ip?: string;
        password?: string;
        port?: number;
        subnetId?: string;
        urlPassword?: string;
        urls?: string[];
        userName?: string;
        vpcId: string;
    }

    export interface MigrationTarget {
        instanceId?: string;
        password?: string;
        userName?: string;
    }

    export interface PublishSubscribeDatabaseTuple {
        publishDatabase: string;
        subscribeDatabase: string;
    }

    export interface RestoreInstanceEncryption {
        dbName: string;
        status: string;
    }

    export interface RestoreInstanceRenameRestore {
        newName: string;
        oldName: string;
    }

    export interface RollbackInstanceEncryption {
        dbName: string;
        status: string;
    }

    export interface RollbackInstanceRenameRestore {
        newName: string;
        oldName: string;
    }

    export interface StartXeventEventConfig {
        eventType: string;
        threshold: number;
    }

}

export namespace Ssl {
    export interface FreeCertificateDvAuth {
        dvAuthKey: string;
        dvAuthValue: string;
        dvAuthVerifyType: string;
    }

    export interface GetCertificatesCertificate {
        beginTime: string;
        cert: string;
        createTime: string;
        domain: string;
        dvAuths: outputs.Ssl.GetCertificatesCertificateDvAuth[];
        endTime: string;
        id: string;
        key: string;
        name: string;
        orderId: string;
        productZhName: string;
        projectId: number;
        status: number;
        subjectNames: string[];
        type: string;
    }

    export interface GetCertificatesCertificateDvAuth {
        dvAuthKey: string;
        dvAuthValue: string;
        dvAuthVerifyType: string;
    }

    export interface PayCertificateDvAuth {
        dvAuthKey: string;
        dvAuthValue: string;
        dvAuthVerifyType: string;
    }

    export interface PayCertificateInformation {
        adminEmail: string;
        adminFirstName: string;
        adminLastName: string;
        adminPhoneNum: string;
        adminPosition: string;
        certificateDomain: string;
        contactEmail: string;
        contactFirstName: string;
        contactLastName: string;
        contactNumber: string;
        contactPosition: string;
        csrContent?: string;
        csrType?: string;
        domainLists?: string[];
        keyPassword?: string;
        organizationAddress: string;
        organizationCity: string;
        organizationCountry: string;
        organizationDivision: string;
        organizationName: string;
        organizationRegion: string;
        phoneAreaCode: string;
        phoneNumber: string;
        postalCode: string;
        verifyType: string;
    }

}

export namespace Ssm {
    export interface GetSecretVersionsSecretVersionList {
        secretBinary: string;
        secretString: string;
        versionId: string;
    }

    export interface GetSecretsSecretList {
        associatedInstanceIds: string[];
        createTime: number;
        createUin: number;
        deleteTime: number;
        description: string;
        kmsKeyId: string;
        kmsKeyType: string;
        nextRotationTime: number;
        productName: string;
        projectId: number;
        resourceId: string;
        resourceName: string;
        rotationBeginTime: string;
        rotationFrequency: number;
        rotationStatus: number;
        secretName: string;
        secretType: number;
        status: string;
        targetUin: number;
    }

    export interface ProductSecretPrivilegesList {
        columnName?: string;
        database?: string;
        privilegeName: string;
        privileges: string[];
        tableName?: string;
    }

}

export namespace Tat {
    export interface CommandTag {
        key: string;
        value: string;
    }

    export interface GetAgentAutomationAgentSet {
        agentStatus: string;
        environment: string;
        instanceId: string;
        lastHeartbeatTime: string;
        supportFeatures: string[];
        version: string;
    }

    export interface GetAgentFilter {
        name: string;
        values: string[];
    }

    export interface GetCommandCommandSet {
        commandId: string;
        commandName: string;
        commandType: string;
        content: string;
        createdBy: string;
        createdTime: string;
        defaultParameters: string;
        description: string;
        enableParameter: boolean;
        formattedDescription: string;
        outputCosBucketUrl: string;
        outputCosKeyPrefix: string;
        tags: outputs.Tat.GetCommandCommandSetTag[];
        timeout: number;
        updatedTime: string;
        username: string;
        workingDirectory: string;
    }

    export interface GetCommandCommandSetTag {
        key: string;
        value: string;
    }

    export interface GetInvocationTaskFilter {
        name: string;
        values: string[];
    }

    export interface GetInvocationTaskInvocationTaskSet {
        commandDocuments: outputs.Tat.GetInvocationTaskInvocationTaskSetCommandDocument[];
        commandId: string;
        createdTime: string;
        endTime: string;
        errorInfo: string;
        instanceId: string;
        invocationId: string;
        invocationSource: string;
        invocationTaskId: string;
        startTime: string;
        taskResults: outputs.Tat.GetInvocationTaskInvocationTaskSetTaskResult[];
        taskStatus: string;
        updatedTime: string;
    }

    export interface GetInvocationTaskInvocationTaskSetCommandDocument {
        commandType: string;
        content: string;
        outputCosBucketUrl: string;
        outputCosKeyPrefix: string;
        timeout: number;
        username: string;
        workingDirectory: string;
    }

    export interface GetInvocationTaskInvocationTaskSetTaskResult {
        dropped: number;
        execEndTime: string;
        execStartTime: string;
        exitCode: number;
        output: string;
        outputUploadCosErrorInfo: string;
        outputUrl: string;
    }

    export interface GetInvokerInvokerSet {
        commandId: string;
        createdTime: string;
        enable: boolean;
        instanceIds: string[];
        invokerId: string;
        name: string;
        parameters: string;
        scheduleSettings: outputs.Tat.GetInvokerInvokerSetScheduleSetting[];
        type: string;
        updatedTime: string;
        username: string;
    }

    export interface GetInvokerInvokerSetScheduleSetting {
        invokeTime: string;
        policy: string;
        recurrence: string;
    }

    export interface GetInvokerRecordsInvokerRecordSet {
        invocationId: string;
        invokeTime: string;
        invokerId: string;
        reason: string;
        result: string;
    }

    export interface InvokerScheduleSettings {
        invokeTime?: string;
        policy: string;
        recurrence?: string;
    }

}

export namespace Tcaplus {
    export interface GetClustersList {
        apiAccessId: string;
        apiAccessIp: string;
        apiAccessPort: number;
        clusterId: string;
        clusterName: string;
        createTime: string;
        idlType: string;
        networkType: string;
        oldPasswordExpireTime: string;
        password: string;
        passwordStatus: string;
        subnetId: string;
        vpcId: string;
    }

    export interface GetIdlsList {
        idlId: string;
    }

    export interface GetTablegroupsList {
        createTime: string;
        tableCount: number;
        tablegroupId: string;
        tablegroupName: string;
        totalSize: number;
    }

    export interface GetTablesList {
        createTime: string;
        description: string;
        error: string;
        idlId: string;
        reservedReadCu: number;
        reservedVolume: number;
        reservedWriteCu: number;
        status: string;
        tableId: string;
        tableIdlType: string;
        tableName: string;
        tableSize: number;
        tableType: string;
        tablegroupId: string;
    }

    export interface IdlTableInfo {
        error: string;
        indexKeySet: string;
        keyFields: string;
        sumKeyFieldSize: number;
        sumValueFieldSize: number;
        tableName: string;
        valueFields: string;
    }

}

export namespace Tcm {
    export interface AccessLogConfigCls {
        enable: boolean;
        logSet?: string;
        topic?: string;
    }

    export interface AccessLogConfigSelectedRange {
        all?: boolean;
        items?: outputs.Tcm.AccessLogConfigSelectedRangeItem[];
    }

    export interface AccessLogConfigSelectedRangeItem {
        gateways?: string[];
        namespace?: string;
    }

    export interface ClusterAttachmentClusterList {
        clusterId: string;
        region: string;
        role: string;
        subnetId: string;
        type: string;
        vpcId: string;
    }

    export interface GetMeshMeshList {
        configs: outputs.Tcm.GetMeshMeshListConfig[];
        displayName: string;
        meshId: string;
        tagLists: outputs.Tcm.GetMeshMeshListTagList[];
        type: string;
        version: string;
    }

    export interface GetMeshMeshListConfig {
        istios: outputs.Tcm.GetMeshMeshListConfigIstio[];
    }

    export interface GetMeshMeshListConfigIstio {
        disableHttpRetry: boolean;
        disablePolicyChecks: boolean;
        enablePilotHttp: boolean;
        outboundTrafficPolicy: string;
        smartDns: outputs.Tcm.GetMeshMeshListConfigIstioSmartDn[];
    }

    export interface GetMeshMeshListConfigIstioSmartDn {
        istioMetaDnsAutoAllocate: boolean;
        istioMetaDnsCapture: boolean;
    }

    export interface GetMeshMeshListTagList {
        key: string;
        passthrough: boolean;
        value: string;
    }

    export interface MeshConfig {
        inject?: outputs.Tcm.MeshConfigInject;
        istio?: outputs.Tcm.MeshConfigIstio;
        prometheus: outputs.Tcm.MeshConfigPrometheus;
        sidecarResources?: outputs.Tcm.MeshConfigSidecarResources;
        tracing: outputs.Tcm.MeshConfigTracing;
    }

    export interface MeshConfigInject {
        excludeIpRanges?: string[];
        holdApplicationUntilProxyStarts?: boolean;
        holdProxyUntilApplicationEnds?: boolean;
    }

    export interface MeshConfigIstio {
        disableHttpRetry?: boolean;
        disablePolicyChecks?: boolean;
        enablePilotHttp?: boolean;
        outboundTrafficPolicy: string;
        smartDns?: outputs.Tcm.MeshConfigIstioSmartDns;
        tracing?: outputs.Tcm.MeshConfigIstioTracing;
    }

    export interface MeshConfigIstioSmartDns {
        istioMetaDnsAutoAllocate?: boolean;
        istioMetaDnsCapture?: boolean;
    }

    export interface MeshConfigIstioTracing {
        apm?: outputs.Tcm.MeshConfigIstioTracingApm;
        enable?: boolean;
        sampling: number;
        zipkin?: outputs.Tcm.MeshConfigIstioTracingZipkin;
    }

    export interface MeshConfigIstioTracingApm {
        enable: boolean;
        instanceId?: string;
        region?: string;
    }

    export interface MeshConfigIstioTracingZipkin {
        address: string;
    }

    export interface MeshConfigPrometheus {
        customProm: outputs.Tcm.MeshConfigPrometheusCustomProm;
        instanceId: string;
        region: string;
        subnetId: string;
        vpcId: string;
    }

    export interface MeshConfigPrometheusCustomProm {
        authType: string;
        isPublicAddr: boolean;
        password: string;
        url: string;
        username: string;
        vpcId: string;
    }

    export interface MeshConfigSidecarResources {
        limits?: outputs.Tcm.MeshConfigSidecarResourcesLimit[];
        requests?: outputs.Tcm.MeshConfigSidecarResourcesRequest[];
    }

    export interface MeshConfigSidecarResourcesLimit {
        name?: string;
        quantity?: string;
    }

    export interface MeshConfigSidecarResourcesRequest {
        name?: string;
        quantity?: string;
    }

    export interface MeshConfigTracing {
        apm: outputs.Tcm.MeshConfigTracingApm;
        enable: boolean;
        sampling: number;
        zipkin: outputs.Tcm.MeshConfigTracingZipkin;
    }

    export interface MeshConfigTracingApm {
        enable: boolean;
        instanceId: string;
        region: string;
    }

    export interface MeshConfigTracingZipkin {
        address: string;
    }

    export interface MeshTagList {
        key: string;
        passthrough?: boolean;
        value: string;
    }

    export interface PrometheusAttachmentPrometheus {
        customProm: outputs.Tcm.PrometheusAttachmentPrometheusCustomProm;
        instanceId: string;
        region: string;
        subnetId: string;
        vpcId: string;
    }

    export interface PrometheusAttachmentPrometheusCustomProm {
        authType: string;
        isPublicAddr: boolean;
        password: string;
        url: string;
        username: string;
        vpcId: string;
    }

    export interface TracingConfigApm {
        enable?: boolean;
        instanceId?: string;
        region?: string;
    }

    export interface TracingConfigZipkin {
        address: string;
    }

}

export namespace Tcmq {
    export interface GetQueueFilter {
        name?: string;
        values?: string[];
    }

    export interface GetQueueQueueList {
        activeMsgNum: number;
        bps: number;
        createTime: number;
        createUin: number;
        deadLetterPolicies: outputs.Tcmq.GetQueueQueueListDeadLetterPolicy[];
        deadLetterSources: outputs.Tcmq.GetQueueQueueListDeadLetterSource[];
        delayMsgNum: number;
        inactiveMsgNum: number;
        lastModifyTime: number;
        maxDelaySeconds: number;
        maxMsgBacklogSize: number;
        maxMsgHeapNum: number;
        maxMsgSize: number;
        maxUnackedMsgNum: number;
        minMsgTime: number;
        msgRetentionSeconds: number;
        namespaceName: string;
        pollingWaitSeconds: number;
        qps: number;
        queueId: string;
        queueName: string;
        retentionSizeInMb: number;
        rewindMsgNum: number;
        rewindSeconds: number;
        status: number;
        tags: outputs.Tcmq.GetQueueQueueListTag[];
        tenantId: string;
        trace: boolean;
        transaction: boolean;
        transactionPolicies: outputs.Tcmq.GetQueueQueueListTransactionPolicy[];
        visibilityTimeout: number;
    }

    export interface GetQueueQueueListDeadLetterPolicy {
        deadLetterQueue: string;
        maxReceiveCount: number;
        maxTimeToLive: number;
        policy: number;
    }

    export interface GetQueueQueueListDeadLetterSource {
        queueId: string;
        queueName: string;
    }

    export interface GetQueueQueueListTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetQueueQueueListTransactionPolicy {
        firstQueryInterval: number;
        maxQueryCount: number;
    }

    export interface GetSubscribeSubscriptionList {
        bindingKeys: string[];
        createTime: number;
        endpoint: string;
        filterTags: string[];
        lastModifyTime: number;
        msgCount: number;
        notifyContentFormat: string;
        notifyStrategy: string;
        protocol: string;
        subscriptionId: string;
        subscriptionName: string;
        topicOwner: number;
    }

    export interface GetTopicFilter {
        name?: string;
        values?: string[];
    }

    export interface GetTopicTopicList {
        brokerType: number;
        createTime: number;
        createUin: number;
        filterType: number;
        lastModifyTime: number;
        maxMsgSize: number;
        msgCount: number;
        msgRetentionSeconds: number;
        namespaceName: string;
        qps: number;
        status: number;
        tags: outputs.Tcmq.GetTopicTopicListTag[];
        tenantId: string;
        topicId: string;
        topicName: string;
        trace: boolean;
    }

    export interface GetTopicTopicListTag {
        tagKey: string;
        tagValue: string;
    }

}

export namespace Tcr {
    export interface GetImagesImageInfoList {
        digest: string;
        imageVersion: string;
        kind: string;
        kmsSignature: string;
        size: number;
        updateTime: string;
    }

    export interface GetInstancesInstanceList {
        id: string;
        instanceType: string;
        internalEndPoint: string;
        name: string;
        publicDomain: string;
        status: string;
        tags: {[key: string]: any};
    }

    export interface GetNamespacesNamespaceList {
        id: number;
        isPublic: boolean;
        name: string;
    }

    export interface GetReplicationInstanceCreateTasksTaskDetail {
        createdTime: string;
        finishedTime: string;
        taskMessage: string;
        taskName: string;
        taskStatus: string;
        taskUuid: string;
    }

    export interface GetReplicationInstanceSyncStatusReplicationLog {
        destination: string;
        endTime: string;
        resourceType: string;
        source: string;
        startTime: string;
        status: string;
    }

    export interface GetRepositoriesRepositoryList {
        briefDesc: string;
        createTime: string;
        description: string;
        isPublic: boolean;
        name: string;
        namespaceName: string;
        updateTime: string;
        url: string;
    }

    export interface GetTagRetentionExecutionTasksRetentionTaskList {
        endTime: string;
        executionId: number;
        repository: string;
        retained: number;
        startTime: string;
        status: string;
        taskId: number;
        total: number;
    }

    export interface GetTagRetentionExecutionsRetentionExecutionList {
        endTime: string;
        executionId: number;
        retentionId: number;
        startTime: string;
        status: string;
    }

    export interface GetTokensTokenList {
        createTime: string;
        description: string;
        enable: boolean;
        tokenId: string;
    }

    export interface GetVpcAttachmentsVpcAttachmentList {
        accessIp: string;
        enablePublicDomainDns: boolean;
        enableVpcDomainDns: boolean;
        status: string;
        subnetId: string;
        vpcId: string;
    }

    export interface GetWebhookTriggerLogsLog {
        creationTime: string;
        detail: string;
        eventType: string;
        id: number;
        notifyType: string;
        status: string;
        triggerId: number;
        updateTime: string;
    }

    export interface ImmutableTagRuleRule {
        disabled?: boolean;
        id: number;
        nsName: string;
        repositoryDecoration: string;
        repositoryPattern: string;
        tagDecoration: string;
        tagPattern: string;
    }

    export interface InstanceReplication {
        id: string;
        regionId?: number;
        synTag?: boolean;
    }

    export interface InstanceSecurityPolicy {
        cidrBlock?: string;
        description?: string;
        index: number;
        version: string;
    }

    export interface ManageReplicationOperationPeerReplicationOption {
        enablePeerReplication: boolean;
        peerRegistryToken: string;
        peerRegistryUin: string;
    }

    export interface ManageReplicationOperationRule {
        destNamespace: string;
        filters: outputs.Tcr.ManageReplicationOperationRuleFilter[];
        name: string;
        override: boolean;
    }

    export interface ManageReplicationOperationRuleFilter {
        type: string;
        value?: string;
    }

    export interface NamespaceCveWhitelistItem {
        cveId?: string;
    }

    export interface ServiceAccountPermission {
        actions: string[];
        resource: string;
    }

    export interface TagRetentionRuleRetentionRule {
        key: string;
        value: number;
    }

    export interface WebhookTriggerTrigger {
        condition: string;
        description?: string;
        enabled: boolean;
        eventTypes: string[];
        id: number;
        name: string;
        namespaceId: number;
        targets: outputs.Tcr.WebhookTriggerTriggerTarget[];
    }

    export interface WebhookTriggerTriggerTarget {
        address: string;
        headers?: outputs.Tcr.WebhookTriggerTriggerTargetHeader[];
    }

    export interface WebhookTriggerTriggerTargetHeader {
        key: string;
        values: string[];
    }

}

export namespace Tdcpg {
    export interface GetClustersList {
        autoRenewFlag: number;
        clusterId: string;
        clusterName: string;
        createTime: string;
        dbCharset: string;
        dbKernelVersion: string;
        dbMajorVersion: string;
        dbVersion: string;
        endpointSets: outputs.Tdcpg.GetClustersListEndpointSet[];
        instanceCount: number;
        payMode: string;
        payPeriodEndTime: string;
        projectId: number;
        region: string;
        status: string;
        statusDesc: string;
        storageLimit: number;
        storagePayMode: string;
        storageUsed: number;
        zone: string;
    }

    export interface GetClustersListEndpointSet {
        clusterId: string;
        endpointId: string;
        endpointName: string;
        endpointType: string;
        privateIp: string;
        privatePort: number;
        subnetId: string;
        vpcId: string;
        wanDomain: string;
        wanIp: string;
        wanPort: number;
    }

    export interface GetInstancesList {
        clusterId: string;
        cpu: number;
        createTime: string;
        dbKernelVersion: string;
        dbMajorVersion: string;
        dbVersion: string;
        endpointId: string;
        instanceId: string;
        instanceName: string;
        instanceType: string;
        memory: number;
        payMode: string;
        payPeriodEndTime: string;
        region: string;
        status: string;
        statusDesc: string;
        zone: string;
    }

}

export namespace Tdmq {
    export interface GetProInstanceDetailClusterInfo {
        canEditRoute: boolean;
        clusterId: string;
        clusterName: string;
        createTime: string;
        maxStorage: number;
        nodeDistributions: outputs.Tdmq.GetProInstanceDetailClusterInfoNodeDistribution[];
        remark: string;
        status: number;
        version: string;
    }

    export interface GetProInstanceDetailClusterInfoNodeDistribution {
        nodeCount: number;
        zoneId: string;
        zoneName: string;
    }

    export interface GetProInstanceDetailClusterSpecInfo {
        maxBandWidth: number;
        maxNamespaces: number;
        maxTopics: number;
        maxTps: number;
        scalableTps: number;
        specName: string;
    }

    export interface GetProInstanceDetailNetworkAccessPointInfo {
        endpoint: string;
        instanceId: string;
        routeType: number;
        subnetId: string;
        vpcId: string;
    }

    export interface GetProInstancesFilter {
        name?: string;
        values?: string[];
    }

    export interface GetProInstancesInstance {
        autoRenewFlag: number;
        configDisplay: string;
        expireTime: number;
        instanceId: string;
        instanceName: string;
        instanceVersion: string;
        maxBandWidth: number;
        maxStorage: number;
        maxTps: number;
        payMode: number;
        remark: string;
        scalableTps: number;
        specName: string;
        status: number;
        subnetId: string;
        vpcId: string;
    }

    export interface GetPublishersFilter {
        name?: string;
        values?: string[];
    }

    export interface GetPublishersPublisher {
        address: string;
        averageMsgSize: number;
        clientVersion: string;
        connectedSince: string;
        msgRateIn: number;
        msgThroughputIn: number;
        partition: number;
        producerId: number;
        producerName: string;
    }

    export interface GetPublishersSort {
        name: string;
        order: string;
    }

    export interface GetRabbitmqNodeListFilter {
        name?: string;
        values?: string[];
    }

    export interface GetRabbitmqNodeListNodeList {
        cpuUsage: string;
        diskUsage: string;
        memory: number;
        nodeName: string;
        nodeStatus: string;
        processNumber: number;
    }

    export interface GetRabbitmqVipInstanceFilter {
        name?: string;
        values?: string[];
    }

    export interface GetRabbitmqVipInstanceInstance {
        autoRenewFlag: number;
        configDisplay: string;
        exceptionInformation: string;
        expireTime: number;
        instanceId: string;
        instanceName: string;
        instanceVersion: string;
        maxBandWidth: number;
        maxStorage: number;
        maxTps: number;
        nodeCount: number;
        payMode: number;
        remark: string;
        specName: string;
        status: number;
    }

    export interface GetRocketmqClusterClusterList {
        configs: outputs.Tdmq.GetRocketmqClusterClusterListConfig[];
        infos: outputs.Tdmq.GetRocketmqClusterClusterListInfo[];
        status: number;
    }

    export interface GetRocketmqClusterClusterListConfig {
        maxGroupNum: number;
        maxLatencyTime: number;
        maxNamespaceNum: number;
        maxRetentionTime: number;
        maxTopicNum: number;
        maxTpsPerNamespace: number;
        usedGroupNum: number;
        usedNamespaceNum: number;
        usedTopicNum: number;
    }

    export interface GetRocketmqClusterClusterListInfo {
        clusterId: string;
        clusterName: string;
        createTime: number;
        isVip: boolean;
        publicEndPoint: string;
        region: string;
        remark: string;
        rocketmqFlag: boolean;
        supportNamespaceEndpoint: boolean;
        vpcEndPoint: string;
        vpcs: outputs.Tdmq.GetRocketmqClusterClusterListInfoVpc[];
    }

    export interface GetRocketmqClusterClusterListInfoVpc {
        subnetId: string;
        vpcId: string;
    }

    export interface GetRocketmqGroupGroup {
        broadcastEnable: boolean;
        clientProtocol: string;
        consumerNum: number;
        consumerType: string;
        consumptionMode: number;
        createTime: number;
        name: string;
        readEnable: boolean;
        remark: string;
        retryPartitionNum: number;
        totalAccumulative: number;
        tps: number;
        updateTime: number;
    }

    export interface GetRocketmqMessagesMessageTrack {
        consumeStatus: string;
        exceptionDesc: string;
        group: string;
        trackType: string;
    }

    export interface GetRocketmqNamespaceNamespace {
        namespaceId: string;
        publicEndpoint: string;
        remark: string;
        retentionTime: number;
        ttl: number;
        vpcEndpoint: string;
    }

    export interface GetRocketmqRoleRoleSet {
        createTime: string;
        remark: string;
        roleName: string;
        token: string;
        updateTime: string;
    }

    export interface GetRocketmqTopicTopic {
        createTime: number;
        name: string;
        partitionNum: number;
        remark: string;
        updateTime: number;
    }

    export interface GetVipInstanceClusterInfo {
        clusterId: string;
        clusterName: string;
        createTime: number;
        httpPublicEndpoint: string;
        httpVpcEndpoint: string;
        isVip: boolean;
        isolateTime: number;
        publicEndPoint: string;
        region: string;
        remark: string;
        rocketMqFlag: boolean;
        status: number;
        supportNamespaceEndpoint: boolean;
        vpcEndPoint: string;
        vpcs: outputs.Tdmq.GetVipInstanceClusterInfoVpc[];
    }

    export interface GetVipInstanceClusterInfoVpc {
        subnetId: string;
        vpcId: string;
    }

    export interface GetVipInstanceInstanceConfig {
        configDisplay: string;
        maxGroupNum: number;
        maxNamespaceNum: number;
        maxQueuesPerTopic: number;
        maxTopicNum: number;
        maxTpsPerNamespace: number;
        nodeCount: number;
        nodeDistributions: outputs.Tdmq.GetVipInstanceInstanceConfigNodeDistribution[];
        topicDistributions: outputs.Tdmq.GetVipInstanceInstanceConfigTopicDistribution[];
        usedGroupNum: number;
        usedNamespaceNum: number;
        usedTopicNum: number;
    }

    export interface GetVipInstanceInstanceConfigNodeDistribution {
        nodeCount: number;
        zoneId: string;
        zoneName: string;
    }

    export interface GetVipInstanceInstanceConfigTopicDistribution {
        count: number;
        topicType: string;
    }

    export interface NamespaceRetentionPolicy {
        sizeInMb: number;
        timeInMinutes: number;
    }

    export interface RocketmqClusterVpc {
        subnetId: string;
        vpcId: string;
    }

    export interface RocketmqVipInstanceVpcInfo {
        subnetId: string;
        vpcId: string;
    }

}

export namespace Tem {
    export interface AppConfigConfigData {
        key: string;
        value: string;
    }

    export interface ApplicationServiceService {
        ip: string;
        portMappingItemLists?: outputs.Tem.ApplicationServiceServicePortMappingItemList[];
        serviceName?: string;
        subnetId?: string;
        type?: string;
        vpcId?: string;
    }

    export interface ApplicationServiceServicePortMappingItemList {
        port?: number;
        protocol?: string;
        targetPort?: number;
    }

    export interface GatewayIngress {
        addressIpVersion: string;
        clbId: string;
        createTime: string;
        environmentId: string;
        ingressName: string;
        mixed: boolean;
        rewriteType?: string;
        rules: outputs.Tem.GatewayIngressRule[];
        tls?: outputs.Tem.GatewayIngressTl[];
        vip: string;
    }

    export interface GatewayIngressRule {
        host?: string;
        http: outputs.Tem.GatewayIngressRuleHttp;
        protocol?: string;
    }

    export interface GatewayIngressRuleHttp {
        paths: outputs.Tem.GatewayIngressRuleHttpPath[];
    }

    export interface GatewayIngressRuleHttpPath {
        backend: outputs.Tem.GatewayIngressRuleHttpPathBackend;
        path: string;
    }

    export interface GatewayIngressRuleHttpPathBackend {
        serviceName: string;
        servicePort: number;
    }

    export interface GatewayIngressTl {
        certificateId: string;
        hosts: string[];
        secretName: string;
    }

    export interface ScaleRuleAutoscaler {
        autoscalerName: string;
        cronHorizontalAutoscalers?: outputs.Tem.ScaleRuleAutoscalerCronHorizontalAutoscaler[];
        description?: string;
        enabled: boolean;
        horizontalAutoscalers?: outputs.Tem.ScaleRuleAutoscalerHorizontalAutoscaler[];
        maxReplicas: number;
        minReplicas: number;
    }

    export interface ScaleRuleAutoscalerCronHorizontalAutoscaler {
        enabled: boolean;
        name: string;
        period: string;
        priority: number;
        schedules: outputs.Tem.ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule[];
    }

    export interface ScaleRuleAutoscalerCronHorizontalAutoscalerSchedule {
        startAt: string;
        targetReplicas: number;
    }

    export interface ScaleRuleAutoscalerHorizontalAutoscaler {
        enabled: boolean;
        maxReplicas: number;
        metrics: string;
        minReplicas: number;
        threshold: number;
    }

    export interface WorkloadDeployStrategyConf {
        batchInterval?: number;
        betaBatchNum?: number;
        deployStrategyType: number;
        force?: boolean;
        minAvailable?: number;
        totalBatchCount: number;
    }

    export interface WorkloadEnvConf {
        config?: string;
        key: string;
        secret?: string;
        type?: string;
        value: string;
    }

    export interface WorkloadLiveness {
        exec?: string;
        initialDelaySeconds?: number;
        path?: string;
        periodSeconds?: number;
        port?: number;
        protocol?: string;
        timeoutSeconds?: number;
        type: string;
    }

    export interface WorkloadReadiness {
        exec?: string;
        initialDelaySeconds?: number;
        path?: string;
        periodSeconds?: number;
        port?: number;
        protocol?: string;
        timeoutSeconds?: number;
        type: string;
    }

    export interface WorkloadStartupProbe {
        exec?: string;
        initialDelaySeconds?: number;
        path?: string;
        periodSeconds?: number;
        port?: number;
        protocol?: string;
        timeoutSeconds?: number;
        type: string;
    }

    export interface WorkloadStorageConf {
        storageVolIp: string;
        storageVolName: string;
        storageVolPath: string;
    }

    export interface WorkloadStorageMountConf {
        mountPath: string;
        volumeName: string;
    }

}

export namespace Teo {
    export interface ApplicationProxyIpv6 {
        switch: string;
    }

    export interface GetRuleEngineSettingsAction {
        action: string;
        properties: outputs.Teo.GetRuleEngineSettingsActionProperty[];
    }

    export interface GetRuleEngineSettingsActionProperty {
        choiceProperties: outputs.Teo.GetRuleEngineSettingsActionPropertyChoiceProperty[];
        choicesValues: string[];
        extraParameters: outputs.Teo.GetRuleEngineSettingsActionPropertyExtraParameter[];
        isAllowEmpty: boolean;
        isMultiple: boolean;
        max: number;
        min: number;
        name: string;
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyChoiceProperty {
        choicesValues: string[];
        extraParameters: outputs.Teo.GetRuleEngineSettingsActionPropertyChoicePropertyExtraParameter[];
        isAllowEmpty: boolean;
        isMultiple: boolean;
        max: number;
        min: number;
        name: string;
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyChoicePropertyExtraParameter {
        choices: string[];
        id: string;
        type: string;
    }

    export interface GetRuleEngineSettingsActionPropertyExtraParameter {
        choices: string[];
        id: string;
        type: string;
    }

    export interface GetZoneAvailablePlansPlanInfoList {
        area: string;
        currency: string;
        flux: number;
        frequency: string;
        planType: string;
        price: number;
        request: number;
        siteNumber: number;
    }

    export interface OriginGroupOriginRecord {
        areas?: string[];
        port: number;
        private?: boolean;
        privateParameters?: outputs.Teo.OriginGroupOriginRecordPrivateParameter[];
        record: string;
        recordId: string;
        weight?: number;
    }

    export interface OriginGroupOriginRecordPrivateParameter {
        name: string;
        value: string;
    }

    export interface RuleEngineRule {
        actions: outputs.Teo.RuleEngineRuleAction[];
        ors: outputs.Teo.RuleEngineRuleOr[];
        subRules?: outputs.Teo.RuleEngineRuleSubRule[];
    }

    export interface RuleEngineRuleAction {
        codeAction?: outputs.Teo.RuleEngineRuleActionCodeAction;
        normalAction?: outputs.Teo.RuleEngineRuleActionNormalAction;
        rewriteAction?: outputs.Teo.RuleEngineRuleActionRewriteAction;
    }

    export interface RuleEngineRuleActionCodeAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleActionCodeActionParameter[];
    }

    export interface RuleEngineRuleActionCodeActionParameter {
        name: string;
        statusCode: number;
        values: string[];
    }

    export interface RuleEngineRuleActionNormalAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleActionNormalActionParameter[];
    }

    export interface RuleEngineRuleActionNormalActionParameter {
        name: string;
        values: string[];
    }

    export interface RuleEngineRuleActionRewriteAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleActionRewriteActionParameter[];
    }

    export interface RuleEngineRuleActionRewriteActionParameter {
        action: string;
        name: string;
        values: string[];
    }

    export interface RuleEngineRuleOr {
        ands: outputs.Teo.RuleEngineRuleOrAnd[];
    }

    export interface RuleEngineRuleOrAnd {
        ignoreCase?: boolean;
        name?: string;
        operator: string;
        target: string;
        values: string[];
    }

    export interface RuleEngineRuleSubRule {
        rules: outputs.Teo.RuleEngineRuleSubRuleRule[];
        tags?: string[];
    }

    export interface RuleEngineRuleSubRuleRule {
        actions: outputs.Teo.RuleEngineRuleSubRuleRuleAction[];
        ors: outputs.Teo.RuleEngineRuleSubRuleRuleOr[];
    }

    export interface RuleEngineRuleSubRuleRuleAction {
        codeAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionCodeAction;
        normalAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionNormalAction;
        rewriteAction?: outputs.Teo.RuleEngineRuleSubRuleRuleActionRewriteAction;
    }

    export interface RuleEngineRuleSubRuleRuleActionCodeAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionCodeActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionCodeActionParameter {
        name: string;
        statusCode: number;
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleActionNormalAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionNormalActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionNormalActionParameter {
        name: string;
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleActionRewriteAction {
        action: string;
        parameters: outputs.Teo.RuleEngineRuleSubRuleRuleActionRewriteActionParameter[];
    }

    export interface RuleEngineRuleSubRuleRuleActionRewriteActionParameter {
        action: string;
        name: string;
        values: string[];
    }

    export interface RuleEngineRuleSubRuleRuleOr {
        ands: outputs.Teo.RuleEngineRuleSubRuleRuleOrAnd[];
    }

    export interface RuleEngineRuleSubRuleRuleOrAnd {
        ignoreCase?: boolean;
        name?: string;
        operator: string;
        target: string;
        values: string[];
    }

    export interface ZoneResource {
        area: string;
        autoRenewFlag: number;
        createTime: string;
        enableTime: string;
        expireTime: string;
        id: string;
        payMode: number;
        planId: string;
        status: string;
        svs: outputs.Teo.ZoneResourceSv[];
    }

    export interface ZoneResourceSv {
        key: string;
        value: string;
    }

    export interface ZoneSettingCache {
        cache: outputs.Teo.ZoneSettingCacheCache;
        followOrigin: outputs.Teo.ZoneSettingCacheFollowOrigin;
        noCache: outputs.Teo.ZoneSettingCacheNoCache;
    }

    export interface ZoneSettingCacheCache {
        cacheTime: number;
        ignoreCacheControl: string;
        switch: string;
    }

    export interface ZoneSettingCacheFollowOrigin {
        switch: string;
    }

    export interface ZoneSettingCacheKey {
        fullUrlCache?: string;
        ignoreCase?: string;
        queryString?: outputs.Teo.ZoneSettingCacheKeyQueryString;
    }

    export interface ZoneSettingCacheKeyQueryString {
        action?: string;
        switch: string;
        values?: string[];
    }

    export interface ZoneSettingCacheNoCache {
        switch: string;
    }

    export interface ZoneSettingCachePrefresh {
        percent?: number;
        switch: string;
    }

    export interface ZoneSettingClientIpHeader {
        headerName?: string;
        switch: string;
    }

    export interface ZoneSettingCompression {
        algorithms: string[];
        switch: string;
    }

    export interface ZoneSettingForceRedirect {
        redirectStatusCode?: number;
        switch: string;
    }

    export interface ZoneSettingHttps {
        hsts?: outputs.Teo.ZoneSettingHttpsHsts;
        http2?: string;
        ocspStapling?: string;
        tlsVersions?: string[];
    }

    export interface ZoneSettingHttpsHsts {
        includeSubDomains?: string;
        maxAge?: number;
        preload?: string;
        switch: string;
    }

    export interface ZoneSettingIpv6 {
        switch: string;
    }

    export interface ZoneSettingMaxAge {
        followOrigin?: string;
        maxAgeTime?: number;
    }

    export interface ZoneSettingOfflineCache {
        switch: string;
    }

    export interface ZoneSettingOrigin {
        backupOrigins: string[];
        cosPrivateAccess: string;
        originPullProtocol: string;
        origins: string[];
    }

    export interface ZoneSettingPostMaxSize {
        maxSize?: number;
        switch: string;
    }

    export interface ZoneSettingQuic {
        switch: string;
    }

    export interface ZoneSettingSmartRouting {
        switch: string;
    }

    export interface ZoneSettingUpstreamHttp2 {
        switch: string;
    }

    export interface ZoneSettingWebSocket {
        switch: string;
        timeout?: number;
    }

    export interface ZoneVanityNameServers {
        servers?: string[];
        switch: string;
    }

    export interface ZoneVanityNameServersIp {
        ipv4: string;
        name: string;
    }

}

export namespace Tse {
    export interface CngwCanaryRuleCanaryRule {
        balancedServiceLists?: outputs.Tse.CngwCanaryRuleCanaryRuleBalancedServiceList[];
        conditionLists?: outputs.Tse.CngwCanaryRuleCanaryRuleConditionList[];
        enabled: boolean;
        priority: number;
        serviceId?: string;
        serviceName?: string;
    }

    export interface CngwCanaryRuleCanaryRuleBalancedServiceList {
        percent?: number;
        serviceId?: string;
        serviceName?: string;
        upstreamName: string;
    }

    export interface CngwCanaryRuleCanaryRuleConditionList {
        delimiter?: string;
        globalConfigId?: string;
        globalConfigName?: string;
        key?: string;
        operator?: string;
        type: string;
        value?: string;
    }

    export interface CngwGatewayInternetConfig {
        description?: string;
        internetAddressVersion?: string;
        internetMaxBandwidthOut?: number;
        internetPayMode?: string;
        masterZoneId?: string;
        multiZoneFlag?: boolean;
        slaType?: string;
        slaveZoneId?: string;
    }

    export interface CngwGatewayNodeConfig {
        number: number;
        specification: string;
    }

    export interface CngwGatewayVpcConfig {
        subnetId?: string;
        vpcId?: string;
    }

    export interface CngwGroupInternetConfig {
        description?: string;
        internetAddressVersion?: string;
        internetMaxBandwidthOut?: number;
        internetPayMode?: string;
        masterZoneId?: string;
        multiZoneFlag?: boolean;
        slaType?: string;
        slaveZoneId?: string;
    }

    export interface CngwGroupNodeConfig {
        number: number;
        specification: string;
    }

    export interface CngwRouteHeader {
        key?: string;
        value?: string;
    }

    export interface CngwRouteRateLimitLimitDetail {
        enabled: boolean;
        externalRedis?: outputs.Tse.CngwRouteRateLimitLimitDetailExternalRedis;
        header?: string;
        hideClientHeaders: boolean;
        isDelay: boolean;
        limitBy: string;
        lineUpTime?: number;
        path?: string;
        policy?: string;
        qpsThresholds: outputs.Tse.CngwRouteRateLimitLimitDetailQpsThreshold[];
        rateLimitResponse?: outputs.Tse.CngwRouteRateLimitLimitDetailRateLimitResponse;
        rateLimitResponseUrl?: string;
        responseType: string;
    }

    export interface CngwRouteRateLimitLimitDetailExternalRedis {
        redisHost: string;
        redisPassword: string;
        redisPort: number;
        redisTimeout: number;
    }

    export interface CngwRouteRateLimitLimitDetailQpsThreshold {
        max: number;
        unit: string;
    }

    export interface CngwRouteRateLimitLimitDetailRateLimitResponse {
        body?: string;
        headers?: outputs.Tse.CngwRouteRateLimitLimitDetailRateLimitResponseHeader[];
        httpStatus?: number;
    }

    export interface CngwRouteRateLimitLimitDetailRateLimitResponseHeader {
        key?: string;
        value?: string;
    }

    export interface CngwServiceRateLimitLimitDetail {
        enabled: boolean;
        externalRedis?: outputs.Tse.CngwServiceRateLimitLimitDetailExternalRedis;
        header?: string;
        hideClientHeaders: boolean;
        isDelay: boolean;
        limitBy: string;
        lineUpTime?: number;
        path?: string;
        policy?: string;
        qpsThresholds: outputs.Tse.CngwServiceRateLimitLimitDetailQpsThreshold[];
        rateLimitResponse?: outputs.Tse.CngwServiceRateLimitLimitDetailRateLimitResponse;
        rateLimitResponseUrl?: string;
        responseType: string;
    }

    export interface CngwServiceRateLimitLimitDetailExternalRedis {
        redisHost: string;
        redisPassword: string;
        redisPort: number;
        redisTimeout: number;
    }

    export interface CngwServiceRateLimitLimitDetailQpsThreshold {
        max: number;
        unit: string;
    }

    export interface CngwServiceRateLimitLimitDetailRateLimitResponse {
        body?: string;
        headers?: outputs.Tse.CngwServiceRateLimitLimitDetailRateLimitResponseHeader[];
        httpStatus?: number;
    }

    export interface CngwServiceRateLimitLimitDetailRateLimitResponseHeader {
        key?: string;
        value?: string;
    }

    export interface CngwServiceUpstreamInfo {
        algorithm?: string;
        autoScalingCvmPort?: number;
        autoScalingGroupId?: string;
        autoScalingHookStatus?: string;
        autoScalingTatCmdStatus?: string;
        host: string;
        namespace?: string;
        port?: number;
        realSourceType?: string;
        scfLambdaName?: string;
        scfLambdaQualifier?: string;
        scfNamespace?: string;
        scfType?: string;
        serviceName?: string;
        slowStart?: number;
        sourceId?: string;
        sourceName?: string;
        sourceType?: string;
        targets?: outputs.Tse.CngwServiceUpstreamInfoTarget[];
    }

    export interface CngwServiceUpstreamInfoTarget {
        createdTime: string;
        health: string;
        host: string;
        port: number;
        source?: string;
        weight: number;
    }

    export interface GetAccessAddressEnvAddressInfo {
        configInternetServiceIp: string;
        configIntranetAddress: string;
        enableConfigInternet: boolean;
        enableConfigIntranet: boolean;
        envName: string;
        internetBandWidth: number;
    }

    export interface GetAccessAddressLimiterAddressInfo {
        intranetAddress: string;
    }

    export interface GetGatewayCanaryRulesResult {
        canaryRuleLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleList[];
        totalCount: number;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleList {
        balancedServiceLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleListBalancedServiceList[];
        conditionLists: outputs.Tse.GetGatewayCanaryRulesResultCanaryRuleListConditionList[];
        enabled: boolean;
        priority: number;
        serviceId: string;
        serviceName: string;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleListBalancedServiceList {
        percent: number;
        serviceId: string;
        serviceName: string;
        upstreamName: string;
    }

    export interface GetGatewayCanaryRulesResultCanaryRuleListConditionList {
        delimiter: string;
        globalConfigId: string;
        globalConfigName: string;
        key: string;
        operator: string;
        type: string;
        value: string;
    }

    export interface GetGatewayNodesNodeList {
        groupId: string;
        groupName: string;
        nodeId: string;
        nodeIp: string;
        status: string;
        zone: string;
        zoneId: string;
    }

    export interface GetGatewayRoutesResult {
        routeLists: outputs.Tse.GetGatewayRoutesResultRouteList[];
        totalCount: number;
    }

    export interface GetGatewayRoutesResultRouteList {
        createdTime: string;
        destinationPorts: number[];
        forceHttps: boolean;
        headers: outputs.Tse.GetGatewayRoutesResultRouteListHeader[];
        hosts: string[];
        httpsRedirectStatusCode: number;
        id: string;
        methods: string[];
        name: string;
        paths: string[];
        preserveHost: boolean;
        protocols: string[];
        serviceId: string;
        serviceName: string;
        stripPath: boolean;
    }

    export interface GetGatewayRoutesResultRouteListHeader {
        key: string;
        value: string;
    }

    export interface GetGatewayServicesFilter {
        key?: string;
        value?: string;
    }

    export interface GetGatewayServicesResult {
        serviceLists: outputs.Tse.GetGatewayServicesResultServiceList[];
        totalCount: number;
    }

    export interface GetGatewayServicesResultServiceList {
        createdTime: string;
        editable: boolean;
        id: string;
        name: string;
        tags: string[];
        upstreamInfos: outputs.Tse.GetGatewayServicesResultServiceListUpstreamInfo[];
        upstreamType: string;
    }

    export interface GetGatewayServicesResultServiceListUpstreamInfo {
        algorithm: string;
        autoScalingCvmPort: number;
        autoScalingGroupId: string;
        autoScalingHookStatus: string;
        autoScalingTatCmdStatus: string;
        host: string;
        namespace: string;
        port: number;
        realSourceType: string;
        scfLambdaName: string;
        scfLambdaQualifier: string;
        scfNamespace: string;
        scfType: string;
        serviceName: string;
        slowStart: number;
        sourceId: string;
        sourceName: string;
        sourceType: string;
        targets: outputs.Tse.GetGatewayServicesResultServiceListUpstreamInfoTarget[];
    }

    export interface GetGatewayServicesResultServiceListUpstreamInfoTarget {
        createdTime: string;
        health: string;
        host: string;
        port: number;
        source: string;
        weight: number;
    }

    export interface GetGatewaysFilter {
        name: string;
        values: string[];
    }

    export interface GetGatewaysResult {
        gatewayLists: outputs.Tse.GetGatewaysResultGatewayList[];
        totalCount: number;
    }

    export interface GetGatewaysResultGatewayList {
        autoRenewFlag: number;
        createTime: string;
        curDeadline: string;
        description: string;
        enableCls: boolean;
        enableInternet: boolean;
        engineRegion: string;
        featureVersion: string;
        gatewayId: string;
        gatewayMinorVersion: string;
        gatewayVersion: string;
        ingressClassName: string;
        instancePorts: outputs.Tse.GetGatewaysResultGatewayListInstancePort[];
        internetMaxBandwidthOut: number;
        internetPayMode: string;
        isolateTime: string;
        loadBalancerType: string;
        name: string;
        nodeConfigs: outputs.Tse.GetGatewaysResultGatewayListNodeConfig[];
        publicIpAddresses: string[];
        status: string;
        tags: outputs.Tse.GetGatewaysResultGatewayListTag[];
        tradeType: number;
        type: string;
        vpcConfigs: outputs.Tse.GetGatewaysResultGatewayListVpcConfig[];
    }

    export interface GetGatewaysResultGatewayListInstancePort {
        httpPort: string;
        httpsPort: string;
    }

    export interface GetGatewaysResultGatewayListNodeConfig {
        number: number;
        specification: string;
    }

    export interface GetGatewaysResultGatewayListTag {
        tagKey: string;
        tagValue: string;
    }

    export interface GetGatewaysResultGatewayListVpcConfig {
        subnetId: string;
        vpcId: string;
    }

    export interface GetGroupsFilter {
        name: string;
        values: string[];
    }

    export interface GetGroupsResult {
        gatewayGroupLists: outputs.Tse.GetGroupsResultGatewayGroupList[];
        totalCount: number;
    }

    export interface GetGroupsResultGatewayGroupList {
        bindingStrategies: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategy[];
        createTime: string;
        description: string;
        gatewayId: string;
        groupId: string;
        internetMaxBandwidthOut: number;
        isFirstGroup: number;
        modifyTime: string;
        name: string;
        nodeConfigs: outputs.Tse.GetGroupsResultGatewayGroupListNodeConfig[];
        status: string;
        subnetIds: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategy {
        configs: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyConfig[];
        createTime: string;
        cronConfigs: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyCronConfig[];
        description: string;
        gatewayId: string;
        maxReplicas: number;
        modifyTime: string;
        strategyId: string;
        strategyName: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyConfig {
        autoScalerId: string;
        createTime: string;
        enabled: boolean;
        maxReplicas: number;
        metrics: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyConfigMetric[];
        modifyTime: string;
        strategyId: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyConfigMetric {
        resourceName: string;
        targetType: string;
        targetValue: number;
        type: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyCronConfig {
        createTime: string;
        enabled: boolean;
        modifyTime: string;
        params: outputs.Tse.GetGroupsResultGatewayGroupListBindingStrategyCronConfigParam[];
        strategyId: string;
    }

    export interface GetGroupsResultGatewayGroupListBindingStrategyCronConfigParam {
        crontab: string;
        period: string;
        startAt: string;
        targetReplicas: number;
    }

    export interface GetGroupsResultGatewayGroupListNodeConfig {
        number: number;
        specification: string;
    }

    export interface GetNacosReplicasReplica {
        name: string;
        role: string;
        status: string;
        subnetId: string;
        vpcId: string;
        zone: string;
        zoneId: string;
    }

    export interface GetNacosServerInterfacesContent {
        interface: string;
    }

    export interface GetZookeeperReplicasReplica {
        aliasName: string;
        name: string;
        role: string;
        status: string;
        subnetId: string;
        vpcId: string;
        zone: string;
        zoneId: string;
    }

    export interface GetZookeeperServerInterfacesContent {
        interface: string;
    }

    export interface InstanceEngineRegionInfo {
        engineRegion: string;
        replica: number;
        vpcInfos: outputs.Tse.InstanceEngineRegionInfoVpcInfo[];
    }

    export interface InstanceEngineRegionInfoVpcInfo {
        intranetAddress?: string;
        subnetId: string;
        vpcId: string;
    }

}

export namespace Tsf {
    export interface ApiGroupBindedGatewayDeployGroup {
        applicationId: string;
        applicationName: string;
        applicationType: string;
        clusterType: string;
        deployGroupId: string;
        deployGroupName: string;
        groupStatus: string;
    }

    export interface ApplicationServiceConfigList {
        healthCheck?: outputs.Tsf.ApplicationServiceConfigListHealthCheck;
        name: string;
        ports: outputs.Tsf.ApplicationServiceConfigListPort[];
    }

    export interface ApplicationServiceConfigListHealthCheck {
        path?: string;
    }

    export interface ApplicationServiceConfigListPort {
        protocol: string;
        targetPort: number;
    }

    export interface ClusterOperationInfo {
        addInstances: outputs.Tsf.ClusterOperationInfoAddInstance[];
        destroys: outputs.Tsf.ClusterOperationInfoDestroy[];
        inits: outputs.Tsf.ClusterOperationInfoInit[];
    }

    export interface ClusterOperationInfoAddInstance {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface ClusterOperationInfoDestroy {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface ClusterOperationInfoInit {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface DeployContainerGroupAgentProfileList {
        agentType: string;
        agentVersion: string;
    }

    export interface DeployContainerGroupEnv {
        name: string;
        value: string;
        valueFrom: outputs.Tsf.DeployContainerGroupEnvValueFrom;
    }

    export interface DeployContainerGroupEnvValueFrom {
        fieldRef: outputs.Tsf.DeployContainerGroupEnvValueFromFieldRef;
        resourceFieldRef: outputs.Tsf.DeployContainerGroupEnvValueFromResourceFieldRef;
    }

    export interface DeployContainerGroupEnvValueFromFieldRef {
        fieldPath: string;
    }

    export interface DeployContainerGroupEnvValueFromResourceFieldRef {
        resource: string;
    }

    export interface DeployContainerGroupHealthCheckSettings {
        livenessProbe?: outputs.Tsf.DeployContainerGroupHealthCheckSettingsLivenessProbe;
        readinessProbe?: outputs.Tsf.DeployContainerGroupHealthCheckSettingsReadinessProbe;
    }

    export interface DeployContainerGroupHealthCheckSettingsLivenessProbe {
        actionType: string;
        commands?: string[];
        failureThreshold?: number;
        initialDelaySeconds?: number;
        path?: string;
        periodSeconds?: number;
        port?: number;
        scheme?: string;
        successThreshold?: number;
        timeoutSeconds?: number;
        type?: string;
    }

    export interface DeployContainerGroupHealthCheckSettingsReadinessProbe {
        actionType: string;
        commands?: string[];
        failureThreshold?: number;
        initialDelaySeconds?: number;
        path?: string;
        periodSeconds?: number;
        port?: number;
        scheme?: string;
        successThreshold?: number;
        timeoutSeconds?: number;
        type?: string;
    }

    export interface DeployContainerGroupSchedulingStrategy {
        type: string;
    }

    export interface DeployContainerGroupServiceSetting {
        accessType: number;
        allowDeleteService: boolean;
        disableService: boolean;
        headlessService: boolean;
        openSessionAffinity: boolean;
        protocolPorts: outputs.Tsf.DeployContainerGroupServiceSettingProtocolPort[];
        sessionAffinityTimeoutSeconds: number;
        subnetId: string;
    }

    export interface DeployContainerGroupServiceSettingProtocolPort {
        nodePort: number;
        port: number;
        protocol: string;
        targetPort: number;
    }

    export interface DeployContainerGroupVolumeInfoList {
        volumeConfig: string;
        volumeName: string;
        volumeType: string;
    }

    export interface DeployContainerGroupVolumeMountInfoList {
        readOrWrite: string;
        volumeMountName: string;
        volumeMountPath: string;
        volumeMountSubPath: string;
    }

    export interface DeployContainerGroupWarmupSetting {
        curvature: number;
        enabled: boolean;
        enabledProtection: boolean;
        warmupTime: number;
    }

    export interface DeployVmGroupAgentProfileList {
        agentType: string;
        agentVersion: string;
    }

    export interface DeployVmGroupHealthCheckSettings {
        livenessProbe: outputs.Tsf.DeployVmGroupHealthCheckSettingsLivenessProbe;
        readinessProbe: outputs.Tsf.DeployVmGroupHealthCheckSettingsReadinessProbe;
    }

    export interface DeployVmGroupHealthCheckSettingsLivenessProbe {
        actionType: string;
        commands: string[];
        failureThreshold: number;
        initialDelaySeconds: number;
        path: string;
        periodSeconds: number;
        port: number;
        scheme: string;
        successThreshold: number;
        timeoutSeconds: number;
        type: string;
    }

    export interface DeployVmGroupHealthCheckSettingsReadinessProbe {
        actionType: string;
        commands: string[];
        failureThreshold: number;
        initialDelaySeconds: number;
        path: string;
        periodSeconds: number;
        port: number;
        scheme: string;
        successThreshold: number;
        timeoutSeconds: number;
        type: string;
    }

    export interface DeployVmGroupWarmupSetting {
        curvature: number;
        enabled: boolean;
        enabledProtection: boolean;
        warmupTime: number;
    }

    export interface GetApiDetailResult {
        canRun: boolean;
        definitions: outputs.Tsf.GetApiDetailResultDefinition[];
        description: string;
        requestContentType: string;
        requests: outputs.Tsf.GetApiDetailResultRequest[];
        responses: outputs.Tsf.GetApiDetailResultResponse[];
        status: number;
    }

    export interface GetApiDetailResultDefinition {
        name: string;
        properties: outputs.Tsf.GetApiDetailResultDefinitionProperty[];
    }

    export interface GetApiDetailResultDefinitionProperty {
        description: string;
        name: string;
        type: string;
    }

    export interface GetApiDetailResultRequest {
        defaultValue: string;
        description: string;
        in: string;
        name: string;
        required: boolean;
        type: string;
    }

    export interface GetApiDetailResultResponse {
        description: string;
        name: string;
        type: string;
    }

    export interface GetApiGroupResult {
        contents: outputs.Tsf.GetApiGroupResultContent[];
        totalCount: number;
    }

    export interface GetApiGroupResultContent {
        aclMode: string;
        apiCount: number;
        authType: string;
        bindedGatewayDeployGroups: outputs.Tsf.GetApiGroupResultContentBindedGatewayDeployGroup[];
        createdTime: string;
        description: string;
        gatewayInstanceId: string;
        gatewayInstanceType: string;
        groupContext: string;
        groupId: string;
        groupName: string;
        groupType: string;
        namespaceNameKey: string;
        namespaceNameKeyPosition: string;
        serviceNameKey: string;
        serviceNameKeyPosition: string;
        status: string;
        updatedTime: string;
    }

    export interface GetApiGroupResultContentBindedGatewayDeployGroup {
        applicationId: string;
        applicationName: string;
        applicationType: string;
        clusterType: string;
        deployGroupId: string;
        deployGroupName: string;
        groupStatus: string;
    }

    export interface GetApplicationAttributeResult {
        groupCount: number;
        instanceCount: number;
        runInstanceCount: number;
    }

    export interface GetApplicationConfigResult {
        contents: outputs.Tsf.GetApplicationConfigResultContent[];
        totalCount: number;
    }

    export interface GetApplicationConfigResultContent {
        applicationId: string;
        applicationName: string;
        configId: string;
        configName: string;
        configType: string;
        configValue: string;
        configVersion: string;
        configVersionCount: number;
        configVersionDesc: string;
        creationTime: string;
        deleteFlag: boolean;
        lastUpdateTime: string;
    }

    export interface GetApplicationFileConfigResult {
        contents: outputs.Tsf.GetApplicationFileConfigResultContent[];
        totalCount: number;
    }

    export interface GetApplicationFileConfigResultContent {
        applicationId: string;
        applicationName: string;
        configFileCode: string;
        configFileName: string;
        configFilePath: string;
        configFileValue: string;
        configFileValueLength: number;
        configId: string;
        configName: string;
        configPostCmd: string;
        configVersion: string;
        configVersionCount: number;
        configVersionDesc: string;
        creationTime: string;
        deleteFlag: boolean;
        lastUpdateTime: string;
    }

    export interface GetApplicationPublicConfigResult {
        contents: outputs.Tsf.GetApplicationPublicConfigResultContent[];
        totalCount: number;
    }

    export interface GetApplicationPublicConfigResultContent {
        applicationId: string;
        applicationName: string;
        configId: string;
        configName: string;
        configType: string;
        configValue: string;
        configVersion: string;
        configVersionCount: number;
        configVersionDesc: string;
        creationTime: string;
        deleteFlag: boolean;
        lastUpdateTime: string;
    }

    export interface GetApplicationResult {
        contents: outputs.Tsf.GetApplicationResultContent[];
        totalCount: number;
    }

    export interface GetApplicationResultContent {
        apigatewayServiceId: string;
        applicationDesc: string;
        applicationId: string;
        applicationName: string;
        applicationRemarkName: string;
        applicationResourceType: string;
        applicationRuntimeType: string;
        applicationType: string;
        createTime: string;
        ignoreCreateImageRepository: boolean;
        microserviceType: string;
        progLang: string;
        serviceConfigLists: outputs.Tsf.GetApplicationResultContentServiceConfigList[];
        updateTime: string;
    }

    export interface GetApplicationResultContentServiceConfigList {
        healthChecks: outputs.Tsf.GetApplicationResultContentServiceConfigListHealthCheck[];
        name: string;
        ports: outputs.Tsf.GetApplicationResultContentServiceConfigListPort[];
    }

    export interface GetApplicationResultContentServiceConfigListHealthCheck {
        path: string;
    }

    export interface GetApplicationResultContentServiceConfigListPort {
        protocol: string;
        targetPort: number;
    }

    export interface GetBusinessLogConfigsResult {
        contents: outputs.Tsf.GetBusinessLogConfigsResultContent[];
        totalCount: number;
    }

    export interface GetBusinessLogConfigsResultContent {
        configAssociatedGroups: outputs.Tsf.GetBusinessLogConfigsResultContentConfigAssociatedGroup[];
        configCreateTime: string;
        configDesc: string;
        configId: string;
        configName: string;
        configPath: string;
        configPipeline: string;
        configSchemas: outputs.Tsf.GetBusinessLogConfigsResultContentConfigSchema[];
        configTags: string;
        configUpdateTime: string;
    }

    export interface GetBusinessLogConfigsResultContentConfigAssociatedGroup {
        applicationId: string;
        applicationName: string;
        applicationType: string;
        associatedTime: string;
        clusterId: string;
        clusterName: string;
        clusterType: string;
        groupId: string;
        groupName: string;
        namespaceId: string;
        namespaceName: string;
    }

    export interface GetBusinessLogConfigsResultContentConfigSchema {
        schemaContent: string;
        schemaCreateTime: string;
        schemaDateFormat: string;
        schemaMultilinePattern: string;
        schemaPatternLayout: string;
        schemaType: number;
    }

    export interface GetClusterResult {
        contents: outputs.Tsf.GetClusterResultContent[];
        totalCount: number;
    }

    export interface GetClusterResultContent {
        clusterCidr: string;
        clusterDesc: string;
        clusterId: string;
        clusterLimitCpu: number;
        clusterLimitMem: number;
        clusterName: string;
        clusterStatus: string;
        clusterTotalCpu: number;
        clusterTotalMem: number;
        clusterType: string;
        clusterUsedCpu: number;
        clusterUsedMem: number;
        clusterVersion: string;
        createTime: string;
        deleteFlag: boolean;
        deleteFlagReason: string;
        instanceCount: number;
        normalInstanceCount: number;
        operationInfos: outputs.Tsf.GetClusterResultContentOperationInfo[];
        runInstanceCount: number;
        runServiceInstanceCount: number;
        subnetId: string;
        tsfRegionId: string;
        tsfRegionName: string;
        tsfZoneId: string;
        tsfZoneName: string;
        updateTime: string;
        vpcId: string;
    }

    export interface GetClusterResultContentOperationInfo {
        addInstances: outputs.Tsf.GetClusterResultContentOperationInfoAddInstance[];
        destroys: outputs.Tsf.GetClusterResultContentOperationInfoDestroy[];
        inits: outputs.Tsf.GetClusterResultContentOperationInfoInit[];
    }

    export interface GetClusterResultContentOperationInfoAddInstance {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface GetClusterResultContentOperationInfoDestroy {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface GetClusterResultContentOperationInfoInit {
        disabledReason: string;
        enabled: boolean;
        supported: boolean;
    }

    export interface GetConfigSummaryResult {
        contents: outputs.Tsf.GetConfigSummaryResultContent[];
        totalCount: number;
    }

    export interface GetConfigSummaryResultContent {
        applicationId: string;
        applicationName: string;
        configId: string;
        configName: string;
        configType: string;
        configValue: string;
        configVersion: string;
        configVersionCount: number;
        configVersionDesc: string;
        creationTime: string;
        deleteFlag: boolean;
        lastUpdateTime: string;
    }

    export interface GetContainerGroupResult {
        contents: outputs.Tsf.GetContainerGroupResultContent[];
        totalCount: number;
    }

    export interface GetContainerGroupResultContent {
        alias: string;
        clusterId: string;
        clusterName: string;
        cpuLimit: string;
        cpuRequest: string;
        createTime: string;
        groupId: string;
        groupName: string;
        kubeInjectEnable: boolean;
        memLimit: string;
        memRequest: string;
        namespaceId: string;
        namespaceName: string;
        repoName: string;
        server: string;
        tagName: string;
        updatedTime: string;
    }

    export interface GetDeliveryConfigByGroupIdResult {
        configId: string;
        configName: string;
    }

    export interface GetDeliveryConfigsResult {
        contents: outputs.Tsf.GetDeliveryConfigsResultContent[];
        totalCount: number;
    }

    export interface GetDeliveryConfigsResultContent {
        collectPaths: string[];
        configId: string;
        configName: string;
        createTime: string;
        customRule: string;
        enableAuth: boolean;
        enableGlobalLineRule: boolean;
        groups: outputs.Tsf.GetDeliveryConfigsResultContentGroup[];
        kafkaAddress: string;
        kafkaInfos: outputs.Tsf.GetDeliveryConfigsResultContentKafkaInfo[];
        kafkaVIp: string;
        kafkaVPort: string;
        lineRule: string;
        password: string;
        topic: string;
        username: string;
    }

    export interface GetDeliveryConfigsResultContentGroup {
        associateTime: string;
        clusterId: string;
        clusterName: string;
        clusterType: string;
        groupId: string;
        groupName: string;
        namespaceName: string;
    }

    export interface GetDeliveryConfigsResultContentKafkaInfo {
        customRule: string;
        lineRule: string;
        paths: string[];
        topic: string;
    }

    export interface GetGatewayAllGroupApisResult {
        gatewayDeployGroupId: string;
        gatewayDeployGroupName: string;
        groupNum: number;
        groups: outputs.Tsf.GetGatewayAllGroupApisResultGroup[];
    }

    export interface GetGatewayAllGroupApisResultGroup {
        gatewayInstanceId: string;
        gatewayInstanceType: string;
        groupApiCount: number;
        groupApis: outputs.Tsf.GetGatewayAllGroupApisResultGroupGroupApi[];
        groupId: string;
        groupName: string;
    }

    export interface GetGatewayAllGroupApisResultGroupGroupApi {
        apiId: string;
        method: string;
        microserviceName: string;
        namespaceName: string;
        path: string;
    }

    export interface GetGroupConfigReleaseResult {
        configReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultConfigReleaseList[];
        fileConfigReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultFileConfigReleaseList[];
        packageId: string;
        packageName: string;
        packageVersion: string;
        publicConfigReleaseLists: outputs.Tsf.GetGroupConfigReleaseResultPublicConfigReleaseList[];
        repoName: string;
        tagName: string;
    }

    export interface GetGroupConfigReleaseResultConfigReleaseList {
        applicationId: string;
        clusterId: string;
        clusterName: string;
        configId: string;
        configName: string;
        configReleaseId: string;
        configVersion: string;
        groupId: string;
        groupName: string;
        namespaceId: string;
        namespaceName: string;
        releaseDesc: string;
        releaseTime: string;
    }

    export interface GetGroupConfigReleaseResultFileConfigReleaseList {
        clusterId: string;
        clusterName: string;
        configId: string;
        configName: string;
        configReleaseId: string;
        configVersion: string;
        groupId: string;
        groupName: string;
        namespaceId: string;
        namespaceName: string;
        releaseDesc: string;
        releaseTime: string;
    }

    export interface GetGroupConfigReleaseResultPublicConfigReleaseList {
        applicationId: string;
        clusterId: string;
        clusterName: string;
        configId: string;
        configName: string;
        configReleaseId: string;
        configVersion: string;
        groupId: string;
        groupName: string;
        namespaceId: string;
        namespaceName: string;
        releaseDesc: string;
        releaseTime: string;
    }

    export interface GetGroupGatewaysResult {
        contents: outputs.Tsf.GetGroupGatewaysResultContent[];
        totalCount: number;
    }

    export interface GetGroupGatewaysResultContent {
        aclMode: string;
        apiCount: number;
        authType: string;
        bindedGatewayDeployGroups: outputs.Tsf.GetGroupGatewaysResultContentBindedGatewayDeployGroup[];
        createdTime: string;
        description: string;
        gatewayInstanceId: string;
        gatewayInstanceType: string;
        groupContext: string;
        groupId: string;
        groupName: string;
        groupType: string;
        namespaceNameKey: string;
        namespaceNameKeyPosition: string;
        serviceNameKey: string;
        serviceNameKeyPosition: string;
        status: string;
        updatedTime: string;
    }

    export interface GetGroupGatewaysResultContentBindedGatewayDeployGroup {
        applicationId: string;
        applicationName: string;
        applicationType: string;
        clusterType: string;
        deployGroupId: string;
        deployGroupName: string;
        groupStatus: string;
    }

    export interface GetGroupInstancesResult {
        contents: outputs.Tsf.GetGroupInstancesResultContent[];
        totalCount: number;
    }

    export interface GetGroupInstancesResultContent {
        agentVersion: string;
        applicationId: string;
        applicationName: string;
        applicationResourceType: string;
        applicationType: string;
        clusterId: string;
        clusterName: string;
        clusterType: string;
        countInTsf: number;
        groupId: string;
        groupName: string;
        instanceAvailableStatus: string;
        instanceChargeType: string;
        instanceCreatedTime: string;
        instanceDesc: string;
        instanceExpiredTime: string;
        instanceId: string;
        instanceImportMode: string;
        instanceLimitCpu: number;
        instanceLimitMem: number;
        instanceName: string;
        instancePkgVersion: string;
        instanceStatus: string;
        instanceTotalCpu: number;
        instanceTotalMem: number;
        instanceUsedCpu: number;
        instanceUsedMem: number;
        instanceZoneId: string;
        lanIp: string;
        namespaceId: string;
        namespaceName: string;
        nodeInstanceId: string;
        operationState: number;
        reason: string;
        restrictState: string;
        serviceInstanceStatus: string;
        serviceSidecarStatus: string;
        updateTime: string;
        wanIp: string;
    }

    export interface GetGroupsResult {
        contents: outputs.Tsf.GetGroupsResultContent[];
        totalCount: number;
    }

    export interface GetGroupsResultContent {
        alias: string;
        applicationId: string;
        applicationName: string;
        applicationType: string;
        clusterId: string;
        clusterName: string;
        createTime: string;
        deployDesc: string;
        groupDesc: string;
        groupId: string;
        groupName: string;
        groupResourceType: string;
        microserviceType: string;
        namespaceId: string;
        namespaceName: string;
        startupParameters: string;
        updateTime: string;
        updatedTime: number;
    }

    export interface GetMicroserviceApiVersionResult {
        applicationId: string;
        applicationName: string;
        pkgVersion: string;
    }

    export interface GetMicroserviceResult {
        contents: outputs.Tsf.GetMicroserviceResultContent[];
        totalCount: number;
    }

    export interface GetMicroserviceResultContent {
        createTime: number;
        criticalInstanceCount: number;
        microserviceDesc: string;
        microserviceId: string;
        microserviceName: string;
        namespaceId: string;
        runInstanceCount: number;
        updateTime: number;
    }

    export interface GetMsApiListResult {
        contents: outputs.Tsf.GetMsApiListResultContent[];
        totalCount: number;
    }

    export interface GetMsApiListResultContent {
        description: string;
        method: string;
        path: string;
        status: number;
    }

    export interface GetPodInstancesResult {
        contents: outputs.Tsf.GetPodInstancesResultContent[];
        totalCount: number;
    }

    export interface GetPodInstancesResultContent {
        createdAt: string;
        instanceAvailableStatus: string;
        instanceStatus: string;
        ip: string;
        nodeInstanceId: string;
        nodeIp: string;
        podId: string;
        podName: string;
        readyCount: number;
        reason: string;
        restartCount: number;
        runtime: string;
        serviceInstanceStatus: string;
        status: string;
    }

    export interface GetPublicConfigSummaryResult {
        contents: outputs.Tsf.GetPublicConfigSummaryResultContent[];
        totalCount: number;
    }

    export interface GetPublicConfigSummaryResultContent {
        applicationId: string;
        applicationName: string;
        configId: string;
        configName: string;
        configType: string;
        configValue: string;
        configVersion: string;
        configVersionCount: number;
        configVersionDesc: string;
        creationTime: string;
        deleteFlag: boolean;
        lastUpdateTime: string;
    }

    export interface GetRepositoryResult {
        contents: outputs.Tsf.GetRepositoryResultContent[];
        totalCount: number;
    }

    export interface GetRepositoryResultContent {
        bucketName: string;
        bucketRegion: string;
        createTime: string;
        directory: string;
        isUsed: boolean;
        repositoryDesc: string;
        repositoryId: string;
        repositoryName: string;
        repositoryType: string;
    }

    export interface GetUnitRulesResult {
        contents: outputs.Tsf.GetUnitRulesResultContent[];
        totalCount: number;
    }

    export interface GetUnitRulesResultContent {
        createdTime: string;
        description: string;
        gatewayInstanceId: string;
        id: string;
        name: string;
        status: string;
        unitRuleItemLists: outputs.Tsf.GetUnitRulesResultContentUnitRuleItemList[];
        updatedTime: string;
    }

    export interface GetUnitRulesResultContentUnitRuleItemList {
        description: string;
        destNamespaceId: string;
        destNamespaceName: string;
        id: string;
        name: string;
        priority: number;
        relationship: string;
        unitRuleId: string;
        unitRuleTagLists: outputs.Tsf.GetUnitRulesResultContentUnitRuleItemListUnitRuleTagList[];
    }

    export interface GetUnitRulesResultContentUnitRuleItemListUnitRuleTagList {
        id: string;
        tagField: string;
        tagOperator: string;
        tagType: string;
        tagValue: string;
        unitRuleItemId: string;
    }

    export interface GetUsableUnitNamespacesResult {
        contents: outputs.Tsf.GetUsableUnitNamespacesResultContent[];
        totalCount: number;
    }

    export interface GetUsableUnitNamespacesResultContent {
        createdTime: string;
        gatewayInstanceId: string;
        id: string;
        namespaceId: string;
        namespaceName: string;
        updatedTime: string;
    }

    export interface InstancesAttachmentInstanceAdvancedSettings {
        dockerGraphPath: string;
        mountTarget: string;
    }

    export interface LaneLaneGroupList {
        applicationId?: string;
        applicationName?: string;
        clusterType?: string;
        createTime?: number;
        entrance: boolean;
        groupId: string;
        groupName?: string;
        laneGroupId?: string;
        laneId?: string;
        namespaceId?: string;
        namespaceName?: string;
        updateTime?: number;
    }

    export interface LaneRuleRuleTagList {
        createTime: number;
        laneRuleId: string;
        tagId: string;
        tagName: string;
        tagOperator: string;
        tagValue: string;
        updateTime: number;
    }

    export interface TaskAdvanceSettings {
        subTaskConcurrency?: number;
    }

    export interface TaskShardArgument {
        shardKey: number;
        shardValue: string;
    }

    export interface TaskTaskRule {
        expression?: string;
        repeatInterval?: number;
        ruleType: string;
    }

    export interface UnitRuleUnitRuleItemList {
        description?: string;
        destNamespaceId: string;
        destNamespaceName: string;
        name: string;
        priority?: number;
        relationship: string;
        ruleId: string;
        unitRuleId: string;
        unitRuleTagLists?: outputs.Tsf.UnitRuleUnitRuleItemListUnitRuleTagList[];
    }

    export interface UnitRuleUnitRuleItemListUnitRuleTagList {
        ruleId: string;
        tagField: string;
        tagOperator: string;
        tagType: string;
        tagValue: string;
        unitRuleItemId: string;
    }

}

export namespace Vod {
    export interface AdaptiveDynamicStreamingTemplateStreamInfo {
        audio: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoAudio;
        removeAudio?: boolean;
        video: outputs.Vod.AdaptiveDynamicStreamingTemplateStreamInfoVideo;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoAudio {
        audioChannel?: string;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface AdaptiveDynamicStreamingTemplateStreamInfoVideo {
        bitrate: number;
        codec: string;
        fillType?: string;
        fps: number;
        height?: number;
        resolutionAdaptive?: boolean;
        width?: number;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateList {
        comment: string;
        createTime: string;
        definition: string;
        disableHigherVideoBitrate: boolean;
        disableHigherVideoResolution: boolean;
        drmType: string;
        format: string;
        name: string;
        streamInfos: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfo[];
        type: string;
        updateTime: string;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfo {
        audios: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio[];
        removeAudio: boolean;
        videos: outputs.Vod.GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo[];
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoAudio {
        audioChannel: string;
        bitrate: number;
        codec: string;
        sampleRate: number;
    }

    export interface GetAdaptiveDynamicStreamingTemplatesTemplateListStreamInfoVideo {
        bitrate: number;
        codec: string;
        fillType: string;
        fps: number;
        height: number;
        resolutionAdaptive: boolean;
        width: number;
    }

    export interface GetImageSpriteTemplatesTemplateList {
        columnCount: number;
        comment: string;
        createTime: string;
        definition: string;
        fillType: string;
        height: number;
        name: string;
        resolutionAdaptive: boolean;
        rowCount: number;
        sampleInterval: number;
        sampleType: string;
        type: string;
        updateTime: string;
        width: number;
    }

    export interface GetProcedureTemplatesTemplateList {
        comment: string;
        createTime: string;
        mediaProcessTasks: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTask[];
        name: string;
        type: string;
        updateTime: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTask {
        adaptiveDynamicStreamingTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        animatedGraphicTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList[];
        coverBySnapshotTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList[];
        imageSpriteTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList[];
        sampleSnapshotTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList[];
        snapshotByTimeOffsetTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        transcodeTaskLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        definition: string;
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskAnimatedGraphicTaskList {
        definition: string;
        endTimeOffset: number;
        startTimeOffset: number;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskList {
        definition: string;
        positionType: string;
        positionValue: number;
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskImageSpriteTaskList {
        definition: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskList {
        definition: string;
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskList {
        definition: string;
        extTimeOffsetLists: string[];
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskList {
        definition: string;
        mosaicLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList[];
        watermarkLists: outputs.Vod.GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListMosaicList {
        coordinateOrigin: string;
        endTimeOffset: number;
        height: string;
        startTimeOffset: number;
        width: string;
        xPos: string;
        yPos: string;
    }

    export interface GetProcedureTemplatesTemplateListMediaProcessTaskTranscodeTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface GetSnapshotByTimeOffsetTemplatesTemplateList {
        comment: string;
        createTime: string;
        definition: string;
        fillType: string;
        format: string;
        height: number;
        name: string;
        resolutionAdaptive: boolean;
        type: string;
        updateTime: string;
        width: number;
    }

    export interface GetSuperPlayerConfigsConfigList {
        adaptiveDynamicStreamingDefinition: string;
        comment: string;
        createTime: string;
        domain: string;
        drmStreamingInfos: outputs.Vod.GetSuperPlayerConfigsConfigListDrmStreamingInfo[];
        drmSwitch: boolean;
        imageSpriteDefinition: string;
        name: string;
        resolutionNames: outputs.Vod.GetSuperPlayerConfigsConfigListResolutionName[];
        scheme: string;
        type: string;
        updateTime: string;
    }

    export interface GetSuperPlayerConfigsConfigListDrmStreamingInfo {
        simpleAesDefinition: string;
    }

    export interface GetSuperPlayerConfigsConfigListResolutionName {
        minEdgeLength: number;
        name: string;
    }

    export interface ProcedureTemplateMediaProcessTask {
        adaptiveDynamicStreamingTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList[];
        animatedGraphicTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList[];
        coverBySnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList[];
        imageSpriteTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskImageSpriteTaskList[];
        sampleSnapshotTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList[];
        snapshotByTimeOffsetTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList[];
        transcodeTaskLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskList {
        definition: string;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskAdaptiveDynamicStreamingTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskAnimatedGraphicTaskList {
        definition: string;
        endTimeOffset: number;
        startTimeOffset: number;
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskList {
        definition: string;
        positionType: string;
        positionValue: number;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskCoverBySnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskImageSpriteTaskList {
        definition: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskList {
        definition: string;
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSampleSnapshotTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskList {
        definition: string;
        extTimeOffsetLists?: string[];
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskSnapshotByTimeOffsetTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskList {
        definition: string;
        mosaicLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList[];
        watermarkLists?: outputs.Vod.ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList[];
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListMosaicList {
        coordinateOrigin?: string;
        endTimeOffset?: number;
        height?: string;
        startTimeOffset?: number;
        width?: string;
        xPos?: string;
        yPos?: string;
    }

    export interface ProcedureTemplateMediaProcessTaskTranscodeTaskListWatermarkList {
        definition: string;
        endTimeOffset?: number;
        startTimeOffset?: number;
        svgContent?: string;
        textContent?: string;
    }

    export interface SuperPlayerConfigDrmStreamingInfo {
        simpleAesDefinition?: string;
    }

    export interface SuperPlayerConfigResolutionName {
        minEdgeLength: number;
        name: string;
    }

}

export namespace Vpc {
    export interface FlowLogFlowLogStorage {
        storageId: string;
        storageTopic: string;
    }

    export interface GetAccountAttributesAccountAttributeSet {
        attributeName: string;
        attributeValues: string[];
    }

    export interface GetAclsAclList {
        createTime: string;
        egresses: outputs.Vpc.GetAclsAclListEgress[];
        id: string;
        ingresses: outputs.Vpc.GetAclsAclListIngress[];
        name: string;
        subnets: outputs.Vpc.GetAclsAclListSubnet[];
        vpcId: string;
    }

    export interface GetAclsAclListEgress {
        cidrBlock: string;
        description: string;
        policy: string;
        port: string;
        protocol: string;
    }

    export interface GetAclsAclListIngress {
        cidrBlock: string;
        description: string;
        policy: string;
        port: string;
        protocol: string;
    }

    export interface GetAclsAclListSubnet {
        cidrBlock: string;
        subnetId: string;
        subnetName: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetBandwidthPackageBillUsageBandwidthPackageBillBandwidthSet {
        bandwidthUsage: number;
    }

    export interface GetBandwidthPackageQuotaQuotaSet {
        quotaCurrent: number;
        quotaId: string;
        quotaLimit: number;
    }

    export interface GetClassicLinkInstancesClassicLinkInstanceSet {
        instanceId: string;
        vpcId: string;
    }

    export interface GetClassicLinkInstancesFilter {
        name: string;
        values: string[];
    }

    export interface GetCvmInstancesFilter {
        name: string;
        values: string[];
    }

    export interface GetCvmInstancesInstanceSet {
        cpu: number;
        createdTime: string;
        eniIpLimit: number;
        eniLimit: number;
        instanceEniCount: number;
        instanceId: string;
        instanceName: string;
        instanceState: string;
        instanceType: string;
        memory: number;
        subnetId: string;
        vpcId: string;
    }

    export interface GetGatewayFlowMonitorDetailGatewayFlowMonitorDetailSet {
        inPkg: number;
        inTraffic: number;
        outPkg: number;
        outTraffic: number;
        privateIpAddress: string;
    }

    export interface GetGatewayFlowQosGatewayQosSet {
        bandwidth: number;
        createTime: string;
        ipAddress: string;
        vpcId: string;
    }

    export interface GetInstancesInstanceList {
        cidrBlock: string;
        createTime: string;
        dnsServers: string[];
        isDefault: boolean;
        isMulticast: boolean;
        name: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetLimitsVpcLimitSet {
        limitType: string;
        limitValue: number;
    }

    export interface GetNetDetectStateCheckNetDetectIpStateSet {
        delay: number;
        detectDestinationIp: string;
        packetLossRate: number;
        state: number;
    }

    export interface GetNetDetectStatesFilter {
        name: string;
        values: string[];
    }

    export interface GetNetDetectStatesNetDetectStateSet {
        netDetectId: string;
        netDetectIpStateSets: outputs.Vpc.GetNetDetectStatesNetDetectStateSetNetDetectIpStateSet[];
    }

    export interface GetNetDetectStatesNetDetectStateSetNetDetectIpStateSet {
        delay: number;
        detectDestinationIp: string;
        packetLossRate: number;
        state: number;
    }

    export interface GetPrivateIpAddressesVpcPrivateIpAddressSet {
        cidrBlock: string;
        createdTime: string;
        privateIpAddress: string;
        privateIpAddressType: string;
    }

    export interface GetProductQuotaProductQuotaSet {
        quotaCurrent: number;
        quotaId: string;
        quotaLimit: number;
        quotaName: string;
        quotaRegion: boolean;
    }

    export interface GetResourceDashboardResourceDashboardSet {
        cdb: number;
        cfs: number;
        ckafka: number;
        classicLink: number;
        cmem: number;
        cnas: number;
        ctsDb: number;
        cvm: number;
        cynosDbMysql: number;
        cynosDbPostgres: number;
        dbAudit: number;
        dcdb: number;
        dcg: number;
        elasticSearch: number;
        emr: number;
        flowLog: number;
        greenplumn: number;
        grocery: number;
        hsm: number;
        ip: number;
        itop: number;
        lb: number;
        mariaDb: number;
        mongoDb: number;
        nas: number;
        nat: number;
        networkAcl: number;
        networkDetect: number;
        oracle: number;
        pcx: number;
        postgres: number;
        redis: number;
        routeTable: number;
        seal: number;
        sqlServer: number;
        subnet: number;
        subnetId: string;
        tBaas: number;
        tcaplus: number;
        tiDb: number;
        vpcId: string;
        vpngw: number;
    }

    export interface GetRouteConflictsRouteConflictSet {
        conflictSets: outputs.Vpc.GetRouteConflictsRouteConflictSetConflictSet[];
        destinationCidrBlock: string;
        routeTableId: string;
    }

    export interface GetRouteConflictsRouteConflictSetConflictSet {
        createdTime: string;
        destinationCidrBlock: string;
        destinationIpv6CidrBlock: string;
        enabled: boolean;
        gatewayId: string;
        gatewayType: string;
        publishedToVbc: boolean;
        routeDescription: string;
        routeId: number;
        routeItemId: string;
        routeTableId: string;
        routeType: string;
    }

    export interface GetRouteTablesInstanceList {
        createTime: string;
        isDefault: boolean;
        name: string;
        routeEntryInfos: outputs.Vpc.GetRouteTablesInstanceListRouteEntryInfo[];
        routeTableId: string;
        subnetIds: string[];
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetRouteTablesInstanceListRouteEntryInfo {
        description: string;
        destinationCidrBlock: string;
        nextHub: string;
        nextType: string;
        routeEntryId: string;
    }

    export interface GetSecurityGroupLimitsSecurityGroupLimitSet {
        instanceSecurityGroupLimit: number;
        referredSecurityGroupLimit: number;
        securityGroupExtendedPolicyLimit: number;
        securityGroupInstanceLimit: number;
        securityGroupLimit: number;
        securityGroupPolicyLimit: number;
        securityGroupReferredCvmAndEniLimit: number;
        securityGroupReferredSvcLimit: number;
    }

    export interface GetSecurityGroupReferencesReferredSecurityGroupSet {
        referredSecurityGroupIds: string[];
        securityGroupId: string;
    }

    export interface GetSgSnapshotFileContentBackupData {
        action: string;
        addressTemplates: outputs.Vpc.GetSgSnapshotFileContentBackupDataAddressTemplate[];
        cidrBlock: string;
        ipv6CidrBlock: string;
        modifyTime: string;
        policyDescription: string;
        policyIndex: number;
        port: string;
        protocol: string;
        securityGroupId: string;
        serviceTemplates: outputs.Vpc.GetSgSnapshotFileContentBackupDataServiceTemplate[];
    }

    export interface GetSgSnapshotFileContentBackupDataAddressTemplate {
        addressGroupId: string;
        addressId: string;
    }

    export interface GetSgSnapshotFileContentBackupDataServiceTemplate {
        serviceGroupId: string;
        serviceId: string;
    }

    export interface GetSgSnapshotFileContentOriginalData {
        action: string;
        addressTemplates: outputs.Vpc.GetSgSnapshotFileContentOriginalDataAddressTemplate[];
        cidrBlock: string;
        ipv6CidrBlock: string;
        modifyTime: string;
        policyDescription: string;
        policyIndex: number;
        port: string;
        protocol: string;
        securityGroupId: string;
        serviceTemplates: outputs.Vpc.GetSgSnapshotFileContentOriginalDataServiceTemplate[];
    }

    export interface GetSgSnapshotFileContentOriginalDataAddressTemplate {
        addressGroupId: string;
        addressId: string;
    }

    export interface GetSgSnapshotFileContentOriginalDataServiceTemplate {
        serviceGroupId: string;
        serviceId: string;
    }

    export interface GetSnapshotFilesSnapshotFileSet {
        backupTime: string;
        instanceId: string;
        operator: string;
        snapshotFileId: string;
        snapshotPolicyId: string;
    }

    export interface GetSubnetResourceDashboardResourceStatisticsSet {
        ip: number;
        resourceStatisticsItemSets: outputs.Vpc.GetSubnetResourceDashboardResourceStatisticsSetResourceStatisticsItemSet[];
        subnetId: string;
        vpcId: string;
    }

    export interface GetSubnetResourceDashboardResourceStatisticsSetResourceStatisticsItemSet {
        resourceCount: number;
        resourceName: string;
        resourceType: string;
    }

    export interface GetSubnetsInstanceList {
        availabilityZone: string;
        availableIpCount: number;
        cidrBlock: string;
        createTime: string;
        isDefault: boolean;
        isMulticast: boolean;
        name: string;
        routeTableId: string;
        subnetId: string;
        tags: {[key: string]: any};
        vpcId: string;
    }

    export interface GetTemplateLimitsTemplateLimit {
        addressTemplateGroupMemberLimit: number;
        addressTemplateMemberLimit: number;
        serviceTemplateGroupMemberLimit: number;
        serviceTemplateMemberLimit: number;
    }

    export interface GetUsedIpAddressIpAddressState {
        ipAddress: string;
        resourceId: string;
        resourceType: string;
        subnetId: string;
        vpcId: string;
    }

    export interface Ipv6EniAddressIpv6Address {
        address: string;
        addressId?: string;
        description?: string;
        isWanIpBlocked?: boolean;
        primary?: boolean;
        state?: string;
    }

    export interface Ipv6SubnetCidrBlockIpv6SubnetCidrBlocks {
        ipv6CidrBlock: string;
        subnetId: string;
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSet {
        egresses?: outputs.Vpc.NetworkAclQuintupleNetworkAclQuintupleSetEgress[];
        ingresses?: outputs.Vpc.NetworkAclQuintupleNetworkAclQuintupleSetIngress[];
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSetEgress {
        action?: string;
        createTime?: string;
        description?: string;
        destinationCidr?: string;
        destinationPort?: string;
        networkAclDirection?: string;
        networkAclQuintupleEntryId?: string;
        priority?: number;
        protocol?: string;
        sourceCidr?: string;
        sourcePort?: string;
    }

    export interface NetworkAclQuintupleNetworkAclQuintupleSetIngress {
        action?: string;
        createTime?: string;
        description?: string;
        destinationCidr?: string;
        destinationPort?: string;
        networkAclDirection?: string;
        networkAclQuintupleEntryId?: string;
        priority?: number;
        protocol?: string;
        sourceCidr?: string;
        sourcePort?: string;
    }

    export interface SnapshotPolicyAttachmentInstance {
        instanceId: string;
        instanceName: string;
        instanceRegion: string;
        instanceType: string;
        snapshotPolicyId: string;
    }

    export interface SnapshotPolicyBackupPolicy {
        backupDay: string;
        backupTime: string;
    }

}

export namespace Vpn {
    export interface ConnectionSecurityGroupPolicy {
        localCidrBlock: string;
        remoteCidrBlocks: string[];
    }

    export interface CustomerGatewayConfigurationDownloadCustomerGatewayVendor {
        platform: string;
        softwareVersion: string;
        vendorName: string;
    }

    export interface GetConnectionsConnectionList {
        createTime: string;
        customerGatewayId: string;
        encryptProto: string;
        id: string;
        ikeDhGroupName: string;
        ikeExchangeMode: string;
        ikeLocalAddress: string;
        ikeLocalFqdnName: string;
        ikeLocalIdentity: string;
        ikeProtoAuthenAlgorithm: string;
        ikeProtoEncryAlgorithm: string;
        ikeRemoteAddress: string;
        ikeRemoteFqdnName: string;
        ikeRemoteIdentity: string;
        ikeSaLifetimeSeconds: number;
        ikeVersion: string;
        ipsecEncryptAlgorithm: string;
        ipsecIntegrityAlgorithm: string;
        ipsecPfsDhGroup: string;
        ipsecSaLifetimeSeconds: number;
        ipsecSaLifetimeTraffic: number;
        name: string;
        netStatus: string;
        preShareKey: string;
        routeType: string;
        securityGroupPolicies: outputs.Vpn.GetConnectionsConnectionListSecurityGroupPolicy[];
        state: string;
        tags: {[key: string]: any};
        vpcId: string;
        vpnGatewayId: string;
        vpnProto: string;
    }

    export interface GetConnectionsConnectionListSecurityGroupPolicy {
        localCidrBlock: string;
        remoteCidrBlocks: string[];
    }

    export interface GetCustomerGatewayVendorsCustomerGatewayVendorSet {
        platform: string;
        softwareVersion: string;
        vendorName: string;
    }

    export interface GetCustomerGatewaysGatewayList {
        createTime: string;
        id: string;
        name: string;
        publicIpAddress: string;
        tags: {[key: string]: any};
    }

    export interface GetGatewayRoutesVpnGatewayRouteList {
        createTime: string;
        destinationCidrBlock: string;
        instanceId: string;
        instanceType: string;
        priority: number;
        routeId: string;
        status: string;
        type: string;
        updateTime: string;
        vpnGatewayId: string;
    }

    export interface GetGatewaysGatewayList {
        bandwidth: number;
        chargeType: string;
        createTime: string;
        expiredTime: string;
        id: string;
        isAddressBlocked: boolean;
        name: string;
        newPurchasePlan: string;
        prepaidRenewFlag: string;
        publicIpAddress: string;
        restrictState: string;
        state: string;
        tags: {[key: string]: any};
        type: string;
        vpcId: string;
        zone: string;
    }

}

export namespace Wedata {
    export interface GetRuleTemplatesData {
        citationCount: number;
        compareType: number;
        description: string;
        multiSourceFlag: boolean;
        name: string;
        qualityDim: number;
        ruleTemplateId: number;
        sourceContent: string;
        sourceEngineTypes: number[];
        sourceObjectDataType: number;
        sourceObjectType: number;
        sqlExpression: string;
        subQualityDim: number;
        type: number;
        updateTime: string;
        userId: number;
        userName: string;
        whereFlag: boolean;
    }

}

export namespace config {
    export interface AssumeRole {
        policy?: string;
        roleArn: string;
        sessionDuration: number;
        sessionName: string;
    }

}
